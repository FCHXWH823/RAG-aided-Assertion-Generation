Master Module,Code,golden_assertions,llm_assertions
or1200_if,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's instruction fetch                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  PC, instruction fetch, interface to IC.                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_if.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_if(
	// Clock and reset
	clk, rst,

	// External i/f to IC
	icpu_dat_i, icpu_ack_i, icpu_err_i, icpu_adr_i, icpu_tag_i,

	// Internal i/f
	if_freeze, if_insn, if_pc, if_flushpipe, saving_if_insn, 
	if_stall, no_more_dslot, genpc_refetch, rfe,
	except_itlbmiss, except_immufault, except_ibuserr
);

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External i/f to IC
//
input	[31:0]			icpu_dat_i;
input				icpu_ack_i;
input				icpu_err_i;
input	[31:0]			icpu_adr_i;
input	[3:0]			icpu_tag_i;

//
// Internal i/f
//
input				if_freeze;
output	[31:0]			if_insn;
output	[31:0]			if_pc;
input				if_flushpipe;
output				saving_if_insn;
output				if_stall;
input				no_more_dslot;
output				genpc_refetch;
input				rfe;
output				except_itlbmiss;
output				except_immufault;
output				except_ibuserr;

//
// Internal wires and regs
//
wire			save_insn;
wire			if_bypass;
reg			if_bypass_reg;
reg	[31:0]		insn_saved;
reg	[31:0]		addr_saved;
reg	[2:0]		err_saved;
reg			saved;

assign save_insn = (icpu_ack_i | icpu_err_i) & if_freeze & !saved;
assign saving_if_insn = !if_flushpipe & save_insn;

//
// IF bypass 
//
assign if_bypass = icpu_adr_i[0] ? 1'b0 : if_bypass_reg | if_flushpipe;

always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		if_bypass_reg <=  1'b0;
	else
		if_bypass_reg <=  if_bypass;

//
// IF stage insn
//
assign if_insn = no_more_dslot | rfe | if_bypass ? {`OR1200_OR32_NOP, 26'h041_0000} : saved ? insn_saved : icpu_ack_i ? icpu_dat_i : {`OR1200_OR32_NOP, 26'h061_0000};
assign if_pc = saved ? addr_saved : {icpu_adr_i[31:2], 2'h0};
assign if_stall = !icpu_err_i & !icpu_ack_i & !saved;
assign genpc_refetch = saved & icpu_ack_i;
assign except_itlbmiss = no_more_dslot ? 1'b0 : saved ? err_saved[0] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_TE);
assign except_immufault = no_more_dslot ? 1'b0 : saved ? err_saved[1] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_PE);
assign except_ibuserr = no_more_dslot ? 1'b0 : saved ? err_saved[2] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_BE);

//
// Flag for saved insn/address
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		saved <=  1'b0;
	else if (if_flushpipe)
		saved <=  1'b0;
	else if (save_insn)
		saved <=  1'b1;
	else if (!if_freeze)
		saved <=  1'b0;

//
// Store fetched instruction
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (if_flushpipe)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (save_insn)
		insn_saved <=  icpu_err_i ? {`OR1200_OR32_NOP, 26'h041_0000} : icpu_dat_i;
	else if (!if_freeze)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};

//
// Store fetched instruction's address
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		addr_saved <=  32'h00000000;
	else if (if_flushpipe)
		addr_saved <=  32'h00000000;
	else if (save_insn)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};
	else if (!if_freeze)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};

//
// Store fetched instruction's error tags 
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		err_saved <=  3'b000;
	else if (if_flushpipe)
		err_saved <=  3'b000;
	else if (save_insn) begin
		err_saved[0] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_TE);
		err_saved[1] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_PE);
		err_saved[2] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_BE);
	end
	else if (!if_freeze)
		err_saved <=  3'b000;


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""no_more_dslot |-> (except_itlbmiss == 0 && except_immufault == 0 && except_ibuserr == 0)"",
    ""Signals"": [""no_more_dslot"", ""except_itlbmiss"", ""except_immufault"", ""except_ibuserr""],
    ""Signal Explanations"": {
      ""no_more_dslot"": ""input signal indicating that there is no delay slot instruction"",
      ""except_itlbmiss"": ""output signal indicating an ITLB miss exception"",
      ""except_immufault"": ""output signal indicating an immediate fault exception"",
      ""except_ibuserr"": ""output signal indicating an instruction bus error exception""
    },
    ""Logical Operators"": [""|->"", ""=="", ""&&""],
    ""Logical Operators Explanation"": {
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&&"": ""and""
    },
    ""Assertion Explaination"": ""when no delay slot instruction signal is true, then ITLB miss exception equals 0 and immediate fault exception equals 0 and instruction bus error exception equals 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 saved == 1"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""saved"": ""flag indicating if an instruction has been saved""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then saved flag equals 1 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 saved == 0"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""saved"": ""flag indicating if an instruction has been saved""
    },
    ""Logical Operators"": [""|"", ""!"", ""&&"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""|"": ""or"",
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true or both save instruction condition is reset (0) and pipeline freeze is reset (0), then saved flag equals 0 from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn && !icpu_err_i) |-> ##1 (insn_saved == $past(icpu_dat_i))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""icpu_err_i"", ""insn_saved"", ""icpu_dat_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""insn_saved"": ""register holding the saved instruction"",
      ""icpu_dat_i"": ""input data from the instruction cache""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true and instruction cache error signal is reset (0), then insn_saved equals the previous clock cycle's instruction cache data from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze) && !icpu_err_i) |-> ##1 (insn_saved == {6'b000101, 26'h041_0000})"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""icpu_err_i"", ""insn_saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""insn_saved"": ""register holding the saved instruction""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|"": ""or"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true or both save instruction condition is reset (0) and pipeline freeze is reset (0) and instruction cache error is reset (0), then insn_saved equals the constant value {6'b000101, 26'h041_0000} from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && (save_insn | !if_freeze)) |-> ##1 (addr_saved == {$past(icpu_adr_i[31:2]), 2'b00})"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""addr_saved"", ""icpu_adr_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""addr_saved"": ""register holding the saved instruction address"",
      ""icpu_adr_i"": ""input signal providing the instruction cache address""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|"", ""|->"", ""##1"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|"": ""or"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and either save instruction is true or pipeline freeze is reset (0), then addr_saved equals the previous clock cycle's instruction cache address with its lower two bits set to 0 from the next clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe) |-> ##1 (addr_saved == 32'h00000000)"",
    ""Signals"": [""if_flushpipe"", ""addr_saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""addr_saved"": ""register holding the saved instruction address""
    },
    ""Logical Operators"": [""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""|->"": ""if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true then addr_saved equals 32'h00000000 from the next clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[0] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hd)))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""err_saved[0]"", ""icpu_err_i"", ""icpu_tag_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""err_saved[0]"": ""bit 0 of the saved error register representing an ITLB miss"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""icpu_tag_i"": ""input signal providing the instruction cache tag""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""&"", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&"": ""and"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then the first bit of the saved error register equals the logical AND of the previous clock cycle's instruction cache error signal and the result of comparing the previous clock cycle's instruction cache tag signal equal to 4'hd from the next clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[1] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hc)))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""err_saved[1]"", ""icpu_err_i"", ""icpu_tag_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""err_saved[1]"": ""bit 1 of the saved error register representing an immediate fault"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""icpu_tag_i"": ""input signal providing the instruction cache tag""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""&"", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&"": ""and"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then the second bit of the saved error register equals the logical AND of the previous clock cycle's instruction cache error signal and the result of comparing the previous clock cycle's instruction cache tag signal equal to 4'hc from the next clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[2] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hb)))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""err_saved[2]"", ""icpu_err_i"", ""icpu_tag_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""err_saved[2]"": ""bit 2 of the saved error register representing an instruction bus error"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""icpu_tag_i"": ""input signal providing the instruction cache tag""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""&"", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&"": ""and"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then the third bit of the saved error register equals the logical AND of the previous clock cycle's instruction cache error signal and the result of comparing the previous clock cycle's instruction cache tag signal equal to 4'hb from the next clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 (err_saved == 3'b000)"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""err_saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""err_saved"": ""register holding the saved error tags for the instruction""
    },
    ""Logical Operators"": [""|"", ""!"", ""&&"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""|"": ""or"",
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true or both save instruction condition is reset (0) and pipeline freeze is reset (0), then err_saved equals 3'b000 from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property (no_more_dslot |-> (except_itlbmiss == 0 && except_immufault == 0 && except_ibuserr == 0));"",
""Assertion 2"": ""assert property ((!if_flushpipe && ((icpu_ack_i | icpu_err_i) & if_freeze & !saved)) |=> (saved == 1'b1));"",
""Assertion 3"": ""assert property ((if_flushpipe || (!save_insn && !if_freeze)) |=> !saved);"",
""Assertion 4"": ""assert property ((!if_flushpipe && save_insn && !icpu_err_i) |=> (insn_saved == $past(icpu_dat_i, 1)));"",
""Assertion 5"": ""assert property ((if_flushpipe || (!save_insn && !if_freeze && !icpu_err_i)) |=> (insn_saved == {6'b000101, 26'h041_0000}));"",
""Assertion 6"": ""assert property ((!if_flushpipe && (save_insn || !if_freeze)) |=> (addr_saved == {($past(icpu_adr_i[31:2]), 2'b00)}));"",
""Assertion 7"": ""assert property (if_flushpipe |=> (addr_saved == 32'h00000000));"",
""Assertion 8"": ""assert property ($fell(if_flushpipe) && save_insn |=> err_saved[0] == ($past(icpu_err_i) && (icpu_tag_i == `OR1200_ITAG_TE)));"",
""Assertion 9"": ""assert property ((!if_flushpipe && save_insn) |=> err_saved[1] == ($past(icpu_err_i) && ($past(icpu_tag_i) == 4'hc));"",
""Assertion 10"": ""assert property ($fell(if_flushpipe) && save_insn |=> err_saved[2] == ($past(icpu_err_i) && $past(icpu_tag_i) == `OR1200_ITAG_BE));"",
""Assertion 11"": ""assert property ((if_flushpipe || (!save_insn && !if_freeze)) |=> (err_saved == 3'b000));""
}"
uart_transmit,"module uart_transmit #(localparam d_width = 4, localparam c_width = 3) (input clk, input rst, input tx_ena, input [d_width - 1: 0] tx_data, output reg tx, output reg tx_busy);
	reg [c_width-1:0] tx_cnt;
	reg tx_state;
	reg [d_width+1:0] tx_buffer;

	always @(posedge clk) begin
		if(rst == 1) begin
			tx_cnt = 0;
			tx = 1;
			tx_busy = 0;
			tx_state = 0;
		end
		if(tx_state == 0) begin
			if(tx_ena == 1) begin
				tx_buffer = {tx_data, 2'b01};
				tx_busy = 1;
				tx_cnt = 0;
				tx_state = 1;
			end
			else
				tx_busy = 0;
		end
		else if(tx_state == 1) begin
			if(tx_cnt < d_width+3) begin
				tx_state = 1;
				tx_cnt = tx_cnt + 1;
				tx_buffer = {1'b1, tx_buffer[d_width+1:1]};
			end
			else begin
				tx_cnt = 0;
				tx_state = 0;
			end
		end
		tx = tx_buffer[0];
	end
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""s_eventually rst == 1 || tx_state == 0"",
    ""Signals"": [""rst"", ""tx_state""],
    ""Signal Explanations"": {
      ""rst"": ""reset signal"",
      ""tx_state"": ""state of the UART transmitter indicating if it is transmitting (1) or idle (0)""
    },
    ""Logical Operators"": [""s_eventually"", ""=="", ""||""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
      ""=="": ""equal"",
      ""||"": ""or""
    },
    ""Assertion Explaination"": ""eventually, reset signal equals 1 or transmitter state equals 0""
  }
}","{
""Assertion 1"": ""assert property (s_eventually (rst || (tx_state == 0)));""
}"
ff,"module ff
  (
   input logic clk, rst, en, in,
   output logic out   
   );

   always_ff @(posedge clk or posedge rst)
      if (rst) out = 1'b0;
      else if (en) out = in;         
endmodule

","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""en |=> out == $past(in,1)"",
    ""Signals"": [""en"", ""out"", ""in""],
    ""Signal Explanations"": {
      ""en"": ""enable signal"",
      ""out"": ""output signal of the verilog module"",
      ""in"": ""input signal of the verilog module""
    },
    ""Logical Operators"": [""|=>"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""$past"": ""the value of the signal in the specified previous clock cycle(s)""
    },
    ""Assertion Explaination"": ""check if when enable signal is set (1), the output is equal to the input from one cycle in the past from the next clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""!en |=> out == $past(out,1)"",
    ""Signals"": [""en"", ""out""],
    ""Signal Explanations"": {
      ""en"": ""enable signal"",
      ""out"": ""output signal of the verilog module""
    },
    ""Logical Operators"": [""!"", ""|=>"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""$past"": ""the value of the signal in the specified previous clock cycle(s)""
    },
    ""Assertion Explaination"": ""check to make sure that when the enable isn't asserted, the output doesn't change from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property (en |=> out == $past(in));"",
""Assertion 2"": ""assert property (!en |=> $stable(out));""
}"
BusArbiter,"parameter N_MASTERS = 3;
typedef bit [N_MASTERS-1:0] arb_vector;
parameter arb_vector NO_REQUEST = '{default: '0};
parameter arb_vector NO_GRANT = '{default: '0};

module busarbiter(input clk, reset, bus_ack, input arb_vector bus_req, output arb_vector bus_grant);

    enum {READY, BUSY} state_s;
    arb_vector prio_req;
    reg found;
    always @(bus_req) begin: prio
        arb_vector prio_req_v;
	found = 0;
        for (int i=0; i < N_MASTERS; i++) begin
            if(~found & (bus_req[i]==1'b1)) begin
                prio_req_v[i] = 1'b1;
                found = 1;
            end
            else begin
                prio_req_v[i] = 1'b0;
            end
        end
        prio_req <= prio_req_v;
    end

    always @(posedge clk or posedge reset) begin: ctrl
        if(reset) begin //always block triggered by reset
            state_s <= READY;
            bus_grant <= NO_GRANT;
        end
        else begin //always block triggered by clk
            case (state_s)
                READY: begin
                    if (bus_req == NO_REQUEST) begin
			state_s <= READY;
                    end
                    else begin
                        state_s <= BUSY;
                    end 
                    bus_grant <= prio_req;
                end

                BUSY: begin
                    if (bus_ack) begin
                        if (bus_req == NO_REQUEST) begin
                            state_s <= READY;
                        end
                        else begin
                            state_s <= BUSY;
                        end 
		        bus_grant <= prio_req;
		    end
                end
            endcase 
        end
    end
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""bus_grant[0] + bus_grant[1] + bus_grant[2] < 2"",
    ""Signals"": [
      ""bus_grant[0]"",
      ""bus_grant[1]"",
      ""bus_grant[2]""
    ],
    ""Signal Explanations"": {
      ""bus_grant[0]"": ""first bit of the output bus_grant vector representing grant signal for master 0"",
      ""bus_grant[1]"": ""second bit of the output bus_grant vector representing grant signal for master 1"",
      ""bus_grant[2]"": ""third bit of the output bus_grant vector representing grant signal for master 2""
    },
    ""Logical Operators"": [
      ""+"",
      ""<""
    ],
    ""Logical Operators Explanation"": {
      ""+"": ""arithmetic addition"",
      ""<"": ""less than""
    },
    ""Assertion Explaination"": ""the arithmetic addition of the first output grant bit, the second output grant bit, and the third output grant bit is computed and the result must be less than 2""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""bus_grant[0] |-> (!bus_grant[1] && !bus_grant[2])"",
    ""Signals"": [
      ""bus_grant[0]"",
      ""bus_grant[1]"",
      ""bus_grant[2]""
    ],
    ""Signal Explanations"": {
      ""bus_grant[0]"": ""first bit of the output bus_grant vector representing grant signal for master 0"",
      ""bus_grant[1]"": ""second bit of the output bus_grant vector representing grant signal for master 1"",
      ""bus_grant[2]"": ""third bit of the output bus_grant vector representing grant signal for master 2""
    },
    ""Logical Operators"": [
      ""|->"",
      ""!"",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical and""
    },
    ""Assertion Explaination"": ""When the first output grant bit is asserted, then the second output grant bit and the third output grant bit must be reset (0) from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""bus_grant[1] |-> (!bus_grant[0] && !bus_grant[2])"",
    ""Signals"": [
      ""bus_grant[1]"",
      ""bus_grant[0]"",
      ""bus_grant[2]""
    ],
    ""Signal Explanations"": {
      ""bus_grant[1]"": ""second bit of the output bus_grant vector representing grant signal for master 1"",
      ""bus_grant[0]"": ""first bit of the output bus_grant vector representing grant signal for master 0"",
      ""bus_grant[2]"": ""third bit of the output bus_grant vector representing grant signal for master 2""
    },
    ""Logical Operators"": [
      ""|->"",
      ""!"",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical and""
    },
    ""Assertion Explaination"": ""When the second output grant bit is asserted, then the first output grant bit and the third output grant bit must be reset (0) from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""bus_grant[2] |-> (!bus_grant[1] && !bus_grant[0])"",
    ""Signals"": [
      ""bus_grant[2]"",
      ""bus_grant[1]"",
      ""bus_grant[0]""
    ],
    ""Signal Explanations"": {
      ""bus_grant[2]"": ""third bit of the output bus_grant vector representing grant signal for master 2"",
      ""bus_grant[1]"": ""second bit of the output bus_grant vector representing grant signal for master 1"",
      ""bus_grant[0]"": ""first bit of the output bus_grant vector representing grant signal for master 0""
    },
    ""Logical Operators"": [
      ""|->"",
      ""!"",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical and""
    },
    ""Assertion Explaination"": ""When the third output grant bit is asserted, then the second output grant bit and the first output grant bit must be reset (0) from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""bus_grant != NO_GRANT && bus_ack != 1 |=> $stable(bus_grant)"",
    ""Signals"": [
      ""bus_grant"",
      ""NO_GRANT"",
      ""bus_ack""
    ],
    ""Signal Explanations"": {
      ""bus_grant"": ""output bus grant vector"",
      ""NO_GRANT"": ""constant arb_vector with all bits reset (0) representing no grant"",
      ""bus_ack"": ""bus acknowledge signal""
    },
    ""Logical Operators"": [
      ""!="",
      ""&&"",
      ""|=>"",
      ""$stable""
    ],
    ""Logical Operators Explanation"": {
      ""!="": ""not equal"",
      ""&&"": ""logical and"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE"",
      ""$stable"": ""indicates that the signal remains constant for at least one clock cycle""
    },
    ""Assertion Explaination"": ""when the output bus grant vector is not equal to the constant vector representing no grant and the bus acknowledge signal is not asserted, then the output bus grant vector must remain constant from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[0]) |=> (bus_grant[0] && !bus_grant[1] && !bus_grant[2])"",
    ""Signals"": [
      ""bus_req[0]"",
      ""bus_grant"",
      ""NO_GRANT"",
      ""bus_ack"",
      ""bus_grant[0]"",
      ""bus_grant[1]"",
      ""bus_grant[2]""
    ],
    ""Signal Explanations"": {
      ""bus_req[0]"": ""first bit of the bus request vector representing request from master 0"",
      ""bus_grant"": ""output bus grant vector"",
      ""NO_GRANT"": ""constant arb_vector with all bits reset (0) representing no grant"",
      ""bus_ack"": ""bus acknowledge signal"",
      ""bus_grant[0]"": ""first bit of the output bus grant vector representing grant signal for master 0"",
      ""bus_grant[1]"": ""second bit of the output bus grant vector representing grant signal for master 1"",
      ""bus_grant[2]"": ""third bit of the output bus grant vector representing grant signal for master 2""
    },
    ""Logical Operators"": [
      ""&&"",
      ""=="",
      ""||"",
      ""|=>"",
      ""&&"",
      ""!""
    ],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""=="": ""equal"",
      ""||"": ""or"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE"",
      ""!"": ""the value of a signal is reset (0)""
    },
    ""Assertion Explaination"": ""when either the first bit of bus request signal is asserted and the output bus grant vector equals the constant vector representing no grant, or the bus acknowledge signal and the first bit of bus request signal are asserted, then the first output grant bit must be asserted and the second and third output grant bits must be reset (0) from the next clock cycle ""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[1] && !bus_req[0]) |=> (!bus_grant[0] && bus_grant[1] && !bus_grant[2])"",
    ""Signals"": [
      ""bus_req[1]"",
      ""bus_req[0]"",
      ""bus_grant"",
      ""NO_GRANT"",
      ""bus_ack"",
      ""bus_grant[0]"",
      ""bus_grant[1]"",
      ""bus_grant[2]""
    ],
    ""Signal Explanations"": {
      ""bus_req[1]"": ""second bit of the bus request vector representing request from master 1"",
      ""bus_req[0]"": ""first bit of the bus request vector representing request from master 0"",
      ""bus_grant"": ""output bus grant vector"",
      ""NO_GRANT"": ""constant arb_vector with all bits reset (0) representing no grant"",
      ""bus_ack"": ""bus acknowledge signal"",
      ""bus_grant[0]"": ""first bit of the output bus grant vector representing grant signal for master 0"",
      ""bus_grant[1]"": ""second bit of the output bus grant vector representing grant signal for master 1"",
      ""bus_grant[2]"": ""third bit of the output bus grant vector representing grant signal for master 2""
    },
    ""Logical Operators"": [
      ""&&"",
      ""!"",
      ""=="",
      ""||"",
      ""|=>"",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""!"": ""the value of a signal is reset (0)"",
      ""=="": ""equal"",
      ""||"": ""or"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when either the second bit of bus request signal is asserted and the first bit of bus request signal is reset and the output bus grant vector equals the constant vector representing no grant, or the bus acknowledge signal is asserted and the second bit of bus request signal is asserted and the first bit of bus request signal is reset, then the second output grant bit must be asserted and the first and third output grant bits must be reset (0) from the next clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(bus_req[2] && !bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[2] && !bus_req[0] && !bus_req[1]) |=> (!bus_grant[0] && !bus_grant[1] && bus_grant[2])"",
    ""Signals"": [
      ""bus_req[2]"",
      ""bus_req[1]"",
      ""bus_req[0]"",
      ""bus_grant"",
      ""NO_GRANT"",
      ""bus_ack"",
      ""bus_grant[0]"",
      ""bus_grant[1]"",
      ""bus_grant[2]""
    ],
    ""Signal Explanations"": {
      ""bus_req[2]"": ""third bit of the bus request vector representing request from master 2"",
      ""bus_req[1]"": ""second bit of the bus request vector representing request from master 1"",
      ""bus_req[0]"": ""first bit of the bus request vector representing request from master 0"",
      ""bus_grant"": ""output bus grant vector"",
      ""NO_GRANT"": ""constant arb_vector with all bits reset (0) representing no grant"",
      ""bus_ack"": ""bus acknowledge signal"",
      ""bus_grant[0]"": ""first bit of the output bus grant vector representing grant signal for master 0"",
      ""bus_grant[1]"": ""second bit of the output bus grant vector representing grant signal for master 1"",
      ""bus_grant[2]"": ""third bit of the output bus grant vector representing grant signal for master 2""
    },
    ""Logical Operators"": [
      ""&&"",
      ""!"",
      ""=="",
      ""||"",
      ""|=>"",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""!"": ""the value of a signal is reset (0)"",
      ""=="": ""equal"",
      ""||"": ""or"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when either the third bus request bit is asserted and the second and first bus request bits are reset and the output bus grant vector equals the constant vector representing no grant, or the bus acknowledge signal is asserted and the third bus request bit is asserted and the first and second bus request bits are reset, then the third output grant bit must be asserted and the first and second output grant bits must be reset (0) from the next clock cycle ""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""$rose(bus_grant[1]) |-> ($past(bus_req[1]) && !$past(bus_req[0]))"",
    ""Signals"": [
      ""bus_grant[1]"",
      ""bus_req[1]"",
      ""bus_req[0]""
    ],
    ""Signal Explanations"": {
      ""bus_grant[1]"": ""second bit of the output bus_grant vector representing grant signal for master 1"",
      ""bus_req[1]"": ""second bit of the bus request vector representing request from master 1"",
      ""bus_req[0]"": ""first bit of the bus request vector representing request from master 0""
    },
    ""Logical Operators"": [
      ""$rose"",
      ""|->"",
      ""$past"",
      ""&&"",
      ""!""
    ],
    ""Logical Operators Explanation"": {
      ""$rose"": ""a function that returns true when a signal transitions from 0 to 1"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal from the previous clock cycle"",
      ""&&"": ""logical and"",
      ""!"": ""the value of a signal is reset (0)""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the second output grant bit, then the second bus request bit in the last clock cycle was asserted and the first bus request bit in the last clock cycle was reset (0) from the current clock cycle ""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""$rose(bus_grant[2]) |-> ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0]))"",
    ""Signals"": [
      ""bus_grant[2]"",
      ""bus_req[2]"",
      ""bus_req[1]"",
      ""bus_req[0]""
    ],
    ""Signal Explanations"": {
      ""bus_grant[2]"": ""third bit of the output bus_grant vector representing grant signal for master 2"",
      ""bus_req[2]"": ""third bit of the bus request vector representing request from master 2"",
      ""bus_req[1]"": ""second bit of the bus request vector representing request from master 1"",
      ""bus_req[0]"": ""first bit of the bus request vector representing request from master 0""
    },
    ""Logical Operators"": [
      ""$rose"",
      ""|->"",
      ""$past"",
      ""&&"",
      ""!""
    ],
    ""Logical Operators Explanation"": {
      ""$rose"": ""a function that returns true when a signal transitions from 0 to 1"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal from the previous clock cycle"",
      ""&&"": ""logical and"",
      ""!"": ""the value of a signal is reset (0)""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the third output grant bit, then the third bus request bit in the last clock cycle was asserted and the second and first bus request bits in the last clock cycle were reset (0) from the current clock cycle ""
  }
}","{
""Assertion 1"": ""assert property ((bus_grant[0] + bus_grant[1] + bus_grant[2]) < 2);"",
""Assertion 2"": ""assert property (bus_grant[0] |-> !bus_grant[1] && !bus_grant[2]);"",
""Assertion 3"": ""assert property (bus_grant[1] |-> !bus_grant[0] && !bus_grant[2]);"",
""Assertion 4"": ""assert property (bus_grant[2] |-> !bus_grant[1] && !bus_grant[0]);"",
""Assertion 5"": ""assert property (((bus_grant != NO_GRANT) && !bus_acknowledge) |=> $stable(bus_grant));"",
""Assertion 6"": ""assert property (((bus_req[0] && (bus_grant == NO_GRANT)) || (bus_ack && bus_req[0])) |=> (bus_grant[0] && !bus_grant[1] && !bus_grant[2]));"",
""Assertion 7"": ""assert property ((!bus_req[0] && bus_req[1] && (bus_grant == NO_GRANT)) || (bus_ack && !bus_req[0] && bus_req[1]) |-> (bus_grant[1] && !bus_grant[0] && !bus_grant[2]));"",
""Assertion 8"": ""assert property (     ((bus_req[2] && !bus_req[1] && !bus_req[0] && (bus_grant == NO_GRANT))      ||      (bus_ack && bus_req[2] && !bus_req[1] && !bus_req[0]))     |=>      (bus_grant[2] && !bus_grant[1] && !bus_grant[0]) );"",
""Assertion 9"": ""assert property ($rose(bus_grant[1]) |-> ($past(bus_req[1]) && !$past(bus_req[0])));"",
""Assertion 10"": ""assert property ($rose(bus_grant[2]) |-> ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0])));""
}"
eth_rxstatem,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  eth_rxstatem.v                                              ////
////                                                              ////
////  This file is part of the Ethernet IP core project           ////
////  http://www.opencores.org/project,ethmac                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Igor Mohor (igorM@opencores.org)                      ////
////      - Novan Hartadi (novan@vlsi.itb.ac.id)                  ////
////      - Mahmud Galela (mgalela@vlsi.itb.ac.id)                ////
////                                                              ////
////  All additional information is avaliable in the Readme.txt   ////
////  file.                                                       ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2001 Authors                                   ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: not supported by cvs2svn $
// Revision 1.5  2002/01/23 10:28:16  mohor
// Link in the header changed.
//
// Revision 1.4  2001/10/19 08:43:51  mohor
// eth_timescale.v changed to timescale.v This is done because of the
// simulation of the few cores in a one joined project.
//
// Revision 1.3  2001/10/18 12:07:11  mohor
// Status signals changed, Adress decoding changed, interrupt controller
// added.
//
// Revision 1.2  2001/09/11 14:17:00  mohor
// Few little NCSIM warnings fixed.
//
// Revision 1.1  2001/08/06 14:44:29  mohor
// A define FPGA added to select between Artisan RAM (for ASIC) and Block Ram (For Virtex).
// Include files fixed to contain no path.
// File names and module names changed ta have a eth_ prologue in the name.
// File eth_timescale.v is used to define timescale
// All pin names on the top module are changed to contain _I, _O or _OE at the end.
// Bidirectional signal MDIO is changed to three signals (Mdc_O, Mdi_I, Mdo_O
// and Mdo_OE. The bidirectional signal must be created on the top level. This
// is done due to the ASIC tools.
//
// Revision 1.1  2001/07/30 21:23:42  mohor
// Directory structure changed. Files checked and joind together.
//
// Revision 1.2  2001/07/03 12:55:41  mohor
// Minor changes because of the synthesys warnings.
//
//
// Revision 1.1  2001/06/27 21:26:19  mohor
// Initial release of the RxEthMAC module.
//
//
//
//

module eth_rxstatem (MRxClk, Reset, MRxDV, ByteCntEq0, ByteCntGreat2, Transmitting, MRxDEq5, MRxDEqD, 
                     IFGCounterEq24, ByteCntMaxFrame, StateData, StateIdle, StatePreamble, StateSFD, 
                     StateDrop
                    );

input         MRxClk;
input         Reset;
input         MRxDV;
input         ByteCntEq0;
input         ByteCntGreat2;
input         MRxDEq5;
input         Transmitting;
input         MRxDEqD;
input         IFGCounterEq24;
input         ByteCntMaxFrame;

output [1:0]  StateData;
output        StateIdle;
output        StateDrop;
output        StatePreamble;
output        StateSFD;

reg           StateData0;
reg           StateData1;
reg           StateIdle;
reg           StateDrop;
reg           StatePreamble;
reg           StateSFD;

wire          StartIdle;
wire          StartDrop;
wire          StartData0;
wire          StartData1;
wire          StartPreamble;
wire          StartSFD;


// Defining the next state
assign StartIdle = ~MRxDV & (StateDrop | StatePreamble | StateSFD | (|StateData));

assign StartPreamble = MRxDV & ~MRxDEq5 & (StateIdle & ~Transmitting);

assign StartSFD = MRxDV & MRxDEq5 & (StateIdle & ~Transmitting | StatePreamble);

assign StartData0 = MRxDV & (StateSFD & MRxDEqD & IFGCounterEq24 | StateData1);

assign StartData1 = MRxDV & StateData0 & (~ByteCntMaxFrame);

assign StartDrop = MRxDV & (StateIdle & Transmitting | StateSFD & ~IFGCounterEq24 &
                   MRxDEqD |  StateData0 &  ByteCntMaxFrame);

// Rx State Machine
always @ (posedge MRxClk or posedge Reset)
begin
  if(Reset)
    begin
      StateIdle     <=  1'b0;
      StateDrop     <=  1'b1;
      StatePreamble <=  1'b0;
      StateSFD      <=  1'b0;
      StateData0    <=  1'b0;
      StateData1    <=  1'b0;
    end
  else
    begin
      if(StartPreamble | StartSFD | StartDrop)
        StateIdle <=  1'b0;
      else
      if(StartIdle)
        StateIdle <=  1'b1;

      if(StartIdle)
        StateDrop <=  1'b0;
      else
      if(StartDrop)
        StateDrop <=  1'b1;

      if(StartSFD | StartIdle | StartDrop)
        StatePreamble <=  1'b0;
      else
      if(StartPreamble)
        StatePreamble <=  1'b1;

      if(StartPreamble | StartIdle | StartData0 | StartDrop)
        StateSFD <=  1'b0;
      else
      if(StartSFD)
        StateSFD <=  1'b1;

      if(StartIdle | StartData1 | StartDrop)
        StateData0 <=  1'b0;
      else
      if(StartData0)
        StateData0 <=  1'b1;

      if(StartIdle | StartData0 | StartDrop)
        StateData1 <=  1'b0;
      else
      if(StartData1)
        StateData1 <=  1'b1;
    end
end

assign StateData[1:0] = {StateData1, StateData0};

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartPreamble == 1) |=> (StatePreamble == 1)"",
    ""Signals"": [
      ""StartPreamble"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""StartPreamble"": ""a wire signal indicating the start of the preamble state"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the preamble state is equal to 1, then a register bit representing the preamble state is equal to 1 from the next clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""StartDrop"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""StartDrop"": ""a wire signal indicating the start of the drop state"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the drop state is equal to 1, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateSFD == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""StateSFD"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""StateSFD"": ""a register bit representing the SFD state"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the SFD state is equal to 1, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData[0] == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""StateData[0]"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""StateData[0]"": ""the lower bit of the data state"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the lower bit of the data state is equal to 1, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateDrop == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""StateDrop"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""StateDrop"": ""a register bit representing the drop state"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the drop state is equal to 1, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData1 == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""StateData1"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""StateData1"": ""a register bit representing data state one"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing data state one is equal to 1, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StatePreamble == 1 & MRxDEq5 == 0 & MRxDV == 1) |=> (StatePreamble == 1)"",
    ""Signals"": [
      ""StatePreamble"",
      ""MRxDEq5"",
      ""MRxDV""
    ],
    ""Signal Explanations"": {
      ""StatePreamble"": ""a register bit representing the preamble state"",
      ""MRxDEq5"": ""a signal indicating that the receive data equals 5"",
      ""MRxDV"": ""the receive data valid signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the preamble state is equal to 1 and a signal indicating that the receive data equals 5 is equal to 0 and the receive data valid signal is equal to 1, then a register bit representing the preamble state is equal to 1 from the next clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDEq5 == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""MRxDEq5"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""MRxDEq5"": ""a signal indicating that the receive data equals 5"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a signal indicating that the receive data equals 5 is equal to 1, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StatePreamble == 0)"",
    ""Signals"": [
      ""MRxDV"",
      ""StatePreamble""
    ],
    ""Signal Explanations"": {
      ""MRxDV"": ""the receive data valid signal"",
      ""StatePreamble"": ""a register bit representing the preamble state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the receive data valid signal is equal to 0, then a register bit representing the preamble state is equal to 0 from the next clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartSFD == 1) |=> (StateSFD == 1)"",
    ""Signals"": [
      ""StartSFD"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StartSFD"": ""a wire signal indicating the start of the SFD state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the SFD state is equal to 1, then a register bit representing the SFD state is equal to 1 from the next clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartIdle == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""StartIdle"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StartIdle"": ""a wire signal indicating the start of the idle state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the idle state is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""StartDrop"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StartDrop"": ""a wire signal indicating the start of the drop state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the drop state is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartData0 == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""StartData0"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StartData0"": ""a wire signal indicating the start of data state 0"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of data state 0 is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartPreamble == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""StartPreamble"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StartPreamble"": ""a wire signal indicating the start of the preamble state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the preamble state is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateSFD == 1 & StartIdle == 0 & MRxDEqD == 0) |=> (StateSFD == 1)"",
    ""Signals"": [
      ""StateSFD"",
      ""StartIdle"",
      ""MRxDEqD""
    ],
    ""Signal Explanations"": {
      ""StateSFD"": ""a register bit representing the SFD state"",
      ""StartIdle"": ""a wire signal indicating the start of the idle state"",
      ""MRxDEqD"": ""a signal indicating that the receive data equals D""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the SFD state is equal to 1 and a wire signal indicating the start of the idle state is equal to 0 and a signal indicating that the receive data equals D is equal to 0, then a register bit representing the SFD state is equal to 1 from the next clock cycle""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData[0] == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""StateData[0]"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StateData[0]"": ""the lower bit of the data state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the lower bit of the data state is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 17"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateDrop == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""StateDrop"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""StateDrop"": ""a register bit representing the drop state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the drop state is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 18"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDEq5 == 0 & StatePreamble == 1) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""MRxDEq5"",
      ""StatePreamble"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""MRxDEq5"": ""a signal indicating that the receive data equals 5"",
      ""StatePreamble"": ""a register bit representing the preamble state"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a signal indicating that the receive data equals 5 is equal to 0 and a register bit representing the preamble state is equal to 1, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 19"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StateSFD == 0)"",
    ""Signals"": [
      ""MRxDV"",
      ""StateSFD""
    ],
    ""Signal Explanations"": {
      ""MRxDV"": ""the receive data valid signal"",
      ""StateSFD"": ""a register bit representing the SFD state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the receive data valid signal is equal to 0, then a register bit representing the SFD state is equal to 0 from the next clock cycle""
  },
  ""Assertion 20"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartIdle == 1) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""StartIdle"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""StartIdle"": ""a wire signal indicating the start of the idle state"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the idle state is equal to 1, then a register bit representing the drop state is equal to 0 from the current clock cycle""
  },
  ""Assertion 21"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StateDrop == 1)"",
    ""Signals"": [
      ""StartDrop"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""StartDrop"": ""a wire signal indicating the start of the drop state"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the drop state is equal to 1, then a register bit representing the drop state is equal to 1 from the current clock cycle""
  },
  ""Assertion 22"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateDrop == 1 & StartIdle == 0) |=> (StateDrop == 1)"",
    ""Signals"": [
      ""StateDrop"",
      ""StartIdle""
    ],
    ""Signal Explanations"": {
      ""StateDrop"": ""a register bit representing the drop state"",
      ""StartIdle"": ""a wire signal indicating the start of the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the drop state is equal to 1 and a wire signal indicating the start of the idle state is equal to 0, then a register bit representing the drop state is equal to 1 from the next clock cycle""
  },
  ""Assertion 23"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateSFD == 1 & StartDrop == 0) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""StateSFD"",
      ""StartDrop"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""StateSFD"": ""a register bit representing the SFD state"",
      ""StartDrop"": ""a wire signal indicating the start of the drop state"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the SFD state is equal to 1 and a wire signal indicating the start of the drop state is equal to 0, then a register bit representing the drop state is equal to 0 from the next clock cycle""
  },
  ""Assertion 24"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData[0] == 1 & StartDrop == 0) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""StateData[0]"",
      ""StartDrop"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""StateData[0]"": ""the lower bit of the data state"",
      ""StartDrop"": ""a wire signal indicating the start of the drop state"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the lower bit of the data state is equal to 1 and a wire signal indicating the start of the drop state is equal to 0, then a register bit representing the drop state is equal to 0 from the next clock cycle""
  },
  ""Assertion 25"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StatePreamble == 1) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""StatePreamble"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""StatePreamble"": ""a register bit representing the preamble state"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing the preamble state is equal to 1, then a register bit representing the drop state is equal to 0 from the next clock cycle""
  },
  ""Assertion 26"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData1 == 1) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""StateData1"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""StateData1"": ""a register bit representing data state one"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a register bit representing data state one is equal to 1, then a register bit representing the drop state is equal to 0 from the next clock cycle""
  },
  ""Assertion 27"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""MRxDV"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""MRxDV"": ""the receive data valid signal"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the receive data valid signal is equal to 0, then a register bit representing the drop state is equal to 0 from the next clock cycle""
  },
  ""Assertion 28"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(Transmitting == 0 & StateIdle == 1) |=> (StateDrop == 0)"",
    ""Signals"": [
      ""Transmitting"",
      ""StateIdle"",
      ""StateDrop""
    ],
    ""Signal Explanations"": {
      ""Transmitting"": ""a signal indicating that the transmitter is active"",
      ""StateIdle"": ""a register bit representing the idle state"",
      ""StateDrop"": ""a register bit representing the drop state""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a signal indicating that the transmitter is active is equal to 0 and a register bit representing the idle state is equal to 1, then a register bit representing the drop state is equal to 0 from the next clock cycle""
  },
  ""Assertion 29"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartIdle == 1) |=> (StateIdle == 1)"",
    ""Signals"": [
      ""StartIdle"",
      ""StateIdle""
    ],
    ""Signal Explanations"": {
      ""StartIdle"": ""a wire signal indicating the start of the idle state"",
      ""StateIdle"": ""a register bit representing the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the idle state is equal to 1, then a register bit representing the idle state is equal to 1 from the next clock cycle""
  },
  ""Assertion 30"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StateIdle == 0)"",
    ""Signals"": [
      ""StartDrop"",
      ""StateIdle""
    ],
    ""Signal Explanations"": {
      ""StartDrop"": ""a wire signal indicating the start of the drop state"",
      ""StateIdle"": ""a register bit representing the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the drop state is equal to 1, then a register bit representing the idle state is equal to 0 from the next clock cycle""
  },
  ""Assertion 31"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartSFD == 1) |=> (StateIdle == 0)"",
    ""Signals"": [
      ""StartSFD"",
      ""StateIdle""
    ],
    ""Signal Explanations"": {
      ""StartSFD"": ""a wire signal indicating the start of the SFD state"",
      ""StateIdle"": ""a register bit representing the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the SFD state is equal to 1, then a register bit representing the idle state is equal to 0 from the next clock cycle""
  },
  ""Assertion 32"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartPreamble == 1) |=> (StateIdle == 0)"",
    ""Signals"": [
      ""StartPreamble"",
      ""StateIdle""
    ],
    ""Signal Explanations"": {
      ""StartPreamble"": ""a wire signal indicating the start of the preamble state"",
      ""StateIdle"": ""a register bit representing the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a wire signal indicating the start of the preamble state is equal to 1, then a register bit representing the idle state is equal to 0 from the next clock cycle""
  },
  ""Assertion 33"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 1) |=> (StateIdle == 0)"",
    ""Signals"": [
      ""MRxDV"",
      ""StateIdle""
    ],
    ""Signal Explanations"": {
      ""MRxDV"": ""the receive data valid signal"",
      ""StateIdle"": ""a register bit representing the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the receive data valid signal is equal to 1, then a register bit representing the idle state is equal to 0 from the next clock cycle""
  },
  ""Assertion 34"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StateIdle == 1)"",
    ""Signals"": [
      ""MRxDV"",
      ""StateIdle""
    ],
    ""Signal Explanations"": {
      ""MRxDV"": ""the receive data valid signal"",
      ""StateIdle"": ""a register bit representing the idle state""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the receive data valid signal is equal to 0, then a register bit representing the idle state is equal to 1 from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property (StartPreamble |=> StatePreamble);"",
""Assertion 2"": ""assert property (StartDrop |=> !StatePreamble);"",
""Assertion 3"": ""assert property (StateSFD |=> !StatePreamble);"",
""Assertion 4"": ""assert property (StateData[0] |=> !StatePreamble);"",
""Assertion 5"": ""assert property (StateDrop |=> !StatePreamble);"",
""Assertion 6"": ""assert property (StateData1 |=> !StatePreamble);"",
""Assertion 7"": ""assert property (StatePreamble && ~MRxDEq5 && MRxDV |=> StatePreamble);"",
""Assertion 8"": ""assert property (MRxDEq5 |=> !StatePreamble);"",
""Assertion 9"": ""assert property (MRxDV == 0 |=> StatePreamble == 0);"",
""Assertion 10"": ""assert property (StartSFD |=> StateSFD);"",
""Assertion 11"": ""assert property (StartIdle |=> !StateSFD)` is already syntactically correct and follows the requested format (only logical expression without clock signal condition or disable condition).   No corrections are needed. The assertion remains:  ```systemverilog assert property (StartIdle |=> !StateSFD);"",
""Assertion 12"": ""assert property (StartDrop |=> !StateSFD);"",
""Assertion 13"": ""assert property (StartData0 |=> !StateSFD);"",
""Assertion 14"": ""assert property (StartPreamble |=> !StateSFD);"",
""Assertion 15"": ""assert property (StateSFD && !StartIdle && !MRxDEqD |=> StateSFD);"",
""Assertion 16"": ""assert property (StateData0 |=> !StateSFD);"",
""Assertion 17"": ""assert property (StateDrop |=> !StateSFD);"",
""Assertion 18"": ""assert property ((~MRxDEq5 & StatePreamble) |=> ~StateSFD);"",
""Assertion 19"": ""assert property (MRxDV == 0 |=> StateSFD == 0);"",
""Assertion 20"": ""assert property (StartIdle |-> !StateDrop);"",
""Assertion 21"": ""assert property (StartDrop |-> StateDrop);"",
""Assertion 22"": ""assert property (StateDrop && ~StartIdle |=> StateDrop);"",
""Assertion 23"": ""assert property (StateSFD && !StartDrop |=> !StateDrop);"",
""Assertion 24"": ""assert property (StateData0 && !StartDrop |=> !StateDrop);"",
""Assertion 25"": ""assert property (StatePreamble |=> !StateDrop);"",
""Assertion 26"": ""assert property (StateData1 |=> !StateDrop);"",
""Assertion 27"": ""assert property (MRxDV == 0 |=> StateDrop == 0);"",
""Assertion 28"": ""assert property ((~Transmitting & StateIdle) |=> ~StateDrop);"",
""Assertion 29"": ""assert property (StartIdle |=> StateIdle);"",
""Assertion 30"": ""assert property (StartDrop |=> !StateIdle);"",
""Assertion 31"": ""assert property (StartSFD |=> !StateIdle);"",
""Assertion 32"": ""assert property (StartPreamble |=> !StateIdle);"",
""Assertion 33"": ""assert property (MRxDV |=> !StateIdle);"",
""Assertion 34"": ""assert property (!MRxDV |=> StateIdle);""
}"
Gray_To_Binary,"module Gray_To_Binary #(
	parameter DATA_WIDTH = 3
) 
(
          input clk,
          input rst,
	input [DATA_WIDTH-1:0]        gray,
	output logic [DATA_WIDTH-1:0] bin
);

wire [DATA_WIDTH-1:0] tmp [DATA_WIDTH-1:1]; 
assign tmp[1] = ( gray >> 1 ) ^ gray;

genvar x;
generate
	for( x = 2; x < DATA_WIDTH ; x++) begin
		assign tmp[x] = ( gray >> x ) ^ tmp[x-1];
	end 
endgenerate

assign bin = tmp[DATA_WIDTH-1];

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst)"",
    ""logical expression"": ""gray_f == gray"",
    ""Signals"": [""gray_f"", ""gray""],
    ""Signal Explanations"": {
      ""gray_f"": ""Gray code computed from the binary output by converting the binary value back to Gray code"",
      ""gray"": ""input Gray code value""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""convert the output binary code to Gray code and it should equal the input Gray code""
  }
}","{
""Assertion 1"": ""assert property (gray == (bin ^ (bin >> 1)));""
}"
delay,"// Greg Stitt
// University of Florida
//
// This file illustrates how to implement a versatile delay module structurally
// as a sequence of registers. It introduces the unpacked array construct.


// Module: register
// Description: Register with flexible parameters.

module register
  #(
    parameter WIDTH = 8,
    parameter logic HAS_ASYNC_RESET = 1'b1,
    parameter logic RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic 	     en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );

   generate
      if (HAS_ASYNC_RESET) begin
	 always_ff @(posedge clk or posedge rst) begin
	    if (rst == RESET_ACTIVATION_LEVEL)
	      out <= RESET_VALUE;
	    else if (en)
	      out <= in;    	
	 end
      end
      else begin
	 always_ff @(posedge clk) begin
	    if (rst == RESET_ACTIVATION_LEVEL)
	      out <= RESET_VALUE;	      
	    else if (en)
	      out <= in;
	 end	
      end
   endgenerate
endmodule // register


// Module: delay
// Description: This module delays a provided WIDTH-bit input by CYCLES cycles.
// It also has configuration parmaters for reset type, activation level, and
// value. Finally, it has an enable signal that stalls the delay when not
// not asserted.
//
// See delay.pdf for an illustration of the schematic.

module delay
  #(
    parameter int 		CYCLES=4,
    parameter int 		WIDTH=8,
    parameter logic 		HAS_ASYNC_RESET = 1'b1,
    parameter logic 		RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk, rst, en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );

   // Ideally, every module would validate its parameters because often
   // certain values are undefined. For example, a negative cycles delay
   // doesn't make sense. Similarly, only positive widths make sense.
   // Unfortunately, parameter validation is somewhat lacking in SystemVerilog,
   // at least in the older versions. Some of the possibilities are shown
   // below.
   
   if (CYCLES < 0) begin
      // One workaround to missing validation constructs is to simply call
      // an undefined module with a name that specifies the error.
      cycles_parameter_must_be_ge_0();

      // The 2009 SV standard defines the $error function, which prints during
      // compilation. However, not every tool supports it yet. Also, despite 
      // the name, $error only created a warning in the version of Quartus
      // used for testing.
      //
      // $error(""ERROR: CYCLES parameter must be >= 0."");

      // $fatal does caused Quartus synthesis to terminate, but is not 
      // supported by every synthesis tool.
      //
      // $fatal(""ERROR: CYCLES parameter must be >= 0."");
   end
   if (WIDTH < 1) begin
      width_parameter_must_be_gt_0();      
      //$error(""ERROR: WIDTH parameter must be >= 1."");
      //$fatal(1, ""ERROR: WIDTH parameter must be >= 1."");      
   end

   // Create an array of WIDTH-bit signals, which will connect all the registers
   // together (see delay.pdf). The array uses CYCLES+1 elements because there
   // are CYCLES register outputs, plus the input to the first register.
   //
   // When creating an array this way, the CYCLES+1 section creates an unpacked
   // array. The [WIDTH-1:0] section creates a packed array. Packed arrays and
   // unpacked arrays support different operations, but generally you will use
   // the unpacked section to specify bits, and the unpacked section to specify
   // the total number of elements.
   //
   // The CYCLES+1 notation is short for [0:CYCLES+1-1]. A common convention is
   // to use ""downto"" syntax for the packed array, and ""to"" syntax for the
   // unpacked array. Most people are used to thinking of arrays starting at 
   // index 0, and the MSB starting at the highest number.
   //
   // VHDL COMPARISON: packed arrays are missing from VHDL, where you instead 
   // have to create a custom array type. In SV, every signal can become an
   // unpacked array simply by adding [], which is very convenient.
   logic [WIDTH-1:0] 	     regs[CYCLES+1];
   
   if (CYCLES == 0) begin
      // For CYCLES == 0, there is no delay, so just use a wire.
      assign out = in;
   end
   else if (CYCLES > 0) begin
      // Create a sequence of CYCLES registers, where each register adds one
      // cycle to the delay.
      
      for (genvar i=0; i < CYCLES; i++) begin : reg_array
	 register #(.WIDTH(WIDTH),
		    .HAS_ASYNC_RESET(HAS_ASYNC_RESET),
		    .RESET_ACTIVATION_LEVEL(RESET_ACTIVATION_LEVEL),
		    .RESET_VALUE(RESET_VALUE))
	 reg_array (.in(regs[i]), .out(regs[i+1]), .*);	 	 
      end

      // The first register's input comes from the delay's input.
      assign regs[0] = in;
      
      // The last register's output goes to the delay's output.
      assign out = regs[CYCLES];      
      
   end       

int count;    
always_ff @(posedge clk or posedge rst)
if (rst) count = 0;
else if (en == 1'b1 && count < CYCLES) count ++;
endmodule

","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""count < CYCLES || out == $past(in, CYCLES, en)"",
    ""Signals"": [
      ""count"",
      ""CYCLES"",
      ""out"",
      ""in"",
      ""en""
    ],
    ""Signal Explanations"": {
      ""count"": ""register that counts cycles"",
      ""CYCLES"": ""parameter specifying the number of delay cycles"",
      ""out"": ""output delayed signal"",
      ""in"": ""input signal to be delayed"",
      ""en"": ""enable signal that stalls the delay when not asserted""
    },
    ""Logical Operators"": [
      ""<"",
      ""||"",
      ""=="",
      ""$past""
    ],
    ""Logical Operators Explanation"": {
      ""<"": ""less than"",
      ""||"": ""logical or"",
      ""=="": ""equal"",
      ""$past"": ""the last several clock cycles (returning the value of a signal from a specified number of cycles in the past under the given enable condition)""
    },
    ""Assertion Explaination"": ""the register counting cycles is less than the parameter specifying the number of delay cycles or the output delayed signal equals the value of the input signal from the last several clock cycles (with a delay of the specified number of cycles under the enable condition)""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""count == CYCLES || out == RESET_VALUE"",
    ""Signals"": [
      ""count"",
      ""CYCLES"",
      ""out"",
      ""RESET_VALUE""
    ],
    ""Signal Explanations"": {
      ""count"": ""register that counts cycles"",
      ""CYCLES"": ""parameter specifying the number of delay cycles"",
      ""out"": ""output delayed signal"",
      ""RESET_VALUE"": ""the constant value to which registers are reset""
    },
    ""Logical Operators"": [
      ""=="",
      ""||"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""||"": ""logical or""
    },
    ""Assertion Explaination"": ""the register counting cycles equals the parameter specifying the number of delay cycles or the output delayed signal equals the constant value used for reset""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""!en |=> $stable(out)"",
    ""Signals"": [
      ""en"",
      ""out""
    ],
    ""Signal Explanations"": {
      ""en"": ""enable signal that stalls the delay when not asserted"",
      ""out"": ""output delayed signal""
    },
    ""Logical Operators"": [
      ""!"",
      ""|=>"",
      ""$stable""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold since the next clock cycle"",
      ""$stable"": ""indicates that the signal remains unchanged from one clock cycle to the next""
    },
    ""Assertion Explaination"": ""when the enable signal is reset (0), then the output delayed signal remains unchanged from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((count < CYCLES) || (out == $past(in, CYCLES, en)));"",
""Assertion 2"": ""assert property ((count == CYCLES) || (out == RESET_VALUE));"",
""Assertion 3"": ""assert property ($fell(en) |=> $stable(out));""
}"
arb2,"module arb2(clk, rst, req1, req2, gnt1, gnt2);

input clk, rst;
input req1, req2;
output gnt1, gnt2;

reg state;
reg gnt1, gnt2;

always @ (posedge clk or posedge rst)
	if (rst)
		state <= 0;
	else
		state <= gnt1;

always @ (*)
	if (state)
	begin
		gnt1 = req1 & ~req2;
		gnt2 = req2;
	end
	else
	begin
		gnt1 = req1;
		gnt2 = req2 & ~req1;
	end

endmodule
","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(state == 1 & req2 == 1) |-> (gnt1 == 0)"",
    ""Signals"": [""state"", ""req2"", ""gnt1""],
    ""Signal Explanations"": {
      ""state"": ""internal state signal"",
      ""req2"": ""request signal from client 2"",
      ""gnt1"": ""grant signal for client 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when internal state signal equals 1 and request signal from client 2 equals 1, then grant signal for client 1 equals 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req1 == 1 & state == 0) |-> (gnt1 == 1)"",
    ""Signals"": [""req1"", ""state"", ""gnt1""],
    ""Signal Explanations"": {
      ""req1"": ""request signal from client 1"",
      ""state"": ""internal state signal"",
      ""gnt1"": ""grant signal for client 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 1 equals 1 and internal state signal equals 0, then grant signal for client 1 equals 1 from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req1 == 0) |-> (gnt1 == 0)"",
    ""Signals"": [""req1"", ""gnt1""],
    ""Signal Explanations"": {
      ""req1"": ""request signal from client 1"",
      ""gnt1"": ""grant signal for client 1""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 1 equals 0, then grant signal for client 1 equals 0 from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req1 == 1 & req2 == 0) |-> (gnt1 == 1)"",
    ""Signals"": [""req1"", ""req2"", ""gnt1""],
    ""Signal Explanations"": {
      ""req1"": ""request signal from client 1"",
      ""req2"": ""request signal from client 2"",
      ""gnt1"": ""grant signal for client 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 1 equals 1 and request signal from client 2 equals 0, then grant signal for client 1 equals 1 from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req1 == 1 & state == 0) |-> (gnt2 == 0)"",
    ""Signals"": [""req1"", ""state"", ""gnt2""],
    ""Signal Explanations"": {
      ""req1"": ""request signal from client 1"",
      ""state"": ""internal state signal"",
      ""gnt2"": ""grant signal for client 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 1 equals 1 and internal state signal equals 0, then grant signal for client 2 equals 0 from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req2 == 1 & state == 1) |-> (gnt2 == 1)"",
    ""Signals"": [""req2"", ""state"", ""gnt2""],
    ""Signal Explanations"": {
      ""req2"": ""request signal from client 2"",
      ""state"": ""internal state signal"",
      ""gnt2"": ""grant signal for client 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 2 equals 1 and internal state signal equals 1, then grant signal for client 2 equals 1 from the current clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req2 == 0) |-> (gnt2 == 0)"",
    ""Signals"": [""req2"", ""gnt2""],
    ""Signal Explanations"": {
      ""req2"": ""request signal from client 2"",
      ""gnt2"": ""grant signal for client 2""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 2 equals 0, then grant signal for client 2 equals 0 from the current clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(req2 == 1 & req1 == 0) |-> (gnt2 == 1)"",
    ""Signals"": [""req2"", ""req1"", ""gnt2""],
    ""Signal Explanations"": {
      ""req2"": ""request signal from client 2"",
      ""req1"": ""request signal from client 1"",
      ""gnt2"": ""grant signal for client 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when request signal from client 2 equals 1 and request signal from client 1 equals 0, then grant signal for client 2 equals 1 from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (state && req2 |-> !gnt1);"",
""Assertion 2"": ""assert property (req1 && !state |-> gnt1);"",
""Assertion 3"": ""assert property (req1 == 0 |-> gnt1 == 0);"",
""Assertion 4"": ""assert property (req1 && !req2 |-> gnt1);"",
""Assertion 5"": ""assert property (req1 && !state |-> !gnt2);"",
""Assertion 6"": ""assert property (req2 && state |-> gnt2);"",
""Assertion 7"": ""assert property (req2 == 0 |-> gnt2 == 0);"",
""Assertion 8"": ""assert property ((!req1 && req2) |-> (gnt2));""
}"
Edge_Detector,"module Edge_Detector (
	input  clk,
	input  resetn,
	input  din,
	output dout
);

// trigger a pulse 1 cycle after din goes up
reg  edge_seen_q;
wire edge_seen_next;
reg  pulse_q;
wire pulse_next;
assign edge_seen_next = ( din & ~edge_seen_q) 
					  | ( din & edge_seen_q );
assign pulse_next      = din & ~edge_seen_q;
 
always @(posedge clk)
begin
	if ( ~resetn ) begin
		edge_seen_q <= 1'b0;
		pulse_q     <= 1'b0;
	end else begin
		edge_seen_q <= edge_seen_next;
		pulse_q     <= pulse_next;
	end
end

assign dout = pulse_q;

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~resetn)"",
    ""logical expression"": ""$rose(din_f_q) == dout"",
    ""Signals"": [""din_f_q"", ""dout""],
    ""Signal Explanations"": {
      ""din_f_q"": ""a delayed version of the input signal, updated at every clock cycle"",
      ""dout"": ""output signal representing the pulse generated when an edge is detected""
    },
    ""Logical Operators"": [""$rose"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""a function that detects a rising edge (transition from 0 to 1) of a signal in the current clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""the output signal indicates whether a rising edge can be detected on the delayed version of the input signal""
  }
}","{
""Assertion 1"": ""assert property ($rose(din) |=> dout);""
}"
VGA,"module VGA #(localparam  size = 1, localparam h_bits = 7, localparam v_bits = 5) (input clk, input rst, output reg disp_ena, output reg n_blank, output reg n_sync, output reg [h_bits-1:0] col, output reg [v_bits-1:0] row);

	localparam h_pixels = 50*size;
	localparam h_pulse = 5*size;
	localparam h_bp = 8*size;
	localparam h_fp = 3*size;
	localparam h_pol = 0;

	localparam v_pixels =  25*size;
	localparam v_pulse = size;
	localparam v_bp = 1*size;
	localparam v_fp = size;
	localparam v_pol = 1;

	localparam h_period = h_pulse + h_bp + h_pixels + h_fp;
	localparam v_period = v_pulse + v_bp + v_pixels + v_fp;

	reg [h_bits-1:0] h_cnt;
	reg [v_bits-1:0] v_cnt;
	reg h_sync;
	reg v_sync;
	always @(posedge clk) begin
		if(rst == 1) begin
			h_cnt = 0;
			v_cnt = 0;
			h_sync = ~h_sync;
			v_sync = ~v_sync;
			disp_ena = 0;
			col = 0;
			row = 0;
		end
		else begin
			if(h_cnt < h_period - 1)
				h_cnt = h_cnt + 1;
			else begin
				h_cnt = 0;
				if(v_cnt < v_period - 1)
					v_cnt = v_cnt + 1;
				else
					v_cnt = 0;
			end
			if((h_cnt < (h_pixels + h_fp)) | (h_cnt >= (h_pixels + h_fp + h_pulse)))
				h_sync = ~h_sync;
			else
				h_sync = h_pol;

			if((v_cnt < (v_pixels + v_fp)) | (v_cnt >= (v_pixels + v_fp + v_pulse)))
				v_sync = ~v_sync;
			else
				v_sync = v_pol;

			if(h_cnt < h_pixels)
				col = h_cnt;

			if(v_cnt < v_pixels)
				row = v_cnt;

			if(h_cnt < h_pixels & v_cnt < v_pixels)
				disp_ena = 1;
			else
				disp_ena = 0;
		end
	end
endmodule
","{
""Assertion 1"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""s_eventually (rst == 1 || disp_ena == 1)"",
  ""Signals"": [""rst"", ""disp_ena""],
  ""Signal Explanations"": {
    ""rst"": ""reset signal of the verilog module"",
    ""disp_ena"": ""display enable signal of the verilog module""
  },
  ""Logical Operators"": [""s_eventually"", ""||"", ""==""],
  ""Logical Operators Explanation"": {
    ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
    ""||"": ""logical OR, evaluating to true if at least one operand is true"",
    ""=="": ""equality comparison operator""
  },
  ""Assertion Explaination"": ""eventually, the reset signal equal 1 or the display enable signal equals 1""
}
}","{
""Assertion 1"": ""assert property (s_eventually (rst || disp_ena));""
}"
simple_router,"module simple_router #(
	parameter DATA_WIDTH = 32
) (
  input  rst,
  input  clk,
  input  [DATA_WIDTH-1:0] din,
  input  din_en,
  input  [1:0] addr,
  output logic [DATA_WIDTH-1:0] dout0,
  output logic [DATA_WIDTH-1:0] dout1,
  output logic [DATA_WIDTH-1:0] dout2,
  output logic [DATA_WIDTH-1:0] dout3
);

// data should be forced to 0 when not driven 
assign dout0 = {DATA_WIDTH{din_en & ( addr == 2'd0 )}} & din; 
assign dout1 = {DATA_WIDTH{din_en & ( addr == 2'd1 )}} & din; 
assign dout2 = {DATA_WIDTH{din_en & ( addr == 2'd2 )}} & din; 
assign dout3 = {DATA_WIDTH{din_en & ( addr == 2'd3 )}} & din; 


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""din_en | ((dout0 == 0) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0))"",
    ""Signals"": [""din_en"", ""dout0"", ""dout1"", ""dout2"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""data input enable signal"",
      ""dout0"": ""data output signal for address 0"",
      ""dout1"": ""data output signal for address 1"",
      ""dout2"": ""data output signal for address 2"",
      ""dout3"": ""data output signal for address 3""
    },
    ""Logical Operators"": [""|"", ""=="", ""&""],
    ""Logical Operators Explanation"": {
      ""|"": ""or"",
      ""=="": ""equal"",
      ""&"": ""and""
    },
    ""Assertion Explaination"": ""either the data input enable signal is asserted or all data output signals for addresses 0, 1, 2, and 3 are equal to zero""
  },
  ""Assertion 2"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd0)) | ((dout0 == din) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0))"",
    ""Signals"": [""din_en"", ""addr"", ""dout0"", ""din"", ""dout1"", ""dout2"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""data input enable signal"",
      ""addr"": ""2-bit address signal to select the corresponding data output"",
      ""dout0"": ""data output signal for address 0"",
      ""din"": ""data input signal"",
      ""dout1"": ""data output signal for address 1"",
      ""dout2"": ""data output signal for address 2"",
      ""dout3"": ""data output signal for address 3""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""the value is inverted (negation)"",
      ""&"": ""and"",
      ""=="": ""equal"",
      ""|"": ""or""
    },
    ""Assertion Explaination"": ""when the data input enable signal is asserted and the address signal equals 0, then the data output signal for address 0 equals the data input signal and the data output signals for addresses 1, 2, and 3 are equal to zero from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd1)) | ((dout1 == din) & (dout0 == 0) & (dout2 == 0) & (dout3 == 0))"",
    ""Signals"": [""din_en"", ""addr"", ""dout1"", ""din"", ""dout0"", ""dout2"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""data input enable signal"",
      ""addr"": ""2-bit address signal to select the corresponding data output"",
      ""dout1"": ""data output signal for address 1"",
      ""din"": ""data input signal"",
      ""dout0"": ""data output signal for address 0"",
      ""dout2"": ""data output signal for address 2"",
      ""dout3"": ""data output signal for address 3""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""the value is inverted (negation)"",
      ""&"": ""and"",
      ""=="": ""equal"",
      ""|"": ""or""
    },
    ""Assertion Explaination"": ""when the data input enable signal is asserted and the address signal equals 1, then the data output signal for address 1 equals the data input signal and the data output signals for addresses 0, 2, and 3 are equal to zero from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd2)) | ((dout2 == din) & (dout0 == 0) & (dout1 == 0) & (dout3 == 0))"",
    ""Signals"": [""din_en"", ""addr"", ""dout2"", ""din"", ""dout0"", ""dout1"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""data input enable signal"",
      ""addr"": ""2-bit address signal to select the corresponding data output"",
      ""dout2"": ""data output signal for address 2"",
      ""din"": ""data input signal"",
      ""dout0"": ""data output signal for address 0"",
      ""dout1"": ""data output signal for address 1"",
      ""dout3"": ""data output signal for address 3""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""the value is inverted (negation)"",
      ""&"": ""and"",
      ""=="": ""equal"",
      ""|"": ""or""
    },
    ""Assertion Explaination"": ""when the data input enable signal is asserted and the address signal equals 2, then the data output signal for address 2 equals the data input signal and the data output signals for addresses 0, 1, and 3 are equal to zero from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd3)) | ((dout3 == din) & (dout0 == 0) & (dout1 == 0) & (dout2 == 0))"",
    ""Signals"": [""din_en"", ""addr"", ""dout3"", ""din"", ""dout0"", ""dout1"", ""dout2""],
    ""Signal Explanations"": {
      ""din_en"": ""data input enable signal"",
      ""addr"": ""2-bit address signal to select the corresponding data output"",
      ""dout3"": ""data output signal for address 3"",
      ""din"": ""data input signal"",
      ""dout0"": ""data output signal for address 0"",
      ""dout1"": ""data output signal for address 1"",
      ""dout2"": ""data output signal for address 2""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""the value is inverted (negation)"",
      ""&"": ""and"",
      ""=="": ""equal"",
      ""|"": ""or""
    },
    ""Assertion Explaination"": ""when the data input enable signal is asserted and the address signal equals 3, then the data output signal for address 3 equals the data input signal and the data output signals for addresses 0, 1, and 2 are equal to zero from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (din_en || (dout0 == 0 && dout1 == 0 && dout2 == 0 && dout3 == 0));"",
""Assertion 2"": ""assert property ((din_en && (addr == 2'd0) |-> ((dout0 == din) && (dout1 == 0) && (dout2 == 0) && (dout3 == 0)));"",
""Assertion 3"": ""assert property ((din_en && (addr == 2'd1)) |-> (dout1 == din) && (dout0 == 0) && (dout2 == 0) && (dout3 == 0));"",
""Assertion 4"": ""assert property ((din_en && (addr == 2'd2)) |-> ((dout2 == din) && (dout0 == 0) && (dout1 == 0) && (dout3 == 0)));"",
""Assertion 5"": ""assert property ((din_en && (addr == 2'd3)) |-> (dout3 == din) && (dout0 == 0) && (dout1 == 0) && (dout2 == 0));""
}"
a25_wishbone,"//////////////////////////////////////////////////////////////////
//                                                              //
//  Wishbone master interface for the Amber 25 core             //
//                                                              //
//  This file is part of the Amber project                      //
//  http://www.opencores.org/project,amber                      //
//                                                              //
//  Description                                                 //
//  Turns memory access requests from the execute stage and     //
//  instruction and data caches into wishbone bus cycles.       //
//  For 4-word read requests from either cache and swap         //
//  accesses ( read followed by write to the same address)      //
//  from the execute stage, a block transfer is done.           //
//  All other requests result in single word transfers.         //
//                                                              //
//  Write accesses can be done in a single clock cycle on       //
//  the wishbone bus, is the destination allows it. The         //
//  next transfer will begin immediately on the                 //
//  next cycle on the bus. This looks like a block transfer     //
//  and does hold ownership of the wishbone bus, preventing     //
//  the other master ( the ethernet MAC) from gaining           //
//  ownership between those two cycles. But otherwise it would  //
//  be necessary to insert a wait cycle after every write,      //
//  slowing down the performance of the core by around 5 to     //
//  10%.                                                        //
//                                                              //
//  Author(s):                                                  //
//      - Conor Santifort, csantifort.amber@gmail.com           //
//                                                              //
//////////////////////////////////////////////////////////////////
//                                                              //
// Copyright (C) 2011 Authors and OPENCORES.ORG                 //
//                                                              //
// This source file may be used and distributed without         //
// restriction provided that this copyright statement is not    //
// removed from the file and that any derivative work contains  //
// the original copyright notice and the associated disclaimer. //
//                                                              //
// This source file is free software; you can redistribute it   //
// and/or modify it under the terms of the GNU Lesser General   //
// Public License as published by the Free Software Foundation; //
// either version 2.1 of the License, or (at your option) any   //
// later version.                                               //
//                                                              //
// This source is distributed in the hope that it will be       //
// useful, but WITHOUT ANY WARRANTY; without even the implied   //
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      //
// PURPOSE.  See the GNU Lesser General Public License for more //
// details.                                                     //
//                                                              //
// You should have received a copy of the GNU Lesser General    //
// Public License along with this source; if not, download it   //
// from http://www.opencores.org/lgpl.shtml                     //
//                                                              //
//////////////////////////////////////////////////////////////////


module a25_wishbone
(
input                       quick_n_reset,
input                       i_clk,

    // Instruction Cache Accesses
input                       i_icache_req,
input                       i_icache_qword,
input       [31:0]          i_icache_address,
output      [31:0]          o_icache_read_data,
output                      o_icache_ready,

    // Data Cache Accesses
input                       i_exclusive,      // high for read part of swap access
input                       i_dcache_cached_req,
input                       i_dcache_uncached_req,
input                       i_dcache_qword,
input                       i_dcache_write,
input       [31:0]          i_dcache_write_data,
input       [3:0]           i_dcache_byte_enable,    // valid for writes only
input       [31:0]          i_dcache_address,
output      [31:0]          o_dcache_read_data,
output                      o_dcache_cached_ready,
output                      o_dcache_uncached_ready,

// Wishbone Bus
output reg  [31:0]          o_wb_adr,
output reg  [3:0]           o_wb_sel,
output reg                  o_wb_we ,
input       [31:0]          i_wb_dat,
output reg  [31:0]          o_wb_dat,
output reg                  o_wb_cyc,
output reg                  o_wb_stb,
input                       i_wb_ack,
input                       i_wb_err

);


localparam [3:0] WB_IDLE            = 3'd0,
                 WB_BURST1          = 3'd1,
                 WB_BURST2          = 3'd2,
                 WB_BURST3          = 3'd3,
                 WB_WAIT_ACK        = 3'd4;

reg     [2:0]               wishbone_st;

wire                        icache_read_req_c;
wire                        icache_read_qword_c;
wire    [31:0]              icache_read_addr_c;
wire                        dcache_read_qword_c;

wire                        dcache_req_c;
wire                        write_req_c;
wire                        dcache_cached_rreq_c;
wire                        dcache_cached_wreq_c;
wire                        dcache_uncached_rreq_c;
wire                        dcache_uncached_wreq_c;

wire                        dcache_cached_rreq_in;
wire                        dcache_cached_wreq_in;
wire                        dcache_uncached_rreq_in;
wire                        dcache_uncached_wreq_in;

reg                         dcache_cached_rreq_r;
reg                         dcache_cached_wreq_r;
reg                         dcache_uncached_rreq_r;
reg                         dcache_uncached_wreq_r;

wire                        dcache_cached_wready;
wire                        dcache_uncached_wready;
wire                        dcache_cached_rready;
wire                        dcache_uncached_rready;

wire                        start_access;
wire    [3:0]               byte_enable;
reg                         exclusive_access;
wire                        read_ack;
wire                        wait_write_ack;
reg                         icache_read_req_r;
reg                         icache_read_qword_r;
reg     [31:0]              icache_read_addr_r;
reg                         dcache_read_qword_r;
wire                        icache_read_req_in;
wire                        icache_read_ready;
reg                         servicing_dcache_cached_read_r;
reg                         servicing_dcache_uncached_read_r;
reg                         servicing_icache_r;
wire                        extra_write;
reg                         extra_write_r;
reg     [31:0]              extra_write_data_r;
reg     [31:0]              extra_write_address_r;
reg     [3:0]               extra_write_be_r;

assign read_ack                 = !o_wb_we && i_wb_ack;

assign dcache_cached_rready     = dcache_cached_rreq_r   && servicing_dcache_cached_read_r   && read_ack;
assign dcache_uncached_rready   = dcache_uncached_rreq_r && servicing_dcache_uncached_read_r && read_ack;


assign o_dcache_cached_ready    = dcache_cached_rready   || dcache_cached_wready;
assign o_dcache_uncached_ready  = dcache_uncached_rready || dcache_uncached_wready;
assign o_dcache_read_data       = i_wb_dat;
                                 
assign icache_read_ready        = servicing_icache_r && read_ack;
assign o_icache_ready           = icache_read_ready; 
assign o_icache_read_data       = i_wb_dat;


assign dcache_cached_rreq_in    = i_dcache_cached_req   && !i_dcache_write;
assign dcache_cached_wreq_in    = i_dcache_cached_req   &&  i_dcache_write;
assign dcache_uncached_rreq_in  = i_dcache_uncached_req && !i_dcache_write;
assign dcache_uncached_wreq_in  = i_dcache_uncached_req &&  i_dcache_write;
assign icache_read_req_in       = i_icache_req && !o_icache_ready;

assign dcache_cached_rreq_c     = ( dcache_cached_rreq_in   || dcache_cached_rreq_r   ) && !(servicing_dcache_cached_read_r   && read_ack);
assign dcache_uncached_rreq_c   = ( dcache_uncached_rreq_in || dcache_uncached_rreq_r ) && !(servicing_dcache_uncached_read_r && read_ack);

assign dcache_read_qword_c      = ( i_dcache_qword       || dcache_read_qword_r ) && !(servicing_dcache_cached_read_r && read_ack);

assign icache_read_req_c        = ( icache_read_req_in   || icache_read_req_r   ) && !(servicing_icache_r && read_ack);
assign icache_read_qword_c      = ( i_icache_qword       || icache_read_qword_r ) && !(servicing_icache_r && read_ack);
assign icache_read_addr_c       = i_icache_req ?  i_icache_address : icache_read_addr_r;

assign dcache_req_c             = dcache_cached_rreq_c || dcache_cached_wreq_c || dcache_uncached_rreq_c || dcache_uncached_wreq_c;
assign write_req_c              = dcache_cached_wreq_c || dcache_uncached_wreq_c;

assign start_access             = !wait_write_ack && (dcache_req_c || icache_read_req_c);

// For writes the byte enable is always 4'hf
assign byte_enable              = write_req_c ? i_dcache_byte_enable : 4'hf;
                                    

assign dcache_cached_wready     = (dcache_cached_wreq_c && wishbone_st == WB_IDLE);
assign dcache_uncached_wready   = (dcache_uncached_wreq_c && wishbone_st == WB_IDLE);
assign dcache_cached_wreq_c     = dcache_cached_wreq_in   || dcache_cached_wreq_r;
assign dcache_uncached_wreq_c   = dcache_uncached_wreq_in || dcache_uncached_wreq_r;


// ======================================
// Register Accesses
// ======================================

assign extra_write =  wishbone_st == WB_IDLE && !i_wb_ack && ((dcache_cached_wreq_c && dcache_cached_wready)||
                                                              (dcache_uncached_wreq_c && dcache_uncached_wready));

//shz always @( posedge i_clk or negedge quick_n_reset)
always @( posedge i_clk)
    if ( !quick_n_reset)
	o_wb_dat <= 'd0;
    else if ( wishbone_st == WB_WAIT_ACK && i_wb_ack && extra_write_r )
        o_wb_dat <= extra_write_data_r;
    else if ( start_access )
        o_wb_dat <= i_dcache_write_data;


//shz always @( posedge i_clk or negedge quick_n_reset )
always @( posedge i_clk )
    if ( !quick_n_reset)
    begin
	dcache_cached_rreq_r   <= 'd0;
	dcache_cached_wreq_r   <= 'd0;
	dcache_uncached_rreq_r <= 'd0;
	dcache_uncached_wreq_r <= 'd0;
	icache_read_req_r  <= 'd0;
	icache_read_qword_r  <= 'd0;
	icache_read_addr_r  <= 'd0;
	dcache_read_qword_r  <= 'd0;
    end
    else
    begin
    icache_read_req_r   <= icache_read_req_in  || icache_read_req_c;
    icache_read_qword_r <= i_icache_qword      || icache_read_qword_c;
    if ( i_icache_req ) icache_read_addr_r  <= i_icache_address;
        
    dcache_read_qword_r    <= i_dcache_qword      || dcache_read_qword_c;
    dcache_cached_wreq_r   <= dcache_cached_wreq_c   && (wishbone_st != WB_IDLE || (o_wb_stb && !i_wb_ack));
    dcache_uncached_wreq_r <= dcache_uncached_wreq_c && (wishbone_st != WB_IDLE || (o_wb_stb && !i_wb_ack));
    
    
    // A buffer to hold a second write while on eis in progress
    if ( extra_write )
        begin
        extra_write_data_r      <= i_dcache_write_data;
        extra_write_address_r   <= i_dcache_address;
        extra_write_be_r        <= i_dcache_byte_enable;
        end


    // The flag can be set during any state but only cleared during WB_IDLE or WB_WAIT_ACK
    if ( dcache_cached_rreq_r )
        begin
        if ( wishbone_st == WB_IDLE || wishbone_st == WB_WAIT_ACK )
            dcache_cached_rreq_r <= dcache_cached_rreq_c && !o_dcache_cached_ready;
        end    
    else    
        dcache_cached_rreq_r <= dcache_cached_rreq_c && !o_dcache_cached_ready;
    if ( dcache_uncached_rreq_r )
        begin
        if ( wishbone_st == WB_IDLE || wishbone_st == WB_WAIT_ACK )
            dcache_uncached_rreq_r <= dcache_uncached_rreq_c && !o_dcache_uncached_ready;
        end    
    else    
        dcache_uncached_rreq_r <= dcache_uncached_rreq_c && !o_dcache_uncached_ready;
    end
    
assign wait_write_ack = o_wb_stb && o_wb_we && !i_wb_ack;


//shz always @( posedge i_clk or negedge quick_n_reset)
always @( posedge i_clk)
    if ( !quick_n_reset)
	begin
		o_wb_adr <= 'd0;
		o_wb_sel <= 'd0;
		o_wb_we  <= 'd0;
		o_wb_cyc <= 'd0;
		o_wb_stb <= 'd0;
		servicing_dcache_cached_read_r <= 'd0;
		servicing_dcache_uncached_read_r <= 'd0;
		servicing_icache_r <= 'd0;
		extra_write_r <= 'd0;
		exclusive_access <= 'd0;
		wishbone_st <= WB_IDLE;
	end
    else
    case ( wishbone_st )
        WB_IDLE :
            begin 
            extra_write_r <= extra_write;
            
            if ( start_access )
                begin
                o_wb_stb            <= 1'd1; 
                o_wb_cyc            <= 1'd1; 
                o_wb_sel            <= byte_enable;
                end
            else if ( !wait_write_ack )
                begin
                o_wb_stb            <= 1'd0;
                
                // Hold cyc high after an exclusive access
                // to hold ownership of the wishbone bus
                o_wb_cyc            <= exclusive_access;
                end

            if ( wait_write_ack )
                begin
                // still waiting for last (write) access to complete
                wishbone_st                      <= WB_WAIT_ACK;
                servicing_dcache_cached_read_r   <= dcache_cached_rreq_c;
                servicing_dcache_uncached_read_r <= dcache_uncached_rreq_c;
                end 
            // dcache accesses have priority over icache     
            else if ( dcache_cached_rreq_c || dcache_uncached_rreq_c )
                begin
                if ( dcache_cached_rreq_c )
                    servicing_dcache_cached_read_r <= 1'd1;
                else if ( dcache_uncached_rreq_c )
                    servicing_dcache_uncached_read_r <= 1'd1;
                
                if ( dcache_read_qword_c )
                    wishbone_st         <= WB_BURST1;
                else
                    wishbone_st         <= WB_WAIT_ACK;
                exclusive_access    <= i_exclusive;
                end                    
           // The core does not currently issue exclusive write requests
           // but there's no reason why this might not be added some
           // time in the future so allow for it here
            else if ( write_req_c )
                begin
                exclusive_access            <= i_exclusive;
                end
            // do a burst of 4 read to fill a cache line                   
            else if ( icache_read_req_c && icache_read_qword_c )
                begin
                wishbone_st                 <= WB_BURST1;
                exclusive_access            <= 1'd0;
                servicing_icache_r          <= 1'd1;
                end                    
            // single word read request from fetch stage                   
            else if ( icache_read_req_c )
                begin
                wishbone_st                 <= WB_WAIT_ACK;
                exclusive_access            <= 1'd0;
                servicing_icache_r          <= 1'd1;
                end                    

                            
            if ( start_access )
                begin
                if ( dcache_req_c )
                    begin
                    o_wb_we              <= write_req_c;
                    // only update these on new wb access to make debug easier
                    o_wb_adr[31:2]       <= i_dcache_address[31:2];
                    o_wb_adr[1:0]        <= byte_enable == 4'b0001 ? 2'd0 :
                                            byte_enable == 4'b0010 ? 2'd1 :
                                            byte_enable == 4'b0100 ? 2'd2 :
                                            byte_enable == 4'b1000 ? 2'd3 :
                                           
                                            byte_enable == 4'b0011 ? 2'd0 :
                                            byte_enable == 4'b1100 ? 2'd2 :
                                           
                                                                     2'd0 ;
                    end                                                 
                else 
                    begin
                    o_wb_we              <= 1'd0;
                    o_wb_adr[31:0]       <= {icache_read_addr_c[31:2], 2'd0};
                    end                                                
                end
            end
                    

        // Read burst, wait for first ack
        WB_BURST1:  
            if ( i_wb_ack )
                begin
                // burst of 4 that wraps
                o_wb_adr[3:2]   <= o_wb_adr[3:2] + 1'd1;
                wishbone_st     <= WB_BURST2;
                end
            
            
        // Read burst, wait for second ack
        WB_BURST2:  
            if ( i_wb_ack )
                begin
                // burst of 4 that wraps
                o_wb_adr[3:2]   <= o_wb_adr[3:2] + 1'd1;
                wishbone_st     <= WB_BURST3;
                end
            
            
        // Read burst, wait for third ack
        WB_BURST3:  
            if ( i_wb_ack )
                begin
                // burst of 4 that wraps
                o_wb_adr[3:2]   <= o_wb_adr[3:2] + 1'd1;
                wishbone_st     <= WB_WAIT_ACK;
                end


        // Wait for the wishbone ack to be asserted
        WB_WAIT_ACK:   
            if ( i_wb_ack )
                // Another write that was acked and needs to be sent before returning to IDLE ?
                if ( extra_write_r )
                    begin
                    extra_write_r                       <= 'd0;
                    o_wb_stb                            <= 1'd1; 
                    o_wb_cyc                            <= exclusive_access; 
                    o_wb_sel                            <= extra_write_be_r;
                    o_wb_we                             <= 1'd1;
                    o_wb_adr[31:0]                      <= extra_write_address_r;
                    end
                else    
                    begin
                    wishbone_st                         <= WB_IDLE;
                    o_wb_stb                            <= 1'd0; 
                    o_wb_cyc                            <= exclusive_access; 
                    o_wb_we                             <= 1'd0;
                    servicing_dcache_cached_read_r      <= 1'd0;
                    servicing_dcache_uncached_read_r    <= 1'd0;
                    servicing_icache_r                  <= 1'd0;
                    end
                         
            
    endcase

// ========================================================
// Debug Wishbone bus - not synthesizable
// ========================================================
//synopsys translate_off
wire    [(14*8)-1:0]   xWB_STATE;


assign xWB_STATE  = wishbone_st == WB_IDLE       ? """"WB_IDLE""""       :
                    wishbone_st == WB_BURST1     ? """"WB_BURST1""""     :
                    wishbone_st == WB_BURST2     ? """"WB_BURST2""""     :
                    wishbone_st == WB_BURST3     ? """"WB_BURST3""""     :
                    wishbone_st == WB_WAIT_ACK   ? """"WB_WAIT_ACK""""   :
                                                   """"UNKNOWN""""       ;

//synopsys translate_on
    
endmodule
","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_IDLE) |-> ##1 (wishbone_st == WB_IDLE) | (wishbone_st == WB_BURST1) | (wishbone_st == WB_WAIT_ACK)"",
    ""Signals"": [
      ""wishbone_st""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the 3‐bit state signal of the wishbone bus interface""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""##1"",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""a temporal delay operator indicating that the condition on the right must hold one clock cycle later"",
      ""|"": ""or""
    },
    ""Assertion Explaination"": ""When the wishbone bus state equals WB_IDLE, then the wishbone bus state equals WB_IDLE or WB_BURST1 or WB_WAIT_ACK from the next clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_BURST1) & i_wb_ack |-> ##1 (wishbone_st == WB_BURST2)"",
    ""Signals"": [
      ""wishbone_st"",
      ""i_wb_ack""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the 3‐bit state signal of the wishbone bus interface"",
      ""i_wb_ack"": ""the wishbone bus acknowledgement input signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""a temporal delay operator indicating that the condition on the right must hold one clock cycle later""
    },
    ""Assertion Explaination"": ""When the wishbone bus state equals WB_BURST1 and the acknowledgement signal is asserted, then the wishbone bus state equals WB_BURST2 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_BURST2) & i_wb_ack |->##1 (wishbone_st == WB_BURST3)"",
    ""Signals"": [
      ""wishbone_st"",
      ""i_wb_ack""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the 3‐bit state signal of the wishbone bus interface"",
      ""i_wb_ack"": ""the wishbone bus acknowledgement input signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""a temporal delay operator indicating that the condition on the right must hold one clock cycle later""
    },
    ""Assertion Explaination"": ""When the wishbone bus state equals WB_BURST2 and the acknowledgement signal is asserted, then the wishbone bus state equals WB_BURST3 from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_BURST3) & i_wb_ack |->##1 ( wishbone_st == WB_WAIT_ACK)"",
    ""Signals"": [
      ""wishbone_st"",
      ""i_wb_ack""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the 3‐bit state signal of the wishbone bus interface"",
      ""i_wb_ack"": ""the wishbone bus acknowledgement input signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""a temporal delay operator indicating that the condition on the right must hold one clock cycle later""
    },
    ""Assertion Explaination"": ""When the wishbone bus state equals WB_BURST3 and the acknowledgement signal is asserted, then the wishbone bus state equals WB_WAIT_ACK from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_WAIT_ACK) & (extra_write_r || !i_wb_ack) |->##1 (wishbone_st == WB_WAIT_ACK)"",
    ""Signals"": [
      ""wishbone_st"",
      ""extra_write_r"",
      ""i_wb_ack""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the 3‐bit state signal of the wishbone bus interface"",
      ""extra_write_r"": ""a register flag indicating an extra write request is buffered"",
      ""i_wb_ack"": ""the wishbone bus acknowledgement input signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""||"",
      ""!"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""||"": ""or"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""a temporal delay operator indicating that the condition on the right must hold one clock cycle later""
    },
    ""Assertion Explaination"": ""When the wishbone bus state equals WB_WAIT_ACK and either the extra write flag is set or the acknowledgement signal is not asserted, then the wishbone bus state equals WB_WAIT_ACK from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_WAIT_ACK) & (!extra_write_r && i_wb_ack) |->##1 (wishbone_st == WB_IDLE)"",
    ""Signals"": [
      ""wishbone_st"",
      ""extra_write_r"",
      ""i_wb_ack""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the 3‐bit state signal of the wishbone bus interface"",
      ""extra_write_r"": ""a register flag indicating an extra write request is buffered"",
      ""i_wb_ack"": ""the wishbone bus acknowledgement input signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""!"",
      ""&&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""a temporal delay operator indicating that the condition on the right must hold one clock cycle later""
    },
    ""Assertion Explaination"": ""When the wishbone bus state equals WB_WAIT_ACK and the extra write flag is not set and the acknowledgement signal is asserted, then the wishbone bus state equals WB_IDLE from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((wishbone_st == WB_IDLE) |=> (wishbone_st == WB_IDLE || wishbone_st == WB_BURST1 || wishbone_st == WB_WAIT_ACK));"",
""Assertion 2"": ""assert property ((wishbone_st == WB_BURST1 && i_wb_ack) |=> (wishbone_st == WB_BURST2));"",
""Assertion 3"": ""assert property ((wishbone_st == WB_BURST2 && i_wb_ack) |=> (wishbone_st == WB_BURST3));"",
""Assertion 4"": ""assert property ((wishbone_st == WB_BURST3 && i_wb_ack) |=> (wishbone_st == WB_WAIT_ACK));"",
""Assertion 5"": ""assert property ((wishbone_st == WB_WAIT_ACK && (extra_write_r || !i_wb_ack)) |=> (wishbone_st == WB_WAIT_ACK));"",
""Assertion 6"": ""assert property ((wishbone_st == WB_WAIT_ACK && !extra_write_r && i_wb_ack) |=> (wishbone_st == WB_IDLE));""
}"
second_largest,"module second_largest #(parameter
  DATA_WIDTH = 32
) (
  input clk,
  input resetn,
  input [DATA_WIDTH-1:0] din,
  output logic [DATA_WIDTH-1:0] dout
);

reg  [DATA_WIDTH-1:0] max_q;
wire [DATA_WIDTH-1:0] max_next;
reg  [DATA_WIDTH-1:0] max2_q; // second largest
wire [DATA_WIDTH-1:0] max2_next;

wire new_max;

assign new_max   = ( max_q < din);
assign max_next  = new_max ? din : max_q;
assign max2_next = new_max ? max_q : max2_q; 

always @(posedge clk)
begin
	if(~resetn) begin
		max_q  <= {DATA_WIDTH{1'b0}}; 
		max2_q <= {DATA_WIDTH{1'b0}}; 
	end
	else begin
		max_q  <= max_next;
		max2_q <= max2_next;
	end
end

// output 
assign dout = max2_q;

`ifdef FORMAL

initial begin
	// assumption
	// max_q and max2_q are not equal on init unless 0
	a_init : assume property ( (max_q == 0 & max2_q == 0) | ( max2_q < max_q));
end

always @(posedge clk)
begin
	if (~resetn) begin
		
		// assertions
		sva_max_greater_max2: assert( (max_q == 0) | ( max_q > max2_q )); 

		// cover
		c_max_zero : cover ( max_q == 0 );
		c_change : cover ( din != dout );
		c_max_greater : cover ( max_q > max2_q );	
		c_max_update : cover ( new_max );
	end
	c_reset : cover ( resetn );
end
`endif // FORMAL 
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~resetn)"",
    ""logical expression"": ""(max_q == 0) | (max_q > max2_q)"",
    ""Signals"": [""max_q"", ""max2_q"", ""resetn""],
    ""Signal Explanations"": {
      ""max_q"": ""holds the maximum value seen so far"",
      ""max2_q"": ""holds the second largest value seen so far"",
      ""resetn"": ""active low reset signal; when high, the system is operational""
    },
    ""Logical Operators"": [""=="", ""|"", "">""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|"": ""or"",
      "">"": ""greater-than""
    },
    ""Assertion Explaination"": ""the maximum value held equals 0 or the maximum value held is greater-than the second largest value held""
  }
}","{
""Assertion 1"": ""assert property ((max_q == 0) || (max_q > max2_q));""
}"
reversing_bits,"module reversing_bits #(
	parameter DATA_WIDTH=3
) 
(
  input clk,
  input rst,
  input  [DATA_WIDTH-1:0]       din,
  output logic [DATA_WIDTH-1:0] dout
);

genvar i;
generate;
	for (i=0; i<DATA_WIDTH; i++) begin
		assign dout[i] = din[DATA_WIDTH-i-1];
	end
endgenerate

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst)"",
    ""logical expression"": ""dout[0] == din[DATA_WIDTH-1]"",
    ""Signals"": [""dout"", ""din""],
    ""Signal Explanations"": {
      ""dout"": ""reversed output bus signal"",
      ""din"": ""input bus signal to be reversed""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""reversed output bus signal's first bit equals input bus signal's DATA_WIDTH-1-th bit""
  }
}","{
""Assertion 1"": ""assert property (dout[0] == din[DATA_WIDTH-1]);""
}"
or1200_ctrl,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Instruction decode                                 ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Majority of instruction decoding is performed here.         ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_ctrl.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_ctrl
  (
   // Clock and reset
   clk, rst,
   
   // Internal i/f
   except_flushpipe, extend_flush, if_flushpipe, id_flushpipe, ex_flushpipe, 
   wb_flushpipe,
   id_freeze, ex_freeze, wb_freeze, if_insn, id_insn, ex_insn, abort_mvspr, 
   id_branch_op, ex_branch_op, ex_branch_taken, pc_we, 
   rf_addra, rf_addrb, rf_rda, rf_rdb, alu_op, alu_op2, mac_op,
   comp_op, rf_addrw, rfwb_op, fpu_op,
   wb_insn, id_simm, ex_simm, id_branch_addrtarget, ex_branch_addrtarget, sel_a,
   sel_b, id_lsu_op,
   cust5_op, cust5_limm, id_pc, ex_pc, du_hwbkpt, 
   multicycle, wait_on, wbforw_valid, sig_syscall, sig_trap,
   force_dslot_fetch, no_more_dslot, id_void, ex_void, ex_spr_read, 
   ex_spr_write, du_flush_pipe,
   id_mac_op, id_macrc_op, ex_macrc_op, rfe, except_illegal, dc_no_writethrough
   );

//
// I/O
//
input					clk;
input					rst;
input					id_freeze;
input					ex_freeze /* verilator public */;
input					wb_freeze /* verilator public */;
output					if_flushpipe;
output					id_flushpipe;
output					ex_flushpipe;
output					wb_flushpipe;
input					extend_flush;
input					except_flushpipe;
input                           abort_mvspr ;
input	[31:0]			if_insn;
output	[31:0]			id_insn;
output	[31:0]			ex_insn /* verilator public */;
output	[`OR1200_BRANCHOP_WIDTH-1:0]		ex_branch_op;
output	[`OR1200_BRANCHOP_WIDTH-1:0]		id_branch_op;
input						ex_branch_taken;
output	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addrw;
output	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addra;
output	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addrb;
output					rf_rda;
output					rf_rdb;
output	[`OR1200_ALUOP_WIDTH-1:0]		alu_op;
output [`OR1200_ALUOP2_WIDTH-1:0] 		alu_op2;
output	[`OR1200_MACOP_WIDTH-1:0]		mac_op;
output	[`OR1200_RFWBOP_WIDTH-1:0]		rfwb_op;
output  [`OR1200_FPUOP_WIDTH-1:0] 		fpu_op;      
input					pc_we;
output	[31:0]				wb_insn;
output	[31:2]				id_branch_addrtarget;
output	[31:2]				ex_branch_addrtarget;
output	[`OR1200_SEL_WIDTH-1:0]		sel_a;
output	[`OR1200_SEL_WIDTH-1:0]		sel_b;
output	[`OR1200_LSUOP_WIDTH-1:0]		id_lsu_op;
output	[`OR1200_COMPOP_WIDTH-1:0]		comp_op;
output	[`OR1200_MULTICYCLE_WIDTH-1:0]		multicycle;
output  [`OR1200_WAIT_ON_WIDTH-1:0] 		wait_on;   
output	[4:0]				cust5_op;
output	[5:0]				cust5_limm;
input   [31:0]                          id_pc;
input   [31:0]                          ex_pc;
output	[31:0]				id_simm;
output	[31:0]				ex_simm;
input					wbforw_valid;
input					du_hwbkpt;
output					sig_syscall;
output					sig_trap;
output					force_dslot_fetch;
output					no_more_dslot;
output					id_void;
output					ex_void;
output					ex_spr_read;
output					ex_spr_write;
output	[`OR1200_MACOP_WIDTH-1:0]	id_mac_op;
output					id_macrc_op;
output					ex_macrc_op;
output					rfe;
output					except_illegal;
output  				dc_no_writethrough;
input					du_flush_pipe;

//
// Internal wires and regs
//
reg	[`OR1200_BRANCHOP_WIDTH-1:0]		id_branch_op;
reg	[`OR1200_BRANCHOP_WIDTH-1:0]		ex_branch_op;
reg	[`OR1200_ALUOP_WIDTH-1:0]		alu_op;
reg [`OR1200_ALUOP2_WIDTH-1:0]      		alu_op2;
wire					if_maci_op;
`ifdef OR1200_MAC_IMPLEMENTED
reg	[`OR1200_MACOP_WIDTH-1:0]		ex_mac_op;
reg	[`OR1200_MACOP_WIDTH-1:0]		id_mac_op;
wire	[`OR1200_MACOP_WIDTH-1:0]		mac_op;
reg					ex_macrc_op;
`else
wire	[`OR1200_MACOP_WIDTH-1:0]		mac_op;
wire					ex_macrc_op;
`endif
reg	[31:0]				id_insn /* verilator public */;
reg	[31:0]				ex_insn /* verilator public */;
reg	[31:0]				wb_insn /* verilator public */;
reg	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addrw;
reg	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	wb_rfaddrw;
reg	[`OR1200_RFWBOP_WIDTH-1:0]		rfwb_op;
reg	[`OR1200_SEL_WIDTH-1:0]		sel_a;
reg	[`OR1200_SEL_WIDTH-1:0]		sel_b;
reg					sel_imm;
reg	[`OR1200_LSUOP_WIDTH-1:0]		id_lsu_op;
reg	[`OR1200_COMPOP_WIDTH-1:0]		comp_op;
reg	[`OR1200_MULTICYCLE_WIDTH-1:0]		multicycle;
reg     [`OR1200_WAIT_ON_WIDTH-1:0] 		wait_on;      
reg 	[31:0]				id_simm;
reg 	[31:0]				ex_simm;
reg					sig_syscall;
reg					sig_trap;
reg					except_illegal;
wire					id_void;
wire					ex_void;
wire                                    wb_void;
reg                                     ex_delayslot_dsi;
reg                                     ex_delayslot_nop;
reg					spr_read;
reg					spr_write;
reg     [31:2]				ex_branch_addrtarget;
`ifdef OR1200_DC_NOSTACKWRITETHROUGH
reg 					dc_no_writethrough;
`endif
   
//
// Register file read addresses
//
assign rf_addra = if_insn[20:16];
assign rf_addrb = if_insn[15:11];
assign rf_rda = if_insn[31] || if_maci_op;
assign rf_rdb = if_insn[30];

//
// Force fetch of delay slot instruction when jump/branch is preceeded by 
// load/store instructions
//
assign force_dslot_fetch = 1'b0;
assign no_more_dslot = (|ex_branch_op & !id_void & ex_branch_taken) | 
		       (ex_branch_op == `OR1200_BRANCHOP_RFE);

assign id_void = (id_insn[31:26] == `OR1200_OR32_NOP) & id_insn[16];
assign ex_void = (ex_insn[31:26] == `OR1200_OR32_NOP) & ex_insn[16];
assign wb_void = (wb_insn[31:26] == `OR1200_OR32_NOP) & wb_insn[16];

assign ex_spr_write = spr_write && !abort_mvspr;
assign ex_spr_read = spr_read && !abort_mvspr;

//
// ex_delayslot_dsi: delay slot insn is in EX stage
// ex_delayslot_nop: (filler) nop insn is in EX stage (before nops 
//                   jump/branch was executed)
//
//  ex_delayslot_dsi & !ex_delayslot_nop - DS insn in EX stage
//  !ex_delayslot_dsi & ex_delayslot_nop - NOP insn in EX stage, 
//       next different is DS insn, previous different was Jump/Branch
//  !ex_delayslot_dsi & !ex_delayslot_nop - normal insn in EX stage
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
        if (rst == `OR1200_RST_VALUE) begin
		ex_delayslot_nop <=  1'b0;
		ex_delayslot_dsi <=  1'b0;
	end
	else if (!ex_freeze & !ex_delayslot_dsi & ex_delayslot_nop) begin
		ex_delayslot_nop <=  id_void;
		ex_delayslot_dsi <=  !id_void;
	end
	else if (!ex_freeze & ex_delayslot_dsi & !ex_delayslot_nop) begin
		ex_delayslot_nop <=  1'b0;
		ex_delayslot_dsi <=  1'b0;
	end
	else if (!ex_freeze) begin
		ex_delayslot_nop <=  id_void && ex_branch_taken && 
				     (ex_branch_op != `OR1200_BRANCHOP_NOP) && 
				     (ex_branch_op != `OR1200_BRANCHOP_RFE);
	        ex_delayslot_dsi <=  !id_void && ex_branch_taken && 
				     (ex_branch_op != `OR1200_BRANCHOP_NOP) && 
				     (ex_branch_op != `OR1200_BRANCHOP_RFE);
	end
end

//
// Flush pipeline
//
assign if_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign id_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign ex_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign wb_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;

//
// EX Sign/Zero extension of immediates
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_simm <=  32'h0000_0000;
	else if (!ex_freeze) begin
		ex_simm <=  id_simm;
	end
end

//
// ID Sign/Zero extension of immediate
//
always @(id_insn) begin
	case (id_insn[31:26])     // synopsys parallel_case

	// l.addi
	`OR1200_OR32_ADDI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.addic
	`OR1200_OR32_ADDIC:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.lxx (load instructions)
	`OR1200_OR32_LWZ, `OR1200_OR32_LWS,
   `OR1200_OR32_LBZ, `OR1200_OR32_LBS,
	`OR1200_OR32_LHZ, `OR1200_OR32_LHS:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.muli
	`ifdef OR1200_MULT_IMPLEMENTED
	`OR1200_OR32_MULI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};
	`endif

	// l.maci
	`ifdef OR1200_MAC_IMPLEMENTED
	`OR1200_OR32_MACI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};
	`endif

	// l.mtspr
	`OR1200_OR32_MTSPR:
		id_simm = {16'b0, id_insn[25:21], id_insn[10:0]};

	// l.sxx (store instructions)
	`OR1200_OR32_SW, `OR1200_OR32_SH, `OR1200_OR32_SB:
		id_simm = {{16{id_insn[25]}}, id_insn[25:21], id_insn[10:0]};

	// l.xori
	`OR1200_OR32_XORI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.sfxxi (SFXX with immediate)
	`OR1200_OR32_SFXXI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// Instructions with no or zero extended immediate
	default:
		id_simm = {{16'b0}, id_insn[15:0]};

	endcase
end

//
// ID Sign extension of branch offset
//
assign id_branch_addrtarget = {{4{id_insn[25]}}, id_insn[25:0]} + id_pc[31:2];

//
// EX Sign extension of branch offset
//

// pipeline ID and EX branch target address 
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_branch_addrtarget <=  0;
	else if (!ex_freeze) 
		ex_branch_addrtarget <=  id_branch_addrtarget;
end
// not pipelined
//assign ex_branch_addrtarget = {{4{ex_insn[25]}}, ex_insn[25:0]} + ex_pc[31:2];

//
// l.maci in IF stage
//
`ifdef OR1200_MAC_IMPLEMENTED
assign if_maci_op = (if_insn[31:26] == `OR1200_OR32_MACI);
`else
assign if_maci_op = 1'b0;
`endif

//
// l.macrc in ID stage
//
`ifdef OR1200_MAC_IMPLEMENTED
assign id_macrc_op = (id_insn[31:26] == `OR1200_OR32_MACRC) & id_insn[16];
`else
assign id_macrc_op = 1'b0;
`endif

//
// l.macrc in EX stage
//
`ifdef OR1200_MAC_IMPLEMENTED
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_macrc_op <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_macrc_op <=  1'b0;
	else if (!ex_freeze)
		ex_macrc_op <=  id_macrc_op;
end
`else
assign ex_macrc_op = 1'b0;
`endif

//
// cust5_op, cust5_limm (L immediate)
//
assign cust5_op = ex_insn[4:0];
assign cust5_limm = ex_insn[10:5];

//
//
//
assign rfe = (id_branch_op == `OR1200_BRANCHOP_RFE) | 
	     (ex_branch_op == `OR1200_BRANCHOP_RFE);

   
`ifdef verilator
   // Function to access wb_insn (for Verilator). Have to hide this from
   // simulator, since functions with no inputs are not allowed in IEEE
   // 1364-2001.
   function [31:0] get_wb_insn;
      // verilator public
      get_wb_insn = wb_insn;
   endfunction // get_wb_insn

   // Function to access id_insn (for Verilator). Have to hide this from
   // simulator, since functions with no inputs are not allowed in IEEE
   // 1364-2001.
   function [31:0] get_id_insn;
      // verilator public
      get_id_insn = id_insn;
   endfunction // get_id_insn

   // Function to access ex_insn (for Verilator). Have to hide this from
   // simulator, since functions with no inputs are not allowed in IEEE
   // 1364-2001.
   function [31:0] get_ex_insn;
      // verilator public
      get_ex_insn = ex_insn;
   endfunction // get_ex_insn
   
`endif

   
//
// Generation of sel_a
//
always @(rf_addrw or id_insn or rfwb_op or wbforw_valid or wb_rfaddrw)
	if ((id_insn[20:16] == rf_addrw) && rfwb_op[0])
		sel_a = `OR1200_SEL_EX_FORW;
	else if ((id_insn[20:16] == wb_rfaddrw) && wbforw_valid)
		sel_a = `OR1200_SEL_WB_FORW;
	else
		sel_a = `OR1200_SEL_RF;

//
// Generation of sel_b
//
always @(rf_addrw or sel_imm or id_insn or rfwb_op or wbforw_valid or 
	 wb_rfaddrw)
	if (sel_imm)
		sel_b = `OR1200_SEL_IMM;
	else if ((id_insn[15:11] == rf_addrw) && rfwb_op[0])
		sel_b = `OR1200_SEL_EX_FORW;
	else if ((id_insn[15:11] == wb_rfaddrw) && wbforw_valid)
		sel_b = `OR1200_SEL_WB_FORW;
	else
		sel_b = `OR1200_SEL_RF;

//
// Decode of multicycle
//
always @(id_insn) begin
  case (id_insn[31:26])		// synopsys parallel_case
    // l.rfe
    `OR1200_OR32_RFE,
    // l.mfspr
    `OR1200_OR32_MFSPR:
      multicycle = `OR1200_TWO_CYCLES;	// to read from ITLB/DTLB (sync RAMs)
    // Single cycle instructions
    default: begin
      multicycle = `OR1200_ONE_CYCLE;
    end    
  endcase
end // always @ (id_insn)

//
// Encode wait_on signal
//    
always @(id_insn) begin
   case (id_insn[31:26])		// synopsys parallel_case
     `OR1200_OR32_ALU: 
       wait_on =  ( 1'b0
`ifdef OR1200_DIV_IMPLEMENTED
                     | (id_insn[4:0] == `OR1200_ALUOP_DIV)
		     | (id_insn[4:0] == `OR1200_ALUOP_DIVU)
`endif
`ifdef OR1200_MULT_IMPLEMENTED
		     | (id_insn[4:0] == `OR1200_ALUOP_MUL)
		     | (id_insn[4:0] == `OR1200_ALUOP_MULU)
`endif
		    ) ? `OR1200_WAIT_ON_MULTMAC : `OR1200_WAIT_ON_NOTHING;
`ifdef OR1200_MULT_IMPLEMENTED
`ifdef OR1200_MAC_IMPLEMENTED
     `OR1200_OR32_MACMSB,
     `OR1200_OR32_MACI,
`endif
     `OR1200_OR32_MULI:       
	 wait_on = `OR1200_WAIT_ON_MULTMAC;
`endif
`ifdef OR1200_MAC_IMPLEMENTED
     `OR1200_OR32_MACRC:
         wait_on = id_insn[16] ? `OR1200_WAIT_ON_MULTMAC : 
		                 `OR1200_WAIT_ON_NOTHING;
`endif		   
`ifdef OR1200_FPU_IMPLEMENTED
       `OR1200_OR32_FLOAT: begin
	 wait_on = id_insn[`OR1200_FPUOP_DOUBLE_BIT] ? 0 : `OR1200_WAIT_ON_FPU;
       end
`endif
`ifndef OR1200_DC_WRITEHROUGH
     // l.mtspr
     `OR1200_OR32_MTSPR: begin
	wait_on = `OR1200_WAIT_ON_MTSPR;
     end
`endif
     default: begin
	wait_on = `OR1200_WAIT_ON_NOTHING;
     end
   endcase // case (id_insn[31:26])
end // always @ (id_insn)
   
   
   
   
//
// Register file write address
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		rf_addrw <=  5'd0;
	else if (!ex_freeze & id_freeze)
		rf_addrw <=  5'd00;
	else if (!ex_freeze)
		case (id_insn[31:26])	// synopsys parallel_case
			`OR1200_OR32_JAL, `OR1200_OR32_JALR:
				rf_addrw <=  5'd09;	// link register r9
			default:
				rf_addrw <=  id_insn[25:21];
		endcase
end

//
// rf_addrw in wb stage (used in forwarding logic)
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		wb_rfaddrw <=  5'd0;
	else if (!wb_freeze)
		wb_rfaddrw <=  rf_addrw;
end

//
// Instruction latch in id_insn
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		id_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};
        else if (id_flushpipe)
                id_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};        // NOP -> id_insn[16] must be 1
	else if (!id_freeze) begin
		id_insn <=  if_insn;
`ifdef OR1200_VERBOSE
// synopsys translate_off
		$display(""%t: id_insn <= %h"", $time, if_insn);
// synopsys translate_on
`endif
	end
end

//
// Instruction latch in ex_insn
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};	// NOP -> ex_insn[16] must be 1
	else if (!ex_freeze) begin
		ex_insn <=  id_insn;
`ifdef OR1200_VERBOSE
// synopsys translate_off
		$display(""%t: ex_insn <= %h"", $time, id_insn);
// synopsys translate_on
`endif
	end
end
   
//
// Instruction latch in wb_insn
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		wb_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};
	// wb_insn should not be changed by exceptions due to correct 
	// recording of display_arch_state in the or1200_monitor! 
	// wb_insn changed by exception is not used elsewhere! 
	else if (!wb_freeze) begin
		wb_insn <=  ex_insn;
	end
end

//
// Decode of sel_imm
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		sel_imm <=  1'b0;
	else if (!id_freeze) begin
	  case (if_insn[31:26])		// synopsys parallel_case

	    // j.jalr
	    `OR1200_OR32_JALR:
	      sel_imm <=  1'b0;
	    
	    // l.jr
	    `OR1200_OR32_JR:
	      sel_imm <=  1'b0;
	    
	    // l.rfe
	    `OR1200_OR32_RFE:
	      sel_imm <=  1'b0;
	    
	    // l.mfspr
	    `OR1200_OR32_MFSPR:
	      sel_imm <=  1'b0;
	    
	    // l.mtspr
	    `OR1200_OR32_MTSPR:
	      sel_imm <=  1'b0;
	    
	    // l.sys, l.brk and all three sync insns
	    `OR1200_OR32_XSYNC:
	      sel_imm <=  1'b0;
	    
	    // l.mac/l.msb
`ifdef OR1200_MAC_IMPLEMENTED
	    `OR1200_OR32_MACMSB:
	      sel_imm <=  1'b0;
`endif

	    // l.sw
	    `OR1200_OR32_SW:
	      sel_imm <=  1'b0;
	    
	    // l.sb
	    `OR1200_OR32_SB:
	      sel_imm <=  1'b0;
	    
	    // l.sh
	    `OR1200_OR32_SH:
	      sel_imm <=  1'b0;
	    
	    // ALU instructions except the one with immediate
	    `OR1200_OR32_ALU:
	      sel_imm <=  1'b0;
	    
	    // SFXX instructions
	    `OR1200_OR32_SFXX:
	      sel_imm <=  1'b0;

`ifdef OR1200_IMPL_ALU_CUST5
	    // l.cust5 instructions
	    `OR1200_OR32_CUST5:
	      sel_imm <=  1'b0;
`endif
`ifdef OR1200_FPU_IMPLEMENTED
	    // FPU instructions
	    `OR1200_OR32_FLOAT:
	      sel_imm <=  1'b0;
`endif
	    // l.nop
	    `OR1200_OR32_NOP:
	      sel_imm <=  1'b0;

	    // All instructions with immediates
	    default: begin
	      sel_imm <=  1'b1;
	    end
	    
	  endcase
	  
	end
end

//
// Decode of except_illegal
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		except_illegal <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		except_illegal <=  1'b0;
	else if (!ex_freeze) begin
		case (id_insn[31:26])		// synopsys parallel_case

		`OR1200_OR32_J,
		`OR1200_OR32_JAL,
		`OR1200_OR32_JALR,
		`OR1200_OR32_JR,
		`OR1200_OR32_BNF,
		`OR1200_OR32_BF,
		`OR1200_OR32_RFE,
		`OR1200_OR32_MOVHI,
		`OR1200_OR32_MFSPR,
		`OR1200_OR32_XSYNC,
`ifdef OR1200_MAC_IMPLEMENTED
		`OR1200_OR32_MACI,
`endif
		`OR1200_OR32_LWZ,
		`OR1200_OR32_LWS,
		`OR1200_OR32_LBZ,
		`OR1200_OR32_LBS,
		`OR1200_OR32_LHZ,
		`OR1200_OR32_LHS,
		`OR1200_OR32_ADDI,
		`OR1200_OR32_ADDIC,
		`OR1200_OR32_ANDI,
		`OR1200_OR32_ORI,
		`OR1200_OR32_XORI,
`ifdef OR1200_MULT_IMPLEMENTED
		`OR1200_OR32_MULI,
`endif
`ifdef OR1200_IMPL_ALU_ROTATE		  
		`OR1200_OR32_SH_ROTI,
`endif
		`OR1200_OR32_SFXXI,
		`OR1200_OR32_MTSPR,
`ifdef OR1200_MAC_IMPLEMENTED
		`OR1200_OR32_MACMSB,
`endif
		`OR1200_OR32_SW,
		`OR1200_OR32_SB,
		`OR1200_OR32_SH,
		`OR1200_OR32_SFXX,
`ifdef OR1200_IMPL_ALU_CUST5
		`OR1200_OR32_CUST5,
`endif
	`OR1200_OR32_NOP:
		except_illegal <=  1'b0;
`ifdef OR1200_FPU_IMPLEMENTED
	    `OR1200_OR32_FLOAT:
                // Check it's not a double precision instruction
                except_illegal <=  id_insn[`OR1200_FPUOP_DOUBLE_BIT];
`endif	      

	`OR1200_OR32_ALU:
		except_illegal <=  1'b0 

`ifdef OR1200_MULT_IMPLEMENTED
`ifdef OR1200_DIV_IMPLEMENTED
`else 
		| (id_insn[4:0] == `OR1200_ALUOP_DIV)
		| (id_insn[4:0] == `OR1200_ALUOP_DIVU)
`endif
`else
		| (id_insn[4:0] == `OR1200_ALUOP_DIV)
		| (id_insn[4:0] == `OR1200_ALUOP_DIVU)
		| (id_insn[4:0] == `OR1200_ALUOP_MUL)
`endif

`ifdef OR1200_IMPL_ADDC
`else
		| (id_insn[4:0] == `OR1200_ALUOP_ADDC)
`endif

`ifdef OR1200_IMPL_ALU_FFL1
`else
		| (id_insn[4:0] == `OR1200_ALUOP_FFL1)
`endif

`ifdef OR1200_IMPL_ALU_ROTATE
`else
		| ((id_insn[4:0] == `OR1200_ALUOP_SHROT) &
		   (id_insn[9:6] == `OR1200_SHROTOP_ROR))
`endif

`ifdef OR1200_IMPL_SUB
`else
		| (id_insn[4:0] == `OR1200_ALUOP_SUB)
`endif
`ifdef OR1200_IMPL_ALU_EXT
`else
		| (id_insn[4:0] == `OR1200_ALUOP_EXTHB)
		| (id_insn[4:0] == `OR1200_ALUOP_EXTW)
`endif
		;

		// Illegal and OR1200 unsupported instructions
	default:
		except_illegal <=  1'b1;

	endcase
	end // if (!ex_freeze)
end
   

//
// Decode of alu_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		alu_op <=  `OR1200_ALUOP_NOP;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		alu_op <=  `OR1200_ALUOP_NOP;
	else if (!ex_freeze) begin
	  case (id_insn[31:26])		// synopsys parallel_case
	    
	    // l.movhi
	    `OR1200_OR32_MOVHI:
	      alu_op <=  `OR1200_ALUOP_MOVHI;
	    
	    // l.addi
	    `OR1200_OR32_ADDI:
	      alu_op <=  `OR1200_ALUOP_ADD;
	    
	    // l.addic
	    `OR1200_OR32_ADDIC:
	      alu_op <=  `OR1200_ALUOP_ADDC;
	    
	    // l.andi
	    `OR1200_OR32_ANDI:
	      alu_op <=  `OR1200_ALUOP_AND;
	    
	    // l.ori
	    `OR1200_OR32_ORI:
	      alu_op <=  `OR1200_ALUOP_OR;
	    
	    // l.xori
	    `OR1200_OR32_XORI:
	      alu_op <=  `OR1200_ALUOP_XOR;
	    
	    // l.muli
`ifdef OR1200_MULT_IMPLEMENTED
	    `OR1200_OR32_MULI:
	      alu_op <=  `OR1200_ALUOP_MUL;
`endif
`ifdef OR1200_IMPL_ALU_ROTATE	    
	    // Shift and rotate insns with immediate
	    `OR1200_OR32_SH_ROTI:
	      alu_op <=  `OR1200_ALUOP_SHROT;
`endif  
	    // SFXX insns with immediate
	    `OR1200_OR32_SFXXI:
	      alu_op <=  `OR1200_ALUOP_COMP;
	    
	    // ALU instructions except the one with immediate
	    `OR1200_OR32_ALU:
	      alu_op <=  {1'b0,id_insn[3:0]};
	    
	    // SFXX instructions
	    `OR1200_OR32_SFXX:
	      alu_op <=  `OR1200_ALUOP_COMP;
`ifdef OR1200_IMPL_ALU_CUST5	    
	    // l.cust5
	    `OR1200_OR32_CUST5:
	      alu_op <=  `OR1200_ALUOP_CUST5;
`endif	    
	    // Default
	    default: begin
	      alu_op <=  `OR1200_ALUOP_NOP;
	    end
	      
	  endcase
	  
	end
end


//
// Decode of second ALU operation field [9:6]
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		alu_op2 <=  0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
	        alu_op2 <= 0;
   	else if (!ex_freeze) begin
		alu_op2 <=  id_insn[`OR1200_ALUOP2_POS];
	end
end

//
// Decode of spr_read, spr_write
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		spr_read <=  1'b0;
		spr_write <=  1'b0;
	end
	else if (!ex_freeze & id_freeze | ex_flushpipe) begin
		spr_read <=  1'b0;
		spr_write <=  1'b0;
	end
	else if (!ex_freeze) begin
		case (id_insn[31:26])     // synopsys parallel_case

		// l.mfspr
		`OR1200_OR32_MFSPR: begin
			spr_read <=  1'b1;
			spr_write <=  1'b0;
		end

		// l.mtspr
		`OR1200_OR32_MTSPR: begin
			spr_read <=  1'b0;
			spr_write <=  1'b1;
		end

		// Default
		default: begin
			spr_read <=  1'b0;
			spr_write <=  1'b0;
		end

		endcase
	end
end

//
// Decode of mac_op
//
`ifdef OR1200_MAC_IMPLEMENTED
always @(id_insn) begin
	case (id_insn[31:26])		// synopsys parallel_case

	// l.maci
	`OR1200_OR32_MACI:
		id_mac_op =  `OR1200_MACOP_MAC;

	// l.mac, l.msb
	`OR1200_OR32_MACMSB:
		id_mac_op =  id_insn[2:0];

	// Illegal and OR1200 unsupported instructions
	default:
		id_mac_op =  `OR1200_MACOP_NOP;

	endcase
end

always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_mac_op <=  `OR1200_MACOP_NOP;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_mac_op <=  `OR1200_MACOP_NOP;
	else if (!ex_freeze)
		ex_mac_op <=  id_mac_op;
end

assign mac_op = abort_mvspr ? `OR1200_MACOP_NOP : ex_mac_op;
`else
assign id_mac_op = `OR1200_MACOP_NOP;
assign mac_op = `OR1200_MACOP_NOP;
`endif


//
// Decode of rfwb_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		rfwb_op <=  `OR1200_RFWBOP_NOP;
	else  if (!ex_freeze & id_freeze | ex_flushpipe)
		rfwb_op <=  `OR1200_RFWBOP_NOP;
	else  if (!ex_freeze) begin
		case (id_insn[31:26])		// synopsys parallel_case

		// j.jal
		`OR1200_OR32_JAL:
			rfwb_op <=  {`OR1200_RFWBOP_LR, 1'b1};
		  
		// j.jalr
		`OR1200_OR32_JALR:
			rfwb_op <=  {`OR1200_RFWBOP_LR, 1'b1};
		  
		// l.movhi
		`OR1200_OR32_MOVHI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.mfspr
		`OR1200_OR32_MFSPR:
			rfwb_op <=  {`OR1200_RFWBOP_SPRS, 1'b1};
		  
		// l.lwz
		`OR1200_OR32_LWZ:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};

		// l.lws
		`OR1200_OR32_LWS:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};

		// l.lbz
		`OR1200_OR32_LBZ:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.lbs
		`OR1200_OR32_LBS:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.lhz
		`OR1200_OR32_LHZ:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.lhs
		`OR1200_OR32_LHS:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.addi
		`OR1200_OR32_ADDI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.addic
		`OR1200_OR32_ADDIC:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.andi
		`OR1200_OR32_ANDI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.ori
		`OR1200_OR32_ORI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.xori
		`OR1200_OR32_XORI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.muli
`ifdef OR1200_MULT_IMPLEMENTED
		`OR1200_OR32_MULI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
`endif
		  
		// Shift and rotate insns with immediate
`ifdef OR1200_IMPL_ALU_ROTATE
		`OR1200_OR32_SH_ROTI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
`endif
		// ALU instructions except the one with immediate
		`OR1200_OR32_ALU:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};

`ifdef OR1200_ALU_IMPL_CUST5
		// l.cust5 instructions
		`OR1200_OR32_CUST5:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
`endif
`ifdef OR1200_FPU_IMPLEMENTED
		  // FPU instructions, lf.XXX.s, except sfxx
		  `OR1200_OR32_FLOAT:
		    rfwb_op <=  {`OR1200_RFWBOP_FPU,!id_insn[3]};
`endif
		// Instructions w/o register-file write-back
		default: 
			rfwb_op <=  `OR1200_RFWBOP_NOP;


		endcase
	end
end

//
// Decode of id_branch_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		id_branch_op <=  `OR1200_BRANCHOP_NOP;
	else if (id_flushpipe)
		id_branch_op <=  `OR1200_BRANCHOP_NOP;
	else if (!id_freeze) begin
		case (if_insn[31:26])		// synopsys parallel_case

		// l.j
		`OR1200_OR32_J:
			id_branch_op <=  `OR1200_BRANCHOP_J;
		  
		// j.jal
		`OR1200_OR32_JAL:
			id_branch_op <=  `OR1200_BRANCHOP_J;
		  
		// j.jalr
		`OR1200_OR32_JALR:
			id_branch_op <=  `OR1200_BRANCHOP_JR;
		  
		// l.jr
		`OR1200_OR32_JR:
			id_branch_op <=  `OR1200_BRANCHOP_JR;
		  
		// l.bnf
		`OR1200_OR32_BNF:
			id_branch_op <=  `OR1200_BRANCHOP_BNF;
		  
		// l.bf
		`OR1200_OR32_BF:
			id_branch_op <=  `OR1200_BRANCHOP_BF;
		  
		// l.rfe
		`OR1200_OR32_RFE:
			id_branch_op <=  `OR1200_BRANCHOP_RFE;
		  
		// Non branch instructions
		default:
			id_branch_op <=  `OR1200_BRANCHOP_NOP;

		endcase
	end
end

//
// Generation of ex_branch_op
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		ex_branch_op <=  `OR1200_BRANCHOP_NOP;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_branch_op <=  `OR1200_BRANCHOP_NOP;		
	else if (!ex_freeze)
		ex_branch_op <=  id_branch_op;

//
// Decode of id_lsu_op
//
always @(id_insn) begin
	case (id_insn[31:26])		// synopsys parallel_case

	// l.lwz
	`OR1200_OR32_LWZ:
		id_lsu_op =  `OR1200_LSUOP_LWZ;

	// l.lws
	`OR1200_OR32_LWS:
		id_lsu_op =  `OR1200_LSUOP_LWS;

	// l.lbz
	`OR1200_OR32_LBZ:
		id_lsu_op =  `OR1200_LSUOP_LBZ;

	// l.lbs
	`OR1200_OR32_LBS:
		id_lsu_op =  `OR1200_LSUOP_LBS;

	// l.lhz
	`OR1200_OR32_LHZ:
		id_lsu_op =  `OR1200_LSUOP_LHZ;

	// l.lhs
	`OR1200_OR32_LHS:
		id_lsu_op =  `OR1200_LSUOP_LHS;

	// l.sw
	`OR1200_OR32_SW:
		id_lsu_op =  `OR1200_LSUOP_SW;

	// l.sb
	`OR1200_OR32_SB:
		id_lsu_op =  `OR1200_LSUOP_SB;

	// l.sh
	`OR1200_OR32_SH:
		id_lsu_op =  `OR1200_LSUOP_SH;

	// Non load/store instructions
	default:
		id_lsu_op =  `OR1200_LSUOP_NOP;

	endcase
end

//
// Decode of comp_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		comp_op <=  4'd0;
	end else if (!ex_freeze & id_freeze | ex_flushpipe)
		comp_op <=  4'd0;
	else if (!ex_freeze)
		comp_op <=  id_insn[24:21];
end

`ifdef OR1200_FPU_IMPLEMENTED
//
// Decode of FPU ops
//
   assign fpu_op = {(id_insn[31:26] == `OR1200_OR32_FLOAT), 
		    id_insn[`OR1200_FPUOP_WIDTH-2:0]};
`else
   assign fpu_op = {`OR1200_FPUOP_WIDTH{1'b0}};
`endif

   
//
// Decode of l.sys
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		sig_syscall <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		sig_syscall <=  1'b0;
	else if (!ex_freeze) begin
`ifdef OR1200_VERBOSE
// synopsys translate_off
		if (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b000})
			$display(""Generating sig_syscall"");
// synopsys translate_on
`endif
		sig_syscall <=  (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b000});
	end
end

//
// Decode of l.trap
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		sig_trap <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		sig_trap <=  1'b0;
	else if (!ex_freeze) begin
`ifdef OR1200_VERBOSE
// synopsys translate_off
		if (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b010})
			$display(""Generating sig_trap"");
// synopsys translate_on
`endif
		sig_trap <=  (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b010})
			| du_hwbkpt;
	end
end

// Decode destination register address for data cache to check if store ops
// are being done from the stack register (r1) or frame pointer register (r2)
`ifdef OR1200_DC_NOSTACKWRITETHROUGH   
always @(posedge clk or `OR1200_RST_EVENT rst) begin
   if (rst == `OR1200_RST_VALUE)
     dc_no_writethrough <= 0;
   else if (!ex_freeze)
     dc_no_writethrough <= (id_insn[20:16] == 5'd1) | (id_insn[20:16] == 5'd2);
end
`else
   
   assign dc_no_writethrough = 0;
  
`endif      

   
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!ex_freeze & ex_delayslot_dsi & !ex_delayslot_nop) |-> ##1 (ex_delayslot_nop == 0 && ex_delayslot_dsi == 0)"",
    ""Signals"": [
      ""ex_freeze"",
      ""ex_delayslot_dsi"",
      ""ex_delayslot_nop""
    ],
    ""Signal Explanations"": {
      ""ex_freeze"": ""freeze signal for the EX stage"",
      ""ex_delayslot_dsi"": ""signal indicating that a delay slot instruction is in the EX stage"",
      ""ex_delayslot_nop"": ""signal indicating that a filler nop instruction is in the EX stage""
    },
    ""Logical Operators"": [
      ""!"",
      ""&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle"",
      ""=="": ""equal"",
      ""&&"": ""logical AND""
    },
    ""Assertion Explaination"": ""when the freeze signal for the EX stage is reset (0) and the signal indicating that a delay slot instruction is in the EX stage is set (1) and the signal indicating that a filler nop instruction is in the EX stage is reset (0), then the signal indicating that a filler nop instruction is in the EX stage equals 0 and the signal indicating that a delay slot instruction is in the EX stage equals 0 from the next clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!ex_freeze & id_freeze | ex_flushpipe) |-> ##1 (ex_macrc_op == 0)"",
    ""Signals"": [
      ""ex_freeze"",
      ""id_freeze"",
      ""ex_flushpipe"",
      ""ex_macrc_op""
    ],
    ""Signal Explanations"": {
      ""ex_freeze"": ""freeze signal for the EX stage"",
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""ex_flushpipe"": ""pipeline flush signal for the EX stage"",
      ""ex_macrc_op"": ""signal indicating a MAC read operation in the EX stage""
    },
    ""Logical Operators"": [
      ""!"",
      ""&"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when the freeze signal for the EX stage is reset (0) and either the freeze signal for the ID stage is set (1) or the pipeline flush signal for the EX stage is set (1), then the signal indicating a MAC read operation in the EX stage equals 0 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(id_flushpipe) |-> ##1 (id_insn == {`OR1200_OR32_NOP, 26'h041_0000})"",
    ""Signals"": [
      ""id_flushpipe"",
      ""id_insn""
    ],
    ""Signal Explanations"": {
      ""id_flushpipe"": ""pipeline flush signal for the ID stage"",
      ""id_insn"": ""instruction signal in the ID stage""
    },
    ""Logical Operators"": [
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when the pipeline flush signal for the ID stage is set (1), then the instruction signal in the ID stage equals the constant NOP value from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!ex_freeze & id_freeze | ex_flushpipe) |-> ##1 (ex_insn == {`OR1200_OR32_NOP, 26'h041_0000})"",
    ""Signals"": [
      ""ex_freeze"",
      ""id_freeze"",
      ""ex_flushpipe"",
      ""ex_insn""
    ],
    ""Signal Explanations"": {
      ""ex_freeze"": ""freeze signal for the EX stage"",
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""ex_flushpipe"": ""pipeline flush signal for the EX stage"",
      ""ex_insn"": ""instruction signal in the EX stage""
    },
    ""Logical Operators"": [
      ""!"",
      ""&"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when the freeze signal for the EX stage is reset (0) and either the freeze signal for the ID stage is set (1) or the pipeline flush signal for the EX stage is set (1), then the instruction signal in the EX stage equals the constant NOP value from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_JALR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the JALR opcode `OR1200_OR32_JALR, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_JR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the JR opcode `OR1200_OR32_JR, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_RFE) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the RFE opcode `OR1200_OR32_RFE, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_MFSPR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the MFSPR opcode `OR1200_OR32_MFSPR, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_MTSPR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""if the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the MTSPR opcode `OR1200_OR32_MTSPR, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_XSYNC) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the XSYNC opcode `OR1200_OR32_XSYNC, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_SW) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the SW opcode `OR1200_OR32_S, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_SB) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the SB opcode `OR1200_OR32_SB, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_ALU) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the ALU opcode `OR1200_OR32_ALU, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_SFXX) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""freeze signal for the ID stage"",
      ""if_insn"": ""instruction signal in the IF stage (opcode field used)"",
      ""sel_imm"": ""signal controlling immediate value selection""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##1"": ""the condition on the right must hold after one clock cycle""
    },
    ""Assertion Explaination"": ""when the freeze signal for the ID stage is reset (0) and the opcode field of the instruction in the IF stage equals the SFXX opcode `OR1200_OR32_SFXX, then the signal controlling immediate value selection equals 0 from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((!ex_freeze && ex_delayslot_dsi && !ex_delayslot_nop) |=> (!ex_delayslot_nop && !ex_delayslot_dsi));"",
""Assertion 2"": ""assert property ((!ex_freeze && (id_freeze || ex_flushpipe)) |=> !ex_macrc_op);"",
""Assertion 3"": ""assert property (id_flushpipe |=> (id_insn == {`OR1200_OR32_NOP, 26'h041_0000}));"",
""Assertion 4"": ""assert property ((ex_freeze == 0 && (id_freeze == 1 || ex_flushpipe == 1)) |=> (ex_insn == {`OR1200_OR32_NOP, 26'h041_0000}));"",
""Assertion 5"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_JALR)) |=> (sel_imm == 0));"",
""Assertion 6"": ""assert property (!id_freeze && (if_insn[31:26] == `OR1200_OR32_JR) |=> !sel_imm);"",
""Assertion 7"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_RFE)) |=> !sel_imm);"",
""Assertion 8"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_MFSPR)) |=> (sel_imm == 1'b0));"",
""Assertion 9"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_MTSPR)) |=> !sel_imm);"",
""Assertion 10"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_XSYNC)) |=> !sel_imm);"",
""Assertion 11"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_SW)) |=> (sel_imm == 0));"",
""Assertion 12"": ""assert property (!id_freeze && (if_insn[31:26] == `OR1200_OR32_SB) |=> !sel_imm);"",
""Assertion 13"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_ALU)) |=> !sel_imm);"",
""Assertion 14"": ""assert property ((!id_freeze && (if_insn[31:26] == `OR1200_OR32_SFXX)) |=> !sel_imm);""
}"
