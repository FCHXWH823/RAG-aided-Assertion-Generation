Master Module,Code,golden_assertions,llm_assertions
arbiter,"//EE382M-Verification of Digital Systems
//Lab 4 - Formal Property Verification
//
//
//Module - PNSeqGen
//Pseudo-random pattern generator

module PNSeqGen(
  input        clk,
  input        rst_n,
  output [1:0] rand_out
  );

reg s1, s2, s3;
wire s0;

assign s0 = s1 ^ s3;

always @ (posedge clk or negedge rst_n) begin
  if(!rst_n) begin
   s1 <= 1;
   s2 <= 0;
   s3 <= 0;
  end else begin   
   s1 <= s0;
   s2 <= s1;
   s3 <= s2;
  end
end

assign rand_out = {s3,s2};

endmodule

module arbiter(
  clk,
  rst_n,
  req,
  arb_type,
  gnt
  );

// Input and Output ports
input        clk;
input        rst_n;
input  [3:0] req;
input  [2:0] arb_type;

output [3:0] gnt;

// Internal variables
wire [3:0] req;

reg  [3:0] r_gnt_p0; // P0 priority scheme output
reg  [3:0] r_gnt_p1; // P1 priority scheme output
reg  [3:0] r_gnt_p2; // P2 priority scheme output
reg  [3:0] r_gnt_p3; // P3 priority scheme output
reg  [3:0] r_gnt_rr; // Prr: Round robin arbitration scheme output
reg  [3:0] r_gnt_px; // Prand: Random arbitration scheme output
reg  [3:0] r_gnt;

wire [1:0] rand_out;
wire [1:0] r_gnt_rr_encoded;

assign gnt   = r_gnt;

// P0 Fixed Priority req[0]
always @(*) begin
  if(req[0])
    r_gnt_p0 = 4'b0001;
  else if(req[1])
    r_gnt_p0 = 4'b0010;
  else if(req[2])
    r_gnt_p0 = 4'b0100;
  else if(req[3])
    r_gnt_p0 = 4'b1000; // Saqib changed this from r_gnt_p0 = 4'b0000;
  else
    r_gnt_p0 = 4'b0000;
end

// P1 Fixed Priority req[1]
always @(*) begin
  if(req[1])
    r_gnt_p1 = 4'b0010;
  else if(req[0])
    r_gnt_p1 = 4'b0001;
  else if(req[2])
    r_gnt_p1 = 4'b0100;
  else if(req[3])
    r_gnt_p1 = 4'b1000;
  else
    r_gnt_p1 = 4'b0000;
end

// P2 Fixed Priority req[2]
always @(*) begin
  if(req[2])
    r_gnt_p2 = 4'b0100;
  else if(req[0])
    r_gnt_p2 = 4'b0001;
  else if(req[1])
    r_gnt_p2 = 4'b0010;
  else if(req[3])
    r_gnt_p2 = 4'b1000;
  else
    r_gnt_p2 = 4'b0000;
end

// P3 Fixed Priority req[3]
always @(*) begin
  if(req[3])
    r_gnt_p3 = 4'b1000;
  else if(req[0])
    r_gnt_p3 = 4'b0001;
  else if(req[1])
    r_gnt_p3 = 4'b0010;
  else if(req[2])
    r_gnt_p3 = 4'b0100;
  else
    r_gnt_p3 = 4'b0000;
end

// Prr: Round robin arbiter
always @ (*) begin
  r_gnt_rr[0] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & req[0]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & req[0]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & req[0]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & ~req[1] & req[0]) ;

  r_gnt_rr[1] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & req[1]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[0] & req[1]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & ~req[0] & req[1]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & req[1]) ;
  
  r_gnt_rr[2] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & ~req[1] & req[2]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[0] & ~req[1] & req[2]) |  // Saqib changed req[1] to ~req[1]
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & req[2]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[1] & req[2]) ;
 
  r_gnt_rr[3] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & ~req[1] & ~req[2] & req[3]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & req[3]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[2] & req[3]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[1] & ~req[2] & req[3]) ;
end

// encode the 4b r_gnt_rrs to 2b
assign r_gnt_rr_encoded = {r_gnt[3] | r_gnt[2], r_gnt[3] | r_gnt[1]};

// Prand: Random arbitration
PNSeqGen u_PNSeqGen ( .clk(clk), .rst_n(rst_n), .rand_out(rand_out) );

always @(*) begin
  case(rand_out)

  2'b00: begin
    if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end
  
  2'b01: begin
    if(req[1])
      r_gnt_px = 4'b0010;  // Saqib change 4'b0001 to 4'b0010
    else if(req[0])
      r_gnt_px = 4'b0001;  // Saqib change 4'b0010 to 4'b0001
    else if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end

  2'b10: begin
    if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end

  2'b11: begin
    if(req[3])
      r_gnt_px = 4'b1000;
    else if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[2])
      r_gnt_px = 4'b0100;
    else
      r_gnt_px = 4'b0000;
  end

  endcase
end

// Priority selection
always @(posedge clk or negedge rst_n)
begin
  if(!rst_n)
    r_gnt <= 4'b0000;
  else
    case(arb_type)
      4'b0000: r_gnt <= r_gnt_p0;
      4'b0001: r_gnt <= r_gnt_p1;
      4'b0010: r_gnt <= r_gnt_p2;
      4'b0011: r_gnt <= r_gnt_p3;
      4'b0100: r_gnt <= r_gnt_rr;
      4'b0101: r_gnt <= r_gnt_px;
      default: r_gnt <= 4'b0000;
    endcase
end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd0)) |-> $past(req[0])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the first bit of request input signal must be asserted from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd0)) |-> $past(req[1] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the second bit of request input signal must be asserted and the first bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd0)) |-> $past(req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the third bit of request input signal must be asserted and the first and second bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd0)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the fourth bit of request input signal must be asserted and the first, second, and third bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd1)) |-> $past(req[0] & ~req[1])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[1]"": ""request input signal for request 1""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the first bit of request input signal must be asserted and the second bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd1)) |-> $past(req[1])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the second bit of request input signal must be asserted from the current clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd1)) |-> $past(req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the third bit of request input signal must be asserted and the first and second bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd1)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the fourth bit of request input signal must be asserted and the third, second and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd2)) |-> $past(req[0] & ~req[2])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[2]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[2]"": ""request input signal for request 2""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the first bit of request input signal must be asserted and the third bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd2)) |-> $past(req[1] & ~req[2] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[2]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the second bit of request input signal must be asserted and the third and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd2)) |-> $past(req[2])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the third bit of request input signal must be asserted from the current clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd2)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the fourth bit of request input signal must be asserted and the third, second and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd3)) |-> $past(req[0] & ~req[3])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[3]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[3]"": ""request input signal for request 3""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the first bit of request input signal must be asserted and the fourth bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd3)) |-> $past(req[1] & ~req[3] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[3]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the second bit of request input signal must be asserted and the fourth and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd3)) |-> $past(req[2] & ~req[3] & ~req[0] & ~req[1])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[3]"", ""req[0]"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[1]"": ""request input signal for request 1""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the third bit of request input signal must be asserted and the fourth, second and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd3)) |-> $past(req[3])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the fourth bit of request input signal must be asserted from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (gnt[0] && ($past(arb_type) == 4'b0000) |-> $past(req[0]));"",
""Assertion 2"": ""assert property ((gnt[1]) && ($past(arb_type) == 4'b0000) && ($past(req[1])) && (!req[0]));"",
""Assertion 3"": ""assert property ((gnt[2] && ($past(arb_type) == 0)) |-> ($past(req[2]) && !req[0] && !req[1]));"",
""Assertion 4"": ""assert property (   gnt[3] |-> (     ($past(arb_type) == 4'b0000) &&     ($past(req[3]) == 1'b1) &&     (req[2:0] == 3'b000)   ) );"",
""Assertion 5"": ""assert property ((gnt[0] && ($past(arb_type) == 3'b001)) |-> ($past(req[0]) && !$past(req[1])));"",
""Assertion 6"": ""assert property (gnt[1] |-> ($past(arb_type) == 4'b0001 && $past(req[1])));"",
""Assertion 7"": ""assert property (($past(arb_type) == 4'b0001) |-> ($past(req[2]) && !$past(req[0]) && !$past(req[1]) && gnt[2]));"",
""Assertion 8"": ""assert property (gnt[3] && $past(arb_type) == 4'b0001 |-> ($past(req[3]) && !req[2] && !req[1] && !req[0]));"",
""Assertion 9"": ""assert property (r_gnt[0] && ($past(arb_type) == 4'b0010) |-> ($past(req[0]) && !req[2]));"",
""Assertion 10"": ""assert property (gnt[1] |-> ($past(arb_type) == 3'b010 && $past(req[1]) && !$past(req[2]) && !$past(req[0])));"",
""Assertion 11"": ""assert property (gnt[2] |-> ($past(arb_type) == 3'b010 && $past(req[2])));"",
""Assertion 12"": ""assert property (gnt[3] |-> ($past(arb_type) == 3'b010 && $past(req[3]) && !req[2] && !req[1] && !req[0]));"",
""Assertion 13"": ""assert property ((gnt[0] && ($past(arb_type) == 3)) |-> ($past(req[0]) && !req[3]));"",
""Assertion 14"": ""assert property ((gnt[1] && $past(arb_type == 4'b0011)) |-> ($past(req[1]) && !req[0] && !req[3]));"",
""Assertion 15"": ""assert property (($past(arb_type, 1) == 3) && ($past(req[2], 1) == 1) && (gnt[2] == 1) && (req[3] == 0) && (req[1] == 0) && (req[0] == 0));"",
""Assertion 16"": ""assert property (($past(arb_type) == 3) && gnt[3] |-> $past(req[3]));""
}"
