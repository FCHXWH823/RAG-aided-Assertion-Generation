Master Module,Code,golden_assertions,llm_assertions
Ripple_Carry_Adder,"module full_adder 
(
    input a,
    input b,
    input cin,
    output sum,
    output cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (a & cin) | (b & cin);
endmodule

module Ripple_Carry_Adder #(
	parameter DATA_WIDTH=8
)
(
    input [DATA_WIDTH-1:0] a,
    input [DATA_WIDTH-1:0] b,
    input clk,
    input rst,
    output logic [DATA_WIDTH-0:0] sum,
    output logic [DATA_WIDTH-1:0] cout_int
);

logic [DATA_WIDTH:0] carry;
assign carry[0] = 1'b0;

genvar x;
generate
	for( x = 0; x < DATA_WIDTH; x++ ) begin
		// instanciate adder module
		full_adder m_adder(
			.a( a[x] ),
			.b( b[x] ),
			.cin( carry[x]),
			.sum( sum[x] ),
			.cout( carry[x+1] )
		);
	end
endgenerate
// output
assign sum[DATA_WIDTH] = carry[DATA_WIDTH];
assign cout_int        = carry[DATA_WIDTH-1:0];

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst)"",
    ""logical expression"": ""res == sum"",
    ""Signals"": [""res"", ""sum""],
    ""Signal Explanations"": {
      ""res"": ""the computed result of adding the module inputs (a and b) as an expected binary sum"",
      ""sum"": ""the actual output of the ripple carry adder representing the binary addition result""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the two expressions are equal""
    },
    ""Assertion Explaination"": ""checks whether the expected binary sum is equal to the actual binary addition output, ensuring the adder operation performs correctly""
  }
}","{
""Assertion 1"": ""assert property (a + b == sum);""
}"
or1200_operandmuxes,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's register file read operands mux                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Mux for two register file read operands.                    ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_operandmuxes.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_operandmuxes(
	// Clock and rst
	clk, rst,

	// Internal i/f
	id_freeze, ex_freeze, rf_dataa, rf_datab, ex_forw, wb_forw,
	simm, sel_a, sel_b, operand_a, operand_b, muxed_a, muxed_b
);

parameter width = `OR1200_OPERAND_WIDTH;

//
// I/O
//
input				clk;
input				rst;
input				id_freeze;
input				ex_freeze;
input	[width-1:0]		rf_dataa;
input	[width-1:0]		rf_datab;
input	[width-1:0]		ex_forw;
input	[width-1:0]		wb_forw;
input	[width-1:0]		simm;
input	[`OR1200_SEL_WIDTH-1:0]	sel_a;
input	[`OR1200_SEL_WIDTH-1:0]	sel_b;
output	[width-1:0]		operand_a;
output	[width-1:0]		operand_b;
output	[width-1:0]		muxed_a;
output	[width-1:0]		muxed_b;

//
// Internal wires and regs
//
reg	[width-1:0]		operand_a;
reg	[width-1:0]		operand_b;
reg	[width-1:0]		muxed_a;
reg	[width-1:0]		muxed_b;
reg				saved_a;
reg				saved_b;

//
// Operand A register
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		operand_a <=  32'd0;
		saved_a <=  1'b0;
	end else if (!ex_freeze && id_freeze && !saved_a) begin
		operand_a <=  muxed_a;
		saved_a <=  1'b1;
	end else if (!ex_freeze && !saved_a) begin
		operand_a <=  muxed_a;
	end else if (!ex_freeze && !id_freeze)
		saved_a <=  1'b0;
end

//
// Operand B register
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		operand_b <=  32'd0;
		saved_b <=  1'b0;
	end else if (!ex_freeze && id_freeze && !saved_b) begin
		operand_b <=  muxed_b;
		saved_b <=  1'b1;
	end else if (!ex_freeze && !saved_b) begin
		operand_b <=  muxed_b;
	end else if (!ex_freeze && !id_freeze)
		saved_b <=  1'b0;
end

//
// Forwarding logic for operand A register
//
always @(ex_forw or wb_forw or rf_dataa or sel_a) begin
`ifdef OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES
	casez (sel_a)	// synopsys parallel_case infer_mux
`else
	casez (sel_a)	// synopsys parallel_case
`endif
		`OR1200_SEL_EX_FORW:
			muxed_a = ex_forw;
		`OR1200_SEL_WB_FORW:
			muxed_a = wb_forw;
		default:
			muxed_a = rf_dataa;
	endcase
end

//
// Forwarding logic for operand B register
//
always @(simm or ex_forw or wb_forw or rf_datab or sel_b) begin
`ifdef OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES
	casez (sel_b)	// synopsys parallel_case infer_mux
`else
	casez (sel_b)	// synopsys parallel_case
`endif
		`OR1200_SEL_IMM:
			muxed_b = simm;
		`OR1200_SEL_EX_FORW:
			muxed_b = ex_forw;
		`OR1200_SEL_WB_FORW:
			muxed_b = wb_forw;
		default:
			muxed_b = rf_datab;
	endcase
end


endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_a == 2'd2 && $stable(ex_forw) && $stable(sel_a)) |-> muxed_a == ex_forw"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_a"", ""ex_forw"", ""muxed_a""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_a"": ""the selection signal that determines which source will drive operand A"",
  ""ex_forw"": ""the data forwarded from the execution stage for operand A"",
  ""muxed_a"": ""the output of the multiplexer logic for operand A""
},
""Logical Operators"": [""$rose"", ""&&"", ""##1"", ""$stable"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the condition that neither the execution stage nor the instruction decode stage is frozen, then one clock cycle later if both stages remain unfrozen, the control selection indicates that the execution forwarding path for the first operand is chosen and both the execution forwarding data and its selection remain constant, it follows that the multiplexer output for the first operand must equal the execution forwarding data""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_a == 2'd3 && $stable(wb_forw) && $stable(sel_a)) |-> muxed_a == wb_forw"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_a"", ""wb_forw"", ""muxed_a""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_a"": ""the selection signal that determines which source will drive operand A"",
  ""wb_forw"": ""the data forwarded from the write-back stage for operand A"",
  ""muxed_a"": ""the output of the multiplexer logic for operand A""
},
""Logical Operators"": [""$rose"", ""&&"", ""##1"", ""$stable"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the non-frozen condition for both the execution and instruction decode stages, then one clock cycle later if these stages are still unfrozen, the control selection indicates that the write-back forwarding path for the first operand is selected and both the write-back forwarding data and its selection remain constant, it follows that the multiplexer output for the first operand must equal the write-back forwarding data""
},
""Assertion 3"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && !(sel_a == 2'd2 || sel_a == 2'd3) && $stable(rf_dataa) && $stable(sel_a) && !$isunknown(operand_a)) |-> muxed_a == rf_dataa"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_a"", ""rf_dataa"", ""operand_a"", ""muxed_a""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_a"": ""the selection signal that determines which source will drive operand A"",
  ""rf_dataa"": ""the data read from the register file for operand A"",
  ""operand_a"": ""the internal register holding the value for operand A"",
  ""muxed_a"": ""the output of the multiplexer logic for operand A""
},
""Logical Operators"": [""$rose"", ""&&"", ""||"", ""!"", ""##1"", ""$stable"", ""!$isunknown"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""||"": ""logical OR, meaning at least one connected condition must be true"",
  ""!"": ""logical NOT, inverting the truth value of the condition"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""!$isunknown"": ""checks that the evaluated value is known (not in an unknown state)"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the condition that both the execution and instruction decode stages are not frozen, then one clock cycle later if these stages remain unfrozen, the control selection does not indicate use of either the execution forwarding or the write-back forwarding paths, and if the data read from the register file for the first operand and its selection remain constant while the stored operand is known, it follows that the multiplexer output for the first operand must equal the register file read data""
},
""Assertion 4"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_b == 2'd1 && $stable(simm) && $stable(sel_b)) |-> muxed_b == simm"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""simm"", ""muxed_b""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_b"": ""the selection signal that determines which source will drive operand B"",
  ""simm"": ""the immediate value operand provided as an input"",
  ""muxed_b"": ""the output of the multiplexer logic for operand B""
},
""Logical Operators"": [""$rose"", ""&&"", ""##1"", ""$stable"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the condition that both the execution and instruction decode stages are not frozen, then one clock cycle later if these stages remain unfrozen, the control selection indicates that the immediate value should be used for the second operand and both the immediate value and its selection remain constant, it follows that the multiplexer output for the second operand must equal the immediate value""
},
""Assertion 5"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_b == 2'd2 && $stable(ex_forw) && $stable(sel_b)) |-> muxed_b == ex_forw"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""ex_forw"", ""muxed_b""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_b"": ""the selection signal that determines which source will drive operand B"",
  ""ex_forw"": ""the data forwarded from the execution stage for operand B"",
  ""muxed_b"": ""the output of the multiplexer logic for operand B""
},
""Logical Operators"": [""$rose"", ""&&"", ""##1"", ""$stable"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the condition that both the execution and instruction decode stages are not frozen, then one clock cycle later if these stages remain unfrozen, the control selection indicates that the execution forwarding path for the second operand is chosen and both the execution forwarding data and its selection remain constant, it follows that the multiplexer output for the second operand must equal the execution forwarding data""
},
""Assertion 6"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_b == 2'd3 && $stable(wb_forw) && $stable(sel_b)) |-> muxed_b == wb_forw"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""wb_forw"", ""muxed_b""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_b"": ""the selection signal that determines which source will drive operand B"",
  ""wb_forw"": ""the data forwarded from the write-back stage for operand B"",
  ""muxed_b"": ""the output of the multiplexer logic for operand B""
},
""Logical Operators"": [""$rose"", ""&&"", ""##1"", ""$stable"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the condition that both the execution and instruction decode stages are not frozen, then one clock cycle later if these stages remain unfrozen, the control selection indicates that the write-back forwarding path for the second operand is chosen and both the write-back forwarding data and its selection remain constant, it follows that the multiplexer output for the second operand must equal the write-back forwarding data""
},
""Assertion 7"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && !(sel_b == 2'd1 || sel_b == 2'd2 || sel_b == 2'd3) && $stable(rf_datab) && $stable(sel_b)) |-> muxed_b == rf_datab"",
""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""rf_datab"", ""muxed_b""],
""Signal Explanations"": {
  ""ex_freeze"": ""a signal indicating that the execution stage is frozen"",
  ""id_freeze"": ""a signal indicating that the instruction decode stage is frozen"",
  ""sel_b"": ""the selection signal that determines which source will drive operand B"",
  ""rf_datab"": ""the data read from the register file for operand B"",
  ""muxed_b"": ""the output of the multiplexer logic for operand B""
},
""Logical Operators"": [""$rose"", ""&&"", ""||"", ""!"", ""##1"", ""$stable"", ""=="", ""|->""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge transition (from 0 to 1) of the condition"",
  ""&&"": ""logical AND, meaning all connected conditions must be true"",
  ""||"": ""logical OR, meaning at least one connected condition must be true"",
  ""!"": ""logical NOT, inverting the truth value of the condition"",
  ""##1"": ""delays the evaluation by one clock cycle"",
  ""$stable"": ""ensures that a value remains constant during the evaluated interval"",
  ""=="": ""checks equality between values"",
  ""|->"": ""implication operator indicating that if the antecedent is true then the consequent must be true""
},
""Assertion Explaination"": ""when a rising edge is detected on the condition that both the execution and instruction decode stages are not frozen, then one clock cycle later if these stages remain unfrozen, and if the control selection for the second operand does not indicate use of the immediate value, execution forwarding, or write-back forwarding while ensuring that the register file data for the second operand and its selection remain constant, it follows that the multiplexer output for the second operand must equal the register file read data""
}
}","{
""Assertion 1"": ""assert property ((!ex_freeze && !id_freeze) |-> ##1 ((!ex_freeze && !id_freeze) && (sel_a == `OR1200_SEL_EX_FORW) && (muxed_a == ex_forw)));"",
""Assertion 2"": ""assert property (id_freeze == 1'b0 && ex_freeze == 1'b0 |-> (id_freeze[1:0] == 2'b00 && ex_freeze == 1'b0 && sel_a == `OR1200_SEL_WB_FORW && muxed_a == wb_forw));"",
""Assertion 3"": ""assert property (id_freeze == 1'b0 && ex_freeze == 1'b0 |-> (id_freeze == 1'b0 && ex_freeze == 1'b0 throughout (muxed_a == rf_dataa)));"",
""Assertion 4"": ""assert property (id_freeze == 0 && ex_freeze == 0 |-> (sel_b == `OR1200_SEL_IMM && muxed_b == simm));"",
""Assertion 5"": ""assert property ((id_freeze == 0 && ex_freeze == 0) |->                   ((id_freeze == 0 && ex_freeze == 0) ->                    (sel_b == `OR1200_SEL_EX_FORW && muxed_b == ex_forw)));"",
""Assertion 6"": ""assert property ((!ex_freeze && !id_freeze) |=> ( ##1 ((!ex_freeze && !id_freeze) implies (sel_b == `OR1200_SEL_WB_FORW && simm == wb_forw) |=> (muxed_b == wb_forw))));"",
""Assertion 7"": ""assert property ( (id_freeze == 0) && (ex_freeze == 0) |->                    (id_freeze == 0) && (ex_freeze == 0) &&                    (sel_b != `OR1200_SEL_IMM) &&                    (sel_b != `OR1200_SEL_EX_FORW) &&                    (sel_b != `OR1200_SEL_WB_FORW) &&                    (rf_datab == $past(rf_datab)) &&                    (sel_b == $past(sel_b)) |->                    (muxed_b == rf_datab) );""
}"
gray,"module gray #(parameter CBITS = 8) (input clk, input rst, output reg [CBITS-1:0] gray_cnt, output reg sig);
  reg [CBITS-1:0] cnt;
  always@(posedge clk, posedge rst) begin
    if (rst) begin
      cnt = 0;
    end
    else begin
      cnt = cnt + 1;
      gray_cnt = (cnt) ^ ((cnt) >> 1);
      if(gray_cnt == 0)
        sig = 1;
      else
        sig = 0;
    end
  end
  // F G (rst = F) -> G F (sig = T)
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""rst || sig == 1"",
    ""Signals"": [
      ""rst"",
      ""sig""
    ],
    ""Signal Explanations"": {
      ""rst"": ""the asynchronous reset input that initializes the counter"",
      ""sig"": ""the indicator that is set when the Gray-coded counter equals zero""
    },
    ""Logical Operators"": [
      ""||"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""||"": ""logical OR operator, meaning at least one of the operands must be true"",
      ""=="": ""equality comparison operator, which checks if the two operands are equal""
    },
    ""Assertion Explaination"": ""the property requires that either the module’s reset control is active or the indicator that reflects a zero Gray counter value is equal to one""
  }
}","{
""Assertion 1"": ""assert property (rst || (sig == 1));""
}"
Flip_Flop_Array,"module Flip_Flop_Array #(
	parameter DATA_W = 8,
	parameter ADDR_W = 3,
	parameter DATA_N = 8 // getting non constant error when using $pow(2,ADDR_W)
)
(
    input clk,
    input resetn,

    input [DATA_W-1:0] din,
    input [ADDR_W-1:0] addr,
    input              wr,
    input              rd,

    output logic [DATA_W-1:0] dout,
    output logic              error
);

// register file
reg   [DATA_W-1:0] data_q[DATA_N-1:0];
reg   [DATA_N-1:0] data_v_q;
logic [DATA_W-1:0] data_rd[DATA_N-1:0];
logic [DATA_N-1:0] data_v_next;
logic [DATA_N-1:0] rd_en;
logic [DATA_N-1:0] wr_en;
logic [DATA_N-1:0] addr_v;
logic rd_v;
always @(posedge clk)
begin
	if ( ~resetn ) begin
		data_v_q <= {DATA_N{1'b0}};
	end else begin
		data_v_q <= data_v_next;
	end
end

genvar x;
generate
	for( x=0; x < DATA_N; x++) begin
		assign addr_v[x] = addr == x;
		assign wr_en[x]  = wr & addr_v[x];	
		assign rd_en[x]  = rd & addr_v[x];

		assign data_v_next[x] = wr_en[x];
		assign data_rd[x] = {DATA_W{rd_en[x]}} & data_q[x];
 
		always @(posedge clk) begin
			if ( wr_en[x] ) begin
				data_q[x] <= din;
			end
		end	
	end
endgenerate
// read valid
assign rd_v  = data_v_q & rd_en;

assign error = ( rd & ~|rd_v) |  wr & rd ;

always_comb begin
	for( int i=0; i < DATA_N; i++ ) begin
		if ( 1 << i == rd_v ) dout = data_rd[i];
	end
	dout = {DATA_W{1'b0}};
end

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""~(rd & wr) | (rd & wr & error)"",
""Signals"": [""rd"", ""wr"", ""error""],
""Signal Explanations"": {
  ""rd"": ""control signal that initiates a read operation from the register file"",
  ""wr"": ""control signal that initiates a write operation to the register file"",
  ""error"": ""indicator that flags an error condition when simultaneous operations occur""
},
""Logical Operators"": [""~"", ""&"", ""|""],
""Logical Operators Explanation"": {
  ""~"": ""logical negation, which inverts the truth value of an expression"",
  ""&"": ""logical and, which produces true only when both operands are true"",
  ""|"": ""logical or, which produces true when at least one operand is true""
},
""Assertion Explaination"": ""Either it is not the case that both the control signal initiating a read operation and the control signal initiating a write operation are active, or if both are active then the indicator that flags an error condition must also be active""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""~(~data_v_q & rd_en) | (~data_v_q & rd_en & (dout == '0))"",
""Signals"": [""data_v_q"", ""rd_en"", ""dout""],
""Signal Explanations"": {
  ""data_v_q"": ""register output that tracks which data entries in the register file have been written"",
  ""rd_en"": ""signal derived from address matching that enables a read operation on a specific data entry"",
  ""dout"": ""data output that delivers the read content from the register file""
},
""Logical Operators"": [""~"", ""&"", ""|"", ""==""],
""Logical Operators Explanation"": {
  ""~"": ""logical negation, which inverts the truth value of an expression"",
  ""&"": ""logical and, which produces true only when all involved conditions are true"",
  ""|"": ""logical or, which produces true when at least one condition is true"",
  ""=="": ""equality comparator, which checks if two expressions have the same value""
},
""Assertion Explaination"": ""Either it is not the case that an invalid data entry is being read, or if a read operation is attempted on a data entry that has not been marked as written then the data output must be equal to zero""
},
""Assertion 3"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""$onehot0(rd_v)"",
""Signals"": [""rd_v""],
""Signal Explanations"": {
  ""rd_v"": ""aggregated indicator that shows which read operations are valid based on the combination of data validity and read enable signals""
},
""Logical Operators"": [""$onehot0""],
""Logical Operators Explanation"": {
  ""$onehot0"": ""a function that checks whether the given signal has at most one active bit, ensuring that only one read operation is valid at any time""
},
""Assertion Explaination"": ""The aggregated indicator that shows valid read operations must have at most a single active bit to ensure that only one valid read occurs at a time""
}
}","{
""Assertion 1"": ""assert property ( ~(wr && rd) || error );"",
""Assertion 2"": ""assert property ((!error) || (rd && ~|data_v_q || (dout == {DATA_W{1'b0}})));"",
""Assertion 3"": ""assert property (rd & (|rd_v) | !rd | !wr);""
}"
PSGBusArb,"`timescale 1ns / 1ps
//=============================================================================
//	(C) 2007,2012  Robert Finch
//  robfinch<remove>@opencores.org
//	All rights reserved.
//
//	PSGBusArb.v
//
// This source file is free software: you can redistribute it and/or modify 
// it under the terms of the GNU Lesser General Public License as published 
// by the Free Software Foundation, either version 3 of the License, or     
// (at your option) any later version.                                      
//                                                                          
// This source file is distributed in the hope that it will be useful,      
// but WITHOUT ANY WARRANTY; without even the implied warranty of           
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
// GNU General Public License for more details.                             
//                                                                          
// You should have received a copy of the GNU General Public License        
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
//
//		Arbitrates access to the system bus among up to eight
//	wave table channels for the PSG. This arbitrator is part
//	of a tree that ends up looking like a single arbitration
//	request to the system.
//
//	Spartan3
//	19 LUTs / 11 slices
//=============================================================================

module PSGBusArb(rst, clk, ce, ack,
	req0, req1, req2, req3, req4, req5, req6, req7,
	sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7, seln);
input rst;		// reset
input clk;		// clock (eg 100MHz)
input ce;		// clock enable (eg 25MHz)
input ack;		// bus transfer completed
input req0;		// requester 0 wants the bus
input req1;		// requester 1 wants the bus
input req2;		// ...
input req3;
input req4;
input req5;
input req6;
input req7;
output sel0;	// requester 0 granted the bus
reg sel0;
output sel1;
reg sel1;
output sel2;
reg sel2;
output sel3;
reg sel3;
output sel4;
reg sel4;
output sel5;
reg sel5;
output sel6;
reg sel6;
output sel7;
reg sel7;
output [2:0] seln;	// who has the bus
reg [2:0] seln;

always @(posedge clk) begin
	if (rst) begin
		sel0 <= 1'b0;
		sel1 <= 1'b0;
		sel2 <= 1'b0;
		sel3 <= 1'b0;
		sel4 <= 1'b0;
		sel5 <= 1'b0;
		sel6 <= 1'b0;
		sel7 <= 1'b0;
		seln <= 3'd0;
	end
	else begin
		if (ce&ack) begin
			if (req0) begin
				sel0 <= 1'b1;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd0;
			end
			else if (req1) begin
				sel1 <= 1'b1;
				sel0 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd1;
			end
			else if (req2) begin
				sel2 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd2;
			end
			else if (req3) begin
				sel3 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd3;
			end
			else if (req4) begin
				sel4 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd4;
			end
			else if (req5) begin
				sel5 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd5;
			end
			else if (req6) begin
				sel6 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd6;
			end
			else if (req7) begin
				sel7 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				seln <= 3'd7;
			end
			// otherwise, hold onto last owner
			else begin
				sel0 <= sel0;
				sel1 <= sel1;
				sel2 <= sel2;
				sel3 <= sel3;
				sel4 <= sel4;
				sel5 <= sel5;
				sel6 <= sel6;
				sel7 <= sel7;
				seln <= seln;
			end
		end
	end
end

endmodule","{
""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req0 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req0""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""req0"": ""bus request signal from requester 0""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the bus grant indicator for the channel seven is deasserted and the bus request for the channel zero is asserted, then in the following cycle the deasserted state of the channel seven grant is maintained""
},
""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req1 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req1""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""req1"": ""bus request signal from requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the bus grant indicator for the channel seven is deasserted and the bus request for the channel one is asserted, then in the next cycle the deasserted state of the channel seven grant is preserved""
},
""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 1 & ack == 0) |=> (sel7 == 1)"",
    ""Signals"": [""sel7"", ""ack""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the bus grant indicator for the channel seven is asserted and the bus transfer completion indicator is deasserted, then in the subsequent cycle the asserted state of the channel seven grant continues""
},
""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 1 & ce == 0) |=> (sel7 == 1)"",
    ""Signals"": [""sel7"", ""ce""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the bus grant indicator for the channel seven is asserted while the clock enable is deasserted, then the asserted state of that grant is maintained in the next cycle""
},
""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & ack == 0) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""ack""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the bus grant indicator for the channel seven is deasserted and the bus transfer completion indicator is also deasserted, then the deasserted state of that grant persists in the subsequent cycle""
},
""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req2 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req2""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""req2"": ""bus request signal from requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the bus grant indicator for the channel seven is deasserted and the bus request for the channel two is asserted, then the deasserted state of the grant is maintained in the following cycle""
},
""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req3 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req3""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""req3"": ""bus request signal from requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel seven is deasserted and the request from channel three is asserted, then in the next cycle the deasserted bus grant condition continues""
},
""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req5 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req5""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""req5"": ""bus request signal from requester 5""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel seven is deasserted and the request from channel five is asserted, then the deasserted condition of the grant is preserved in the next cycle""
},
""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req6 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req6""],
    ""Signal Explanations"": {
        ""sel7"": ""bus grant signal for requester 7"",
        ""req6"": ""bus request signal from requester 6""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant status for channel seven is deasserted while the request for channel six is asserted, then the maintained state in the following cycle continues to be deasserted""
},
""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req0 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req0""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""req0"": ""bus request signal from requester 0""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel five is deasserted and the request from channel zero is asserted, then in the next cycle the deasserted state for channel five remains""
},
""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req1 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req1""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""req1"": ""bus request signal from requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel five is deasserted and the request from channel one is asserted, then the deasserted state is maintained in the subsequent cycle""
},
""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 1 & ce == 0) |=> (sel5 == 1)"",
    ""Signals"": [""sel5"", ""ce""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel five is asserted while the clock enable is deasserted, then that asserted state continues in the next cycle""
},
""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 1 & ack == 0) |=> (sel5 == 1)"",
    ""Signals"": [""sel5"", ""ack""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel five is asserted and the transfer completion indicator is deasserted, then in the next cycle the asserted condition persists""
},
""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & ack == 0) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""ack""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel five is deasserted and the transfer completion indicator is deasserted as well, then that deasserted state remains in the subsequent cycle""
},
""Assertion 15"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & ce == 0) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""ce""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel five is deasserted and the clock enable is deasserted, then the deasserted condition continues in the next cycle""
},
""Assertion 16"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req2 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req2""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""req2"": ""bus request signal from requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel five is deasserted and the bus request for channel two is asserted, then the deasserted state persists in the following cycle""
},
""Assertion 17"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req3 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req3""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""req3"": ""bus request signal from requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel five is deasserted and the request from channel three is asserted, then the maintained deasserted condition holds in the next cycle""
},
""Assertion 18"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req4 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req4""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""req4"": ""bus request signal from requester 4""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel five is deasserted and the request from channel four is asserted, then the deasserted state is maintained in the subsequent cycle""
},
""Assertion 19"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req5 == 0) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req5""],
    ""Signal Explanations"": {
        ""sel5"": ""bus grant signal for requester 5"",
        ""req5"": ""bus request signal from requester 5""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel five is deasserted and the corresponding bus request is also deasserted, then the deasserted state persists in the next cycle""
},
""Assertion 20"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req1 == 1) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req1""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""req1"": ""bus request signal from requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel four is deasserted and the bus request from channel one is asserted, then the deasserted condition for channel four is maintained in the following cycle""
},
""Assertion 21"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 1 & ack == 0) |=> (sel4 == 1)"",
    ""Signals"": [""sel4"", ""ack""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel four is asserted and the transfer complete indicator is deasserted, then the asserted condition continues into the next cycle""
},
""Assertion 22"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & ack == 0) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""ack""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel four is deasserted and the transfer completion indicator is deasserted as well, then the deasserted state is maintained in the following cycle""
},
""Assertion 23"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & ce == 0) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""ce""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel four is deasserted and the clock enable is deasserted, then the deasserted condition continues in the next cycle""
},
""Assertion 24"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 1 & ce == 0) |=> (sel4 == 1)"",
    ""Signals"": [""sel4"", ""ce""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel four is asserted while the clock enable is deasserted, then the asserted condition is preserved in the subsequent cycle""
},
""Assertion 25"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req2 == 1) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req2""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""req2"": ""bus request signal from requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel four is deasserted and the request from channel two is asserted, then the deasserted state for channel four continues in the next cycle""
},
""Assertion 26"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req3 == 1) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req3""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""req3"": ""bus request signal from requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for granting the bus to channel four is deasserted and the request from channel three is asserted, then in the subsequent cycle the deasserted state is retained""
},
""Assertion 27"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req4 == 0) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req4""],
    ""Signal Explanations"": {
        ""sel4"": ""bus grant signal for requester 4"",
        ""req4"": ""bus request signal from requester 4""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""equal"",
        ""&"": ""logical AND"",
        ""|=>"": ""non-overlapping implication meaning that if the antecedent holds in one cycle then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the grant indicator for channel four is deasserted and the request from channel four is also deasserted, then the deasserted state for channel four continues in the following cycle""
}
}","{
""Assertion 1"": ""assert property (sel7 == 1'b0 && req0 == 1'b1 |-> sel7 == 1'b0);"",
""Assertion 2"": ""assert property (sel7 == 1'b0 && req1 == 1'b1 |-> sel7 == 1'b0);"",
""Assertion 3"": ""assert property (sel7 && !ack |-> (sel7[1] throughout sel7));"",
""Assertion 4"": ""assert property (sel7 == 1'b1 && ce == 1'b0 |-> sel7 == $past(sel7));"",
""Assertion 5"": ""assert property (sel7 == 1'b0 && ack == 1'b0 |=> sel7 == 1'b0);"",
""Assertion 6"": ""assert property ((sel7 == 1'b0) && (req2 == 1'b1) |=> (sel7 == 1'b0));"",
""Assertion 7"": ""assert property (sel7 == 1'b0 && req3 == 1'b1 |=> sel7 == 1'b0);"",
""Assertion 8"": ""assert property (sel7 == 1'b0 && req5 == 1'b1 |-> sel7 == 1'b0);"",
""Assertion 9"": ""assert property (sel7 == 1'b0 && req6 == 1'b1 |-> sel7 == 1'b0);"",
""Assertion 10"": ""assert property (sel5 == 1'b0 && req0 == 1'b1 |-> sel5 == 1'b0);"",
""Assertion 11"": ""assert property (sel5 == 1'b0 && req1 == 1'b1 |-> sel5 == 1'b0);"",
""Assertion 12"": ""assert property (sel5 == 1'b1 && ce == 1'b0 |=> sel5 == 1'b1);"",
""Assertion 13"": ""assert property (sel5 == 1'b1 && ack == 1'b0 |-> ##1 (sel5 == 1'b1));"",
""Assertion 14"": ""assert property (sel5 == 1'b0 && ack == 1'b0 -> (next(sel5) == 1'b0 && next(ack) == 1'b0));"",
""Assertion 15"": ""assert property (sel5 == 1'b0 |-> sel5 == 1'b0);"",
""Assertion 16"": ""assert property (sel5 == 1'b0 && req2 == 1'b1 |-> sel5 == 1'b0);"",
""Assertion 17"": ""assert property (sel5 == 1'b0 && req3 == 1'b1 |-> sel5 == 1'b0);"",
""Assertion 18"": ""assert property (sel5 == 1'b0 && req4 == 1'b1 |-> (sel5 == 1'b0));"",
""Assertion 19"": ""assert property (sel5 == 1'b0 && req5 == 1'b0 |-> (sel5[1] == 1'b0));"",
""Assertion 20"": ""assert property (sel4 == 1'b0 && req1 == 1'b1 |-> sel4 == 1'b0);"",
""Assertion 21"": ""assert property (sel4 == 1'b1 && ack == 1'b0) |=> (sel4 == 1'b1);"",
""Assertion 22"": ""assert property (sel4 == 1'b0 && ack == 1'b0 |-> sel4 == 1'b0);"",
""Assertion 23"": ""assert property (sel4 == 1'b0 |-> sel4 == 1'b0);"",
""Assertion 24"": ""assert property (sel4 == 1'b1 |-> sel4 == 1'b1);"",
""Assertion 25"": ""assert property (sel4 == 1'b0 && req2 == 1'b1 |-> sel4 == 1'b0);"",
""Assertion 26"": ""assert property ((!sel4) && req3 |=> (sel4 |-> sel4));"",
""Assertion 27"": ""assert property (req4 == 1'b0 |-> sel4 == 1'b0);""
}"
apb,"//////////////////////////////////////////////////////////////////
////
////
//// 	APB module to I2C Core
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// apbi2c_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Ronal Dario Celaya
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////

`timescale 1ns/1ps //timescale 

module apb(
			//standard ARM
	    		input PCLK,
			input PRESETn,
			input PSELx,
			input PWRITE,
			input PENABLE,
			input [31:0] PADDR,
			input [31:0] PWDATA,

			//internal pin
			input [31:0] READ_DATA_ON_RX,
			input ERROR,
			input TX_EMPTY,
			input RX_EMPTY,
			
			//external pin
			output [31:0] PRDATA,

			//internal pin 
			output reg [13:0] INTERNAL_I2C_REGISTER_CONFIG,
			output reg [13:0] INTERNAL_I2C_REGISTER_TIMEOUT,
			output [31:0] WRITE_DATA_ON_TX,
			output  WR_ENA,
			output  RD_ENA,
			
			//outside port 
			output PREADY,
			output PSLVERR,

			//interruption
			output INT_RX,
			output INT_TX
	   

	  );

//ENABLE WRITE ON TX FIFO
assign WR_ENA = (PWRITE == 1'b1 & PENABLE == 1'b1 & PADDR == 32'd0 & PSELx == 1'b1)?  1'b1:1'b0;

//ENABLE READ ON RX FIFO
assign RD_ENA = (PWRITE == 1'b0 & PENABLE == 1'b1  & PADDR == 32'd4 & PSELx == 1'b1)?  1'b1:1'b0;

//WRITE ON I2C MODULE
assign PREADY = ((WR_ENA == 1'b1 | RD_ENA == 1'b1 | PADDR == 32'd8 | PADDR == 32'd12) &  (PENABLE == 1'b1 & PSELx == 1'b1))? 1'b1:1'b0;

//INPUT TO WRITE ON TX FIFO
assign WRITE_DATA_ON_TX = (PADDR == 32'd0)? PWDATA:PWDATA;

//OUTPUT DATA FROM RX TO PRDATA
assign PRDATA = (PADDR == 32'd4)? READ_DATA_ON_RX:READ_DATA_ON_RX;

//ERROR FROM I2C CORE
assign PSLVERR = ERROR; 

//INTERRUPTION FROM I2C
assign INT_TX = TX_EMPTY;

//INTERRUPTION FROM I2C
assign INT_RX = RX_EMPTY;

//This is sequential logic used only to register configuration
always@(posedge PCLK)
begin

	if(!PRESETn)
	begin
		INTERNAL_I2C_REGISTER_CONFIG <= 14'd0;
		INTERNAL_I2C_REGISTER_TIMEOUT <= 14'd0;
	end
	else
	begin

		// Set configuration to i2c
		if(PADDR == 32'd8 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1)
		begin
			INTERNAL_I2C_REGISTER_CONFIG <= PWDATA[13:0];
		end
		else if(PADDR == 32'd12 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1)
		begin
			INTERNAL_I2C_REGISTER_TIMEOUT <= PWDATA[13:0];
		end
		else
		begin
			INTERNAL_I2C_REGISTER_CONFIG <= INTERNAL_I2C_REGISTER_CONFIG;
		end
		
	end

end 


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(ERROR == 0) |-> (PSLVERR == 0)"",
    ""Signals"": [""ERROR"", ""PSLVERR""],
    ""Signal Explanations"": {
      ""ERROR"": ""error status indicator coming from the I2C core"",
      ""PSLVERR"": ""error signal output that reflects the I2C core error condition""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal to"",
      ""|->"": ""non-overlapping implication: if the left-hand condition is true in one evaluation then the right-hand condition must hold at the indicated evaluation""
    },
    ""Assertion Explaination"": ""if the error status indicator from the I2C core is equal to inactive then the error signal output reflecting the I2C core error condition is equal to inactive""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(ERROR == 1) |-> (PSLVERR == 1)"",
    ""Signals"": [""ERROR"", ""PSLVERR""],
    ""Signal Explanations"": {
      ""ERROR"": ""error status indicator coming from the I2C core"",
      ""PSLVERR"": ""error signal output that reflects the I2C core error condition""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal to"",
      ""|->"": ""non-overlapping implication: if the left-hand condition is true in one evaluation then the right-hand condition must hold at the indicated evaluation""
    },
    ""Assertion Explaination"": ""if the error status indicator from the I2C core is equal to active then the error signal output reflecting the I2C core error condition is equal to active""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(TX_EMPTY == 1) |-> (INT_TX == 1)"",
    ""Signals"": [""TX_EMPTY"", ""INT_TX""],
    ""Signal Explanations"": {
      ""TX_EMPTY"": ""transmit FIFO empty indicator from within the module"",
      ""INT_TX"": ""transmit interrupt signal generated by the module""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal to"",
      ""|->"": ""non-overlapping implication: if the left-hand condition is true then the right-hand condition must subsequently be true""
    },
    ""Assertion Explaination"": ""if the transmit FIFO empty indicator is equal to active then the transmit interrupt signal generated by the module is equal to active""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(TX_EMPTY == 0) |-> (INT_TX == 0)"",
    ""Signals"": [""TX_EMPTY"", ""INT_TX""],
    ""Signal Explanations"": {
      ""TX_EMPTY"": ""transmit FIFO empty indicator from within the module"",
      ""INT_TX"": ""transmit interrupt signal generated by the module""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal to"",
      ""|->"": ""non-overlapping implication: if the left-hand condition is true then the right-hand condition must subsequently be true""
    },
    ""Assertion Explaination"": ""if the transmit FIFO empty indicator is equal to inactive then the transmit interrupt signal generated by the module is equal to inactive""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(RX_EMPTY == 0) |-> (INT_RX == 0)"",
    ""Signals"": [""RX_EMPTY"", ""INT_RX""],
    ""Signal Explanations"": {
      ""RX_EMPTY"": ""receive FIFO empty indicator from within the module"",
      ""INT_RX"": ""receive interrupt signal generated by the module""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal to"",
      ""|->"": ""non-overlapping implication: if the left-hand condition is true then the right-hand condition must subsequently be true""
    },
    ""Assertion Explaination"": ""if the receive FIFO empty indicator is equal to inactive then the receive interrupt signal generated by the module is equal to inactive""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(RX_EMPTY == 1) |-> (INT_RX == 1)"",
    ""Signals"": [""RX_EMPTY"", ""INT_RX""],
    ""Signal Explanations"": {
      ""RX_EMPTY"": ""receive FIFO empty indicator from within the module"",
      ""INT_RX"": ""receive interrupt signal generated by the module""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal to"",
      ""|->"": ""non-overlapping implication: if the left-hand condition is true then the right-hand condition must subsequently be true""
    },
    ""Assertion Explaination"": ""if the receive FIFO empty indicator is equal to active then the receive interrupt signal generated by the module is equal to active""
  }
}","{
""Assertion 1"": ""assert property (ERROR == 1'b0 |-> PSLVERR == 1'b0);"",
""Assertion 2"": ""assert property (ERROR |-> PSLVERR);"",
""Assertion 3"": ""assert property (TX_EMPTY == 1'b1 |-> INT_TX == 1'b1);"",
""Assertion 4"": ""assert property (TX_EMPTY == 1'b0 |-> INT_TX == 1'b0);"",
""Assertion 5"": ""assert property (RX_EMPTY == 1'b0 |-> INT_RX == 1'b0);"",
""Assertion 6"": ""assert property (RX_EMPTY === 1'b1 |-> INT_RX === 1'b1);""
}"
host_interface,"//////////////////////////////////////////////////////////////////
////
////
//// 	CRCAHB CORE BLOCK
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// crcahb IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): -  Julio Cesar 
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////
module host_interface
(
	//OUTPUTS
	output [31:0] HRDATA,
	output HREADYOUT,
	output HRESP,
	output [31:0] bus_wr,
	output [ 1:0] crc_poly_size,
	output [ 1:0] bus_size,
	output [ 1:0] rev_in_type,
	output rev_out_type,
	output crc_init_en,
	output crc_idr_en,
	output crc_poly_en,
	output buffer_write_en,
	output reset_chain,
	//INPUTS
	input [31:0] HWDATA,
	input [31:0] HADDR,
	input [ 2:0] HSIZE,
	input [ 1:0] HTRANS,
	input HWRITE,
	input HSElx,
	input HREADY,
	input HRESETn,
	input HCLK,
	input [31:0] crc_poly_out,
	input [31:0] crc_out,
	input [31:0] crc_init_out,
	input [ 7:0] crc_idr_out,
	input buffer_full,
	input reset_pending,
	input read_wait
);

//Reset Values
localparam RESET_CRC_CR = 6'h00;

//CRC Register Map
localparam CRC_DR   = 3'h0;
localparam CRC_IDR  = 3'h1;
localparam CRC_CR   = 3'h2;
localparam CRC_INIT = 3'h4;
localparam CRC_POL  = 3'h5;

//Transfer Type Encoding
localparam IDLE    = 2'b00;
localparam BUSY    = 2'b01;
localparam NON_SEQ = 2'b10;
localparam SEQ     = 2'b11;

//HRESP Encoding
localparam OK    = 1'b0;
localparam ERROR = 1'b1;

//Pipeline flops
reg [2:0] haddr_pp;
reg [2:0] hsize_pp;
reg [1:0] htrans_pp;
reg hwrite_pp;
reg hselx_pp;

//Flops
reg [4:0] crc_cr_ff;

//Internal Signals
wire [31:0] crc_cr_rd;
wire crc_dr_sel;
wire crc_init_sel;
wire crc_idr_sel;
wire crc_poly_sel;
wire crc_cr_sel;
wire ahb_enable;
wire write_en;
wire read_en;
wire crc_cr_en;
wire sample_bus;
wire buffer_read_en;

//Pipeline Registers for Address Phase of AHB Protocol
always @(posedge HCLK)
	begin
		if(!HRESETn)
			begin
				hselx_pp <= 1'b0;
			end
		else
			if(sample_bus)
				begin
					haddr_pp  <= HADDR[4:2];
					hsize_pp  <= HSIZE;
					htrans_pp <= HTRANS;
					hwrite_pp <= HWRITE;
					hselx_pp  <= HSElx;
				end
	end

//Enable Signals
assign ahb_enable = (htrans_pp == NON_SEQ);
assign write_en = hselx_pp &&  hwrite_pp && ahb_enable;
assign read_en  = hselx_pp && !hwrite_pp && ahb_enable;

//Registers decoding
assign crc_dr_sel   = (haddr_pp == CRC_DR  );
assign crc_init_sel = (haddr_pp == CRC_INIT);
assign crc_idr_sel  = (haddr_pp == CRC_IDR );
assign crc_poly_sel = (haddr_pp == CRC_POL );
assign crc_cr_sel   = (haddr_pp == CRC_CR  );

//Write Esnables Signals for Registers
assign buffer_write_en = crc_dr_sel   && write_en;
assign crc_init_en     = crc_init_sel && write_en;
assign crc_idr_en      = crc_idr_sel  && write_en;
assign crc_poly_en     = crc_poly_sel && write_en;
assign crc_cr_en       = crc_cr_sel   && write_en;

//Indicates reading operation request to crc_dr register
assign buffer_read_en = crc_dr_sel && read_en;

//Bus Size is the output of HSIZE pipeline register
assign bus_size = hsize_pp;

//The Write Bus is not pipelined
assign bus_wr = HWDATA;

//HREADY Signal outputed to Master
assign HREADYOUT = !((buffer_write_en && buffer_full   ) ||
                     (buffer_read_en  && read_wait     ) ||
                     (crc_init_en     && reset_pending ) );

//Signal to control sampling of bus
assign sample_bus = HREADYOUT && HREADY;

//HRESP Signal outputed to Master
//This implementation never signalize bus error to master
assign HRESP = OK;

//CRC_CR Data Read
assign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0};

//Mux to HRDATA
assign HRDATA = ({32{crc_dr_sel  }} & crc_out             ) |
                ({32{crc_init_sel}} & crc_init_out        ) |
                ({32{crc_idr_sel }} & {24'h0, crc_idr_out}) |
                ({32{crc_poly_sel}} & crc_poly_out        ) |
                ({32{crc_cr_sel  }} & crc_cr_rd           ) ;

//Control Register
always @(posedge HCLK)
	begin
		if(!HRESETn)
			crc_cr_ff <= RESET_CRC_CR;
		else
			if(crc_cr_en)
				crc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]};
	end

//Configuration Signals
assign reset_chain   = (crc_cr_en && HWDATA[0]);
assign crc_poly_size = crc_cr_ff[1:0];
assign rev_in_type   = crc_cr_ff[3:2];
assign rev_out_type  = crc_cr_ff[4];

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(sample_bus == 1) |-> (HREADYOUT == 1)"",
""Signals"": [""sample_bus"", ""HREADYOUT""],
""Signal Explanations"": {
  ""sample_bus"": ""the signal that controls when the bus signals are sampled (it is asserted when both the master's ready signal and the slave's ready signal allow the sampling)"",
  ""HREADYOUT"": ""the output signal that indicates to the master that the slave is ready to proceed with the transaction""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""tests equality between two values"",
  ""|->"": ""if the antecedent condition is true then the consequent condition must be true (implication)""
},
""Assertion Explaination"": ""When the condition to sample the bus is met, it implies that the output indicating readiness to the master must be active.""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(buffer_read_en == 1 & read_wait == 1) |-> (HREADYOUT == 0)"",
""Signals"": [""buffer_read_en"", ""read_wait"", ""HREADYOUT""],
""Signal Explanations"": {
  ""buffer_read_en"": ""the signal that indicates a read request from the CRC data register buffer"",
  ""read_wait"": ""the signal that indicates a wait state during a read operation"",
  ""HREADYOUT"": ""the output signal that tells the master whether the slave is ready to proceed""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""checks that a signal’s value equals a specified constant"",
  ""&"": ""logical AND that combines conditions"",
  ""|->"": ""implies that if the left-hand side condition holds, then the right-hand side condition must hold""
},
""Assertion Explaination"": ""If both the read request from the buffer is active and a wait state is indicated, then it implies that the ready output to the master should be deasserted.""
},
""Assertion 3"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(ahb_enable == 0) |-> (HREADYOUT == 1)"",
""Signals"": [""ahb_enable"", ""HREADYOUT""],
""Signal Explanations"": {
  ""ahb_enable"": ""the signal that indicates an active AHB transfer; it is true when a non-sequential transfer occurs"",
  ""HREADYOUT"": ""the signal sent to the master that indicates the interface is ready""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""verifies that a signal’s value matches a given constant"",
  ""|->"": ""specifies that if the condition on the left is met, then the condition on the right must follow""
},
""Assertion Explaination"": ""If an AHB transfer is not enabled, then it implies that the interface must signal it is ready to the master.""
},
""Assertion 4"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(write_en == 0) |-> (crc_idr_en == 0)"",
""Signals"": [""write_en"", ""crc_idr_en""],
""Signal Explanations"": {
  ""write_en"": ""the signal that indicates a write operation is taking place"",
  ""crc_idr_en"": ""the write enable signal for the register that holds the identifier value for CRC""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""ensures that the value of a signal equals a specific constant"",
  ""|->"": ""ensures that if the first condition is true, then the second condition must also be true""
},
""Assertion Explaination"": ""If no write operation is occurring, then it implies that the write enable for the CRC identifier register must be deactivated.""
},
""Assertion 5"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(write_en == 1 & crc_idr_sel == 1) |-> (crc_idr_en == 1)"",
""Signals"": [""write_en"", ""crc_idr_sel"", ""crc_idr_en""],
""Signal Explanations"": {
  ""write_en"": ""the signal that indicates a write transaction is taking place"",
  ""crc_idr_sel"": ""the signal that indicates selection of the CRC identifier register based on the address decoding"",
  ""crc_idr_en"": ""the write enable signal for the CRC identifier register""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""checks for equality of values"",
  ""&"": ""combines multiple conditions logically, requiring both to be true"",
  ""|->"": ""establishes that if the combined condition is met, then the specified outcome must follow""
},
""Assertion Explaination"": ""If a write operation is active and the register selection corresponds to the CRC identifier register, then it implies that the write enable for that register must be active.""
},
""Assertion 6"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(crc_idr_sel == 0) |-> (crc_idr_en == 0)"",
""Signals"": [""crc_idr_sel"", ""crc_idr_en""],
""Signal Explanations"": {
  ""crc_idr_sel"": ""the signal indicating whether the CRC identifier register is selected"",
  ""crc_idr_en"": ""the signal that enables writing to the CRC identifier register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""verifies that a signal attains a given value"",
  ""|->"": ""indicates that the satisfaction of the antecedent forces the consequent condition""
},
""Assertion Explaination"": ""If the selection for the CRC identifier register is not made, then it implies that the write enable for that register should be inactive.""
},
""Assertion 7"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(hselx_pp == 0) |-> (crc_idr_en == 0)"",
""Signals"": [""hselx_pp"", ""crc_idr_en""],
""Signal Explanations"": {
  ""hselx_pp"": ""the pipelined signal that indicates whether the device is selected for the current transaction"",
  ""crc_idr_en"": ""the signal that enables writing to the CRC identifier register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""determines equality between a signal and a constant value"",
  ""|->"": ""dictates that if the initial condition holds, then the following condition must also be true""
},
""Assertion Explaination"": ""If the interface is not selected, then it implies that the write enable for the CRC identifier register must be inactive.""
},
""Assertion 8"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(hwrite_pp == 0) |-> (crc_idr_en == 0)"",
""Signals"": [""hwrite_pp"", ""crc_idr_en""],
""Signal Explanations"": {
  ""hwrite_pp"": ""the pipelined write signal indicating whether the current operation is a write"",
  ""crc_idr_en"": ""the signal that controls writing into the CRC identifier register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""compares a signal’s value to a constant"",
  ""|->"": ""sets a condition such that if the first part is true then the second part must be true""
},
""Assertion Explaination"": ""If a write operation is not indicated in the pipelined stage, then it implies that the write enable for the CRC identifier register must be deasserted.""
},
""Assertion 9"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(write_en == 0) |-> (crc_poly_en == 0)"",
""Signals"": [""write_en"", ""crc_poly_en""],
""Signal Explanations"": {
  ""write_en"": ""the signal that indicates an active write operation"",
  ""crc_poly_en"": ""the signal that enables writing to the CRC polynomial register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""ensures a signal matches a specific value"",
  ""|->"": ""imposes that when the antecedent is true, the consequent must be true as well""
},
""Assertion Explaination"": ""If there is no active write operation, then it implies that the write enable for the CRC polynomial register should be inactive.""
},
""Assertion 10"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(hselx_pp == 0) |-> (crc_poly_en == 0)"",
""Signals"": [""hselx_pp"", ""crc_poly_en""],
""Signal Explanations"": {
  ""hselx_pp"": ""the pipelined selection signal indicating if the device is chosen for the transaction"",
  ""crc_poly_en"": ""the signal controlling the write operation to the CRC polynomial register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""verifies equality between a signal and a constant"",
  ""|->"": ""dictates that the truth of the condition on the left necessitates the truth of the condition on the right""
},
""Assertion Explaination"": ""If the device is not selected during the pipeline stage, then it implies that the write enable for the CRC polynomial register must be inactive.""
},
""Assertion 11"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(hwrite_pp == 0) |-> (crc_poly_en == 0)"",
""Signals"": [""hwrite_pp"", ""crc_poly_en""],
""Signal Explanations"": {
  ""hwrite_pp"": ""the pipelined signal indicating whether the current operation is a write"",
  ""crc_poly_en"": ""the signal that enables writing into the CRC polynomial register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""checks that a signal's value equals a specified constant"",
  ""|->"": ""establishes that if the initial condition is satisfied, the subsequent condition must also be satisfied""
},
""Assertion Explaination"": ""If the pipelined write signal is not asserted, then it implies that the write enable for the CRC polynomial register should be deactivated.""
},
""Assertion 12"": {
""clock signal condition"": ""@(posedge HCLK)"",
""disable condition"": """",
""logical expression"": ""(haddr_pp[1] == 1) |-> (crc_poly_en == 0)"",
""Signals"": [""haddr_pp[1]"", ""crc_poly_en""],
""Signal Explanations"": {
  ""haddr_pp[1]"": ""the specific bit from the pipelined address used for selecting between registers"",
  ""crc_poly_en"": ""the signal that controls the write access to the CRC polynomial register""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""verifies that a particular bit or signal value matches a defined constant"",
  ""|->"": ""specifies that if the condition on the left holds true, then the condition on the right must also hold true""
},
""Assertion Explaination"": ""If the designated bit in the pipelined address is set, then it implies that the write enable for the CRC polynomial register must be inactive.""
}
}","{
""Assertion 1"": ""assert property (sample_bus |=> HREADYOUT);"",
""Assertion 2"": ""assert property (buffer_read_en && read_wait -> !HREADYOUT);"",
""Assertion 3"": ""assert property ( ahb_enable == 0 |=> HREADYOUT == 1 );"",
""Assertion 4"": ""assert property (HWRITE == 1'b0 |-> !crc_idr_en);"",
""Assertion 5"": ""assert property (HWRITE && crc_idr_sel ==> crc_idr_en);"",
""Assertion 6"": ""assert property (crc_idr_sel == 1'b0 |-> !crc_idr_en);"",
""Assertion 7"": ""assert property (HSELx == 1'b0 |-> !crc_idr_en);"",
""Assertion 8"": ""assert property ((!hwrite_pp) |=> !crc_idr_en);"",
""Assertion 9"": ""assert property (HWRITE == 1'b0 |-> !crc_poly_en);"",
""Assertion 10"": ""assert property (hselx_pp == 1'b0 -> !crc_poly_en);"",
""Assertion 11"": ""assert property ( !hselx_pp || !hwrite_pp || !crc_poly_en );"",
""Assertion 12"": ""assert property (crc_poly_sel |-> !crc_poly_en);""
}"
control_unit,"//////////////////////////////////////////////////////////////////
////
////
//// 	AES CORE BLOCK
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// aes128_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Julio Cesar 
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////
module control_unit
(
	output reg [ 2:0] sbox_sel,
	output reg [ 1:0] rk_sel,
	output reg [ 1:0] key_out_sel,
	output reg [ 1:0] col_sel,
	output reg [ 3:0] key_en,
	output reg [ 3:0] col_en,
	output     [ 3:0] round,
	output reg bypass_rk,
	output reg bypass_key_en,
	output reg key_sel,
	output reg iv_cnt_en,
	output reg iv_cnt_sel,
	output reg key_derivation_en,
	output end_comp,
	output key_init,
	output key_gen,
	output mode_ctr,
	output mode_cbc,
	output last_round,
  output encrypt_decrypt,	
	input [1:0] operation_mode,
	input [1:0] aes_mode,
	input start,
	input disable_core,
	input clk,
	input rst_n
);
//`include ""include/host_interface.vh""
//`include ""include/control_unit_params.vh""

//=====================================================================================
// Memory Mapped Registers Address
//=====================================================================================
localparam AES_CR    = 4'd00;
localparam AES_SR    = 4'd01;
localparam AES_DINR  = 4'd02;
localparam AES_DOUTR = 4'd03;
localparam AES_KEYR0 = 4'd04;
localparam AES_KEYR1 = 4'd05;
localparam AES_KEYR2 = 4'd06;
localparam AES_KEYR3 = 4'd07;
localparam AES_IVR0  = 4'd08;
localparam AES_IVR1  = 4'd09;
localparam AES_IVR2  = 4'd10;
localparam AES_IVR3  = 4'd11;

//=============================================================================
// Operation Modes
//=============================================================================
localparam ENCRYPTION     = 2'b00;
localparam KEY_DERIVATION = 2'b01;
localparam DECRYPTION     = 2'b10;
localparam DECRYP_W_DERIV = 2'b11;

//=============================================================================
// AES Modes
//=============================================================================
localparam ECB = 2'b00;
localparam CBC = 2'b01;
localparam CTR = 2'b10;

//=============================================================================
// SBOX SEL
//=============================================================================
localparam COL_0 = 3'b000;
localparam COL_1 = 3'b001;
localparam COL_2 = 3'b010;
localparam COL_3 = 3'b011;
localparam G_FUNCTION = 3'b100;

//=============================================================================
// RK_SEL
//=============================================================================
localparam COL        = 2'b00;
localparam MIXCOL_IN  = 2'b01;
localparam MIXCOL_OUT = 2'b10;

//=============================================================================
// KEY_OUT_SEL
//=============================================================================
localparam KEY_0 = 2'b00;
localparam KEY_1 = 2'b01;
localparam KEY_2 = 2'b10;
localparam KEY_3 = 2'b11;

//=============================================================================
// COL_SEL
//=============================================================================
localparam SHIFT_ROWS = 2'b00;
localparam ADD_RK_OUT = 2'b01;
localparam INPUT      = 2'b10;

//=============================================================================
// KEY_SEL
//=============================================================================
localparam KEY_HOST = 1'b0;
localparam KEY_OUT  = 1'b1;

//=============================================================================
// KEY_EN
//=============================================================================
localparam KEY_DIS  = 4'b0000;
localparam EN_KEY_0 = 4'b0001;
localparam EN_KEY_1 = 4'b0010;
localparam EN_KEY_2 = 4'b0100;
localparam EN_KEY_3 = 4'b1000;
localparam KEY_ALL  = 4'b1111;

//=============================================================================
// COL_EN
//=============================================================================
localparam COL_DIS  = 4'b0000;
localparam EN_COL_0 = 4'b0001;
localparam EN_COL_1 = 4'b0010;
localparam EN_COL_2 = 4'b0100;
localparam EN_COL_3 = 4'b1000;
localparam COL_ALL  = 4'b1111;

//=============================================================================
// IV_CNT_SEL
//=============================================================================
localparam IV_CNT = 1'b1;
localparam IV_BUS = 1'b0;

//=============================================================================
// ENABLES
//=============================================================================
localparam ENABLE = 1'b1;
localparam DISABLE = 1'b0;

localparam NUMBER_ROUND      = 4'd10;
localparam NUMBER_ROUND_INC  = 4'd11;
localparam INITIAL_ROUND     = 4'd00;

//=============================================================================
// FSM STATES
//=============================================================================
localparam IDLE        = 4'd00;
localparam ROUND0_COL0 = 4'd01;
localparam ROUND0_COL1 = 4'd02;
localparam ROUND0_COL2 = 4'd03;
localparam ROUND0_COL3 = 4'd04;
localparam ROUND_KEY0  = 4'd05;
localparam ROUND_COL0  = 4'd06;
localparam ROUND_COL1  = 4'd07;
localparam ROUND_COL2  = 4'd08;
localparam ROUND_COL3  = 4'd09;
localparam READY       = 4'd10;
localparam GEN_KEY0    = 4'd11;
localparam GEN_KEY1    = 4'd12;
localparam GEN_KEY2    = 4'd13;
localparam GEN_KEY3    = 4'd14;
localparam NOP         = 4'd15;

reg [3:0] state, next_state;
reg [3:0] rd_count;

reg rd_count_en;
//reg end_aes_pp1, end_aes_pp2;
wire op_key_derivation;
wire first_round;
wire [1:0] op_mode;
wire enc_dec;

// State Flops Definition
always @(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			state <= IDLE;
		else
			if(disable_core)
				state <= IDLE;
			else
				state <= next_state;
	end

assign encrypt_decrypt = (op_mode == ENCRYPTION || op_mode == KEY_DERIVATION || state == GEN_KEY0   
			  ||   state == GEN_KEY1       ||state == GEN_KEY2   ||   state == GEN_KEY3       );

assign enc_dec = encrypt_decrypt | mode_ctr;
assign key_gen = (state == ROUND_KEY0);

assign op_key_derivation = (op_mode == KEY_DERIVATION);

assign mode_ctr = (aes_mode == CTR);
assign mode_cbc = (aes_mode == CBC);

assign key_init = start;

assign op_mode = (mode_ctr) ? ENCRYPTION : operation_mode;

// Next State Logic
always @(*)
	begin
		next_state = state;
		case(state)
			IDLE:
				begin
					if(!start)
						next_state = IDLE;
					else
						case(op_mode)
							ENCRYPTION    : next_state = ROUND0_COL0;
							DECRYPTION    : next_state = ROUND0_COL3;
							KEY_DERIVATION: next_state = GEN_KEY0;
							DECRYP_W_DERIV: next_state = GEN_KEY0;
							default       : next_state = IDLE;
						endcase
				end
			ROUND0_COL0:
				begin
					next_state = (enc_dec) ? ROUND0_COL1 : ROUND_KEY0; 
				end
			ROUND0_COL1:
				begin
					next_state = (enc_dec) ? ROUND0_COL2 : ROUND0_COL0;
				end
			ROUND0_COL2:
				begin
					next_state = (enc_dec) ? ROUND0_COL3 : ROUND0_COL1;
				end
			ROUND0_COL3:
				begin
					next_state = (enc_dec) ? ROUND_KEY0 : ROUND0_COL2;
				end
			ROUND_KEY0 :
				begin
					if(!first_round)
						begin
							next_state = (last_round) ? READY : NOP;
						end
					else
						begin
							next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;
						end
				end
			NOP        :
				begin
					next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;
				end
			ROUND_COL0 :
				begin
					next_state = (enc_dec) ? ROUND_COL1 : ROUND_KEY0;
				end
			ROUND_COL1 :
				begin
					next_state = (enc_dec) ? ROUND_COL2 : ROUND_COL0;
				end
			ROUND_COL2 :
				begin
					next_state = (enc_dec) ? ROUND_COL3 : ROUND_COL1;
				end
			ROUND_COL3 :
				begin
					if(last_round && enc_dec)
						next_state = READY;
					else
					next_state = (enc_dec) ? ROUND_KEY0 : ROUND_COL2;
				end
			GEN_KEY0   :
				begin
					next_state = GEN_KEY1;
				end
			GEN_KEY1   :
				begin
					next_state = GEN_KEY2;
				end
			GEN_KEY2   :
				begin
					next_state = GEN_KEY3;
				end
			GEN_KEY3   :
				begin
					if(last_round)
						next_state = (op_key_derivation) ? READY : ROUND0_COL3;
					else
						next_state = GEN_KEY0;
				end
			READY      :
				begin
					next_state = IDLE;
				end
		endcase
	end
 
       
// Output Logic
assign end_comp = (state == READY)?ENABLE:DISABLE;

/*
always @(posedge clk, negedge rst_n)
begin
		if(!rst_n)
		begin
			end_aes_pp1 <= 1'b0;
			end_aes_pp2 <= 1'b0; 
			end_comp <= 1'b0;
		end
		else
			if(state == READY)
			begin
				end_aes_pp1 <= ENABLE;
				//end_aes_pp2 <= end_aes_pp1;
				end_comp <= end_aes_pp1 ;
			end
			else
			begin
				end_aes_pp1 <= DISABLE;
				//end_aes_pp2 <= end_aes_pp1;
				end_comp <= end_aes_pp1 ;
			end

end
*/
always @(*)
	begin
		sbox_sel = COL_0;
		rk_sel = COL;
		bypass_rk = DISABLE;
		key_out_sel = KEY_0;
		col_sel = INPUT;
		key_sel = KEY_HOST;
		key_en = KEY_DIS;
		col_en = COL_DIS;
		rd_count_en = DISABLE;
		iv_cnt_en = DISABLE;
		iv_cnt_sel = IV_BUS;
		bypass_key_en = DISABLE;
		key_derivation_en = DISABLE;
		//end_comp = DISABLE;
		case(state)
			ROUND0_COL0:
				begin
					sbox_sel = COL_0;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_0;
					col_sel = (enc_dec) ? ADD_RK_OUT : SHIFT_ROWS;
					col_en =  (enc_dec) ? EN_COL_0 : COL_ALL;
				end
			ROUND0_COL1:
				begin
					sbox_sel = COL_1;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_1;
					col_sel = ADD_RK_OUT;
					col_en = EN_COL_1;
					if(!enc_dec)
						begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_1;
						end
				end
			ROUND0_COL2:
				begin
					sbox_sel = COL_2;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_2;
					col_sel = ADD_RK_OUT;
					col_en = EN_COL_2;
					if(!enc_dec)
						begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_2;
						end
				end
			ROUND0_COL3:
				begin
					sbox_sel = COL_3;
					rk_sel   = COL;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_3;
					col_sel = (enc_dec) ? SHIFT_ROWS : ADD_RK_OUT;
					col_en =  (enc_dec) ? COL_ALL : EN_COL_3;
					bypass_rk = ENABLE;
					if(!enc_dec)
					begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_3;
					end
				end
			ROUND_KEY0:
				begin
					sbox_sel = G_FUNCTION;
					key_sel = KEY_OUT;
					key_en = EN_KEY_0;
					rd_count_en = ENABLE;
				end
			ROUND_COL0:
				begin
					sbox_sel = COL_0;
					rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_0;
					key_sel = KEY_OUT;

					if(enc_dec)
						key_en = EN_KEY_1;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						begin
							if(!enc_dec)
								col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;
							else
								col_sel = ADD_RK_OUT;
						end
					if(enc_dec)
						col_en = EN_COL_0;
					else
						col_en = (last_round) ? EN_COL_0 : COL_ALL;
				end
			ROUND_COL1:
				begin
					sbox_sel = COL_1;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_1;
					key_sel = KEY_OUT;
					if(enc_dec)
						key_en = EN_KEY_2;
					else
						key_en = EN_KEY_1;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						col_sel = ADD_RK_OUT;
					col_en = EN_COL_1;
				end
			ROUND_COL2:
				begin
					sbox_sel = COL_2;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_2;
					key_sel = KEY_OUT;
					if(enc_dec)
						key_en = EN_KEY_3;
					else
						key_en = EN_KEY_2;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						col_sel = ADD_RK_OUT;
					col_en = EN_COL_2;
				end
			ROUND_COL3:
				begin
					sbox_sel = COL_3;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_3;
					key_sel = KEY_OUT;
					if(!enc_dec)
						key_en = EN_KEY_3;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						begin
							if(enc_dec)
								col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;
							else
								col_sel = ADD_RK_OUT;
						end
					if(enc_dec)
						col_en = (last_round) ? EN_COL_3 : COL_ALL;
					else
						col_en = EN_COL_3;
					if(mode_ctr && last_round)
						begin
							iv_cnt_en = ENABLE;
							iv_cnt_sel = IV_CNT;
						end
				end
			GEN_KEY0:
				begin
					sbox_sel = G_FUNCTION;
					rd_count_en = ENABLE;
				end
			GEN_KEY1:
				begin
					key_en = EN_KEY_1 | EN_KEY_0; //Enable key 0 AND key 1
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			GEN_KEY2:
				begin
					key_en = EN_KEY_2;
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			GEN_KEY3:
				begin
					key_en = EN_KEY_3;
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			READY:
				begin
					//end_comp = ENABLE;
					if(op_mode == KEY_DERIVATION)
						key_derivation_en = ENABLE;
				end
		endcase
	end

// Round Counter
always @(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			rd_count <= INITIAL_ROUND;
		else
			if(state == IDLE || (state == GEN_KEY3 && last_round))
				rd_count <= INITIAL_ROUND;
			else 
				if(rd_count_en)
					rd_count <= rd_count + 1'b1;
	end

assign round = rd_count;
assign first_round = (rd_count == INITIAL_ROUND);
assign last_round  = (rd_count == NUMBER_ROUND || rd_count == NUMBER_ROUND_INC);

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(aes_mode[0] == 1) |-> (mode_ctr == 0)"",
    ""Signals"": [""aes_mode"", ""mode_ctr""],
    ""Signal Explanations"": {
      ""aes_mode"": ""a 2‐bit input that selects the AES operating mode (e.g. ECB, CBC, or CTR)"",
      ""mode_ctr"": ""an output signal that indicates whether the core is operating in CTR mode""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares two values for equality"",
      ""|->"": ""non-overlapping implication; if the left-hand condition holds, then the right-hand condition must hold in the same evaluation""
    },
    ""Assertion Explaination"": ""if the least significant bit of the AES mode input equals one, then the signal indicating operation in CTR mode must be deasserted (zero)""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(aes_mode[0] == 0) |-> (mode_cbc == 0)"",
    ""Signals"": [""aes_mode"", ""mode_cbc""],
    ""Signal Explanations"": {
      ""aes_mode"": ""a 2‐bit input that selects the AES operating mode (e.g. ECB, CBC, or CTR)"",
      ""mode_cbc"": ""an output signal that indicates whether the core is operating in CBC mode""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares two values for equality"",
      ""|->"": ""non-overlapping implication; if the left-hand condition holds, then the right-hand condition must hold in the same evaluation""
    },
    ""Assertion Explaination"": ""if the least significant bit of the AES mode input equals zero, then the signal indicating operation in CBC mode must be deasserted (zero)""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(start == 0) |-> (key_init == 0)"",
    ""Signals"": [""start"", ""key_init""],
    ""Signal Explanations"": {
      ""start"": ""an input signal that triggers the start of the AES operation"",
      ""key_init"": ""an output signal used to initiate key processing, which is directly assigned the value of the start signal""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares two values for equality"",
      ""|->"": ""non-overlapping implication; if the left-hand condition holds, then the right-hand condition must hold in the same evaluation""
    },
    ""Assertion Explaination"": ""if the operation trigger signal is deasserted (zero), then the signal for initiating key processing must also be deasserted (zero)""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(start == 1) |-> (key_init == 1)"",
    ""Signals"": [""start"", ""key_init""],
    ""Signal Explanations"": {
      ""start"": ""an input signal that triggers the start of the AES operation"",
      ""key_init"": ""an output signal used to initiate key processing, which is directly assigned the value of the start signal""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares two values for equality"",
      ""|->"": ""non-overlapping implication; if the left-hand condition holds, then the right-hand condition must hold in the same evaluation""
    },
    ""Assertion Explaination"": ""if the operation trigger signal is asserted (one), then the signal for initiating key processing must also be asserted (one)""
  }
}","{
""Assertion 1"": ""assert property (aes_mode[0] == 1'b1 -> !mode_ctr);"",
""Assertion 2"": ""assert property (aes_mode[0] == 1'b0 |-> !mode_cbc);"",
""Assertion 3"": ""assert property (start == 0 -> key_init == 0);"",
""Assertion 4"": ""assert property (start |-> key_init);""
}"
Programmable_Sequence_Detector,"module Programmable_Sequence_Detector 
#(
	parameter SEQ_W = 5
)
(
  input clk,
  input resetn,
  input [SEQ_W-1:0] init,
  input             din,
  input logic      seen
);

reg  [SEQ_W-1:0] seq_q;
wire [SEQ_W-1:0] seq_next;

assign seq_next = { seq_q[SEQ_W-2:0] , din } ;

always @(posedge clk) 
begin
	if ( ~resetn ) begin
		seq_q <= '0;
	end else begin
		seq_q <= seq_next;
	end
end

assign seen = seq_q == init;

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""default disable iff (~resetn)"",
""logical expression"": ""seen == (seq_q == init)"",
""Signals"": [""seen"", ""seq_q"", ""init""],
""Signal Explanations"": {
  ""seen"": ""output indicator signaling if the captured sequence matches the pattern"",
  ""seq_q"": ""register storing the sequential bits captured from the input"",
  ""init"": ""input sequence pattern used for detection""
},
""Logical Operators"": [""==""],
""Logical Operators Explanation"": {
  ""=="": ""equality comparison indicating that two boolean values are identical""
},
""Assertion Explaination"": ""This assertion verifies that the boolean indicator, which reflects the sequence detection result, exactly equals the boolean value obtained by comparing the stored sequence with the provided detection pattern, ensuring that the flag correctly mirrors the outcome of the comparison.""
}
}","{
""Assertion 1"": ""assert property (seen == seq_q && seq_q == init);""
}"
PWM,"module PWM #(parameter CBITS = 10) 
(input clk, input rst, input [3:0] sw, output reg pulse);
  
  wire [CBITS-1:0] pulse_wide;
  assign pulse_wide = {1'b0, sw[3:1], 6'd0};     // (CBTIS-4)

  reg [CBITS-1:0] cntR;

  always @(posedge clk) begin
    cntR <= cntR + 1;
    
    if (cntR < pulse_wide)
      pulse = 1'b1;
    else
      pulse = 1'b0;
  end

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""1 |-> s_eventually(~pulse)"",
""Signals"": [""pulse""],
""Signal Explanations"": {
  ""pulse"": ""output pulse signal of the PWM module that is driven high while an internal counter is below a computed threshold and low otherwise""
},
""Logical Operators"": [""|->"", ""~"", ""s_eventually""],
""Logical Operators Explanation"": {
  ""|->"": ""if the left‐side condition holds, then the property on the right must eventually become true in subsequent clock cycles"",
  ""~"": ""logical negation that inverts a Boolean value"",
  ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle""
},
""Assertion Explaination"": ""since a condition that is always true holds, it mandates that eventually the condition where the inversion of the output pulse signal becomes true must be satisfied""
}
}","{
""Assertion 1"": ""assert property (pulse == 1'b0 |=> (pulse == 1'b1));""
}"
module_i2c,"//////////////////////////////////////////////////////////////////
////
////
//// 	TOP I2C BLOCK to I2C Core
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// apbi2c_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Ronal Dario Celaya ,rcelaya.dario@gmail.com
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////


`timescale 1ns/1ps //timescale 

module module_i2c#(
			//THIS IS USED ONLY LIKE PARAMETER TO BEM CONFIGURABLE
			parameter integer DWIDTH = 32,
			parameter integer AWIDTH = 14
		)
		(
		//I2C INTERFACE WITH ANOTHER BLOCKS
		 input PCLK,
		 input PRESETn,
		 
		//INTERFACE WITH FIFO TRANSMISSION
		 input fifo_tx_f_full,
		 input fifo_tx_f_empty,
		 input [DWIDTH-1:0] fifo_tx_data_out,

		//INTERFACE WITH FIFO RECEIVER
		 input fifo_rx_f_full,
		 input fifo_rx_f_empty,
		 output reg fifo_rx_wr_en,
		 output reg [DWIDTH-1:0] fifo_rx_data_in, 

		//INTERFACE WITH REGISTER CONFIGURATION
		 input [AWIDTH-1:0] DATA_CONFIG_REG,
 		 input [AWIDTH-1:0] TIMEOUT_TX,
		
		//INTERFACE TO APB AND READ FOR FIFO   
		 output reg fifo_tx_rd_en,
		 output   TX_EMPTY,
		 output   RX_EMPTY,
		 output ERROR,
		 output ENABLE_SDA,
		 output ENABLE_SCL,

		//I2C BI DIRETIONAL PORTS
		inout SDA,
		inout SCL
		 

		 );

//THIS IS USED TO GENERATE INTERRUPTIONS
assign TX_EMPTY = (fifo_tx_f_empty == 1'b1)? 1'b1:1'b0;
assign RX_EMPTY = (fifo_rx_f_empty == 1'b1)? 1'b1:1'b0;

	//THIS COUNT IS USED TO CONTROL DATA ACCROSS FSM	
	reg [1:0] count_tx;
	reg [1:0] count_rx;
	//CONTROL CLOCK AND COUNTER
	reg [11:0] count_send_data;
	reg [11:0] count_receive_data;
	reg [11:0] count_timeout;
	reg BR_CLK_O;
	reg SDA_OUT;

	reg BR_CLK_O_RX;
	reg SDA_OUT_RX;

	//RESPONSE USED TO HOLD SIGNAL TO ACK OR NACK
	reg RESPONSE;

//    PARAMETERS USED TO STATE MACHINE

localparam [5:0] IDLE = 6'd0, //IDLE

	   START = 6'd1,//START BIT

	     CONTROLIN_1 = 6'd2, //START BYTE
	     CONTROLIN_2 = 6'd3,
	     CONTROLIN_3 = 6'd4,
             CONTROLIN_4 = 6'd5,
	     CONTROLIN_5 = 6'd6,
	     CONTROLIN_6 = 6'd7,
             CONTROLIN_7 = 6'd8,
             CONTROLIN_8 = 6'd9, //END FIRST BYTE

	     RESPONSE_CIN =6'd10, //RESPONSE

	     ADDRESS_1 = 6'd11,//START BYTE
	     ADDRESS_2 = 6'd12,
	     ADDRESS_3 = 6'd13,
             ADDRESS_4 = 6'd14,
	     ADDRESS_5 = 6'd15,
	     ADDRESS_6 = 6'd16,
             ADDRESS_7 = 6'd17,
             ADDRESS_8 = 6'd18,//END FIRST BYTE

	     RESPONSE_ADDRESS =6'd19, //RESPONSE

	     DATA0_1 = 6'd20,//START BYTE
	     DATA0_2 = 6'd21,
	     DATA0_3 = 6'd22,
             DATA0_4 = 6'd23,
	     DATA0_5 = 6'd24,
	     DATA0_6 = 6'd25,
             DATA0_7 = 6'd26,
             DATA0_8 = 6'd27,//END FIRST BYTE

	     RESPONSE_DATA0_1 = 6'd28,  //RESPONSE
	   
	     DATA1_1 = 6'd29,//START BYTE
	     DATA1_2 = 6'd30,
	     DATA1_3 = 6'd31,
             DATA1_4 = 6'd32,
	     DATA1_5 = 6'd33,
	     DATA1_6 = 6'd34,
             DATA1_7 = 6'd35,
             DATA1_8 = 6'd36,//END FIRST BYTE

	     RESPONSE_DATA1_1 = 6'd37,//RESPONSE

	     DELAY_BYTES = 6'd38,//USED ONLY IN ACK TO DELAY BETWEEN
	     NACK = 6'd39,//USED ONLY IN ACK TO DELAY BETWEEN BYTES
	     STOP = 6'd40;//USED TO SEND STOP BIT

	//STATE CONTROL 
	reg [5:0] state_tx;
	reg [5:0] next_state_tx;

//ASSIGN REGISTERS TO BIDIRETIONAL PORTS
assign SDA =(DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b0 & state_tx != RESPONSE_CIN & state_tx != RESPONSE_ADDRESS & state_tx != RESPONSE_DATA0_1 & state_tx != RESPONSE_DATA1_1)?SDA_OUT:SDA_OUT_RX;


assign SCL = (DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b0)?BR_CLK_O:BR_CLK_O_RX;

//STANDARD ERROR
assign ERROR = (DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b1)?1'b1:1'b0;


//COMBINATIONAL BLOCK TO   
always@(*)
begin

	//THE FUN START HERE :-)
	//COMBINATIONAL UPDATE STATE BE CAREFUL WITH WHAT YOU MAKE HERE
	next_state_tx=state_tx;

	case(state_tx)//state_   IS MORE SECURE CHANGE ONLY IF YOU KNOW WHAT ARE YOU DOING 
	IDLE:
	begin
		//OBEYING SPEC
		if(DATA_CONFIG_REG[0] == 1'b0 && (fifo_tx_f_full == 1'b1 || fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b0)
		begin
			next_state_tx   = IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && (fifo_tx_f_full == 1'b1 || fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b1)
		begin
			next_state_tx   = IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && ((fifo_tx_f_full == 1'b0 && fifo_tx_f_empty == 1'b0) || fifo_tx_f_full == 1'b1) && DATA_CONFIG_REG[1] == 1'b0 && count_timeout < TIMEOUT_TX)
		begin
			next_state_tx   = START;
		end


	end
	START://THIS IS USED TOO ALL STATE MACHINES THE COUNTER_SEND_DATA
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = START;
		end
		else
		begin
			next_state_tx   = CONTROLIN_1;
		end
		
	end
	CONTROLIN_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = CONTROLIN_1;
		end
		else
		begin
			next_state_tx  =  CONTROLIN_2;
		end

	end
	CONTROLIN_2:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = CONTROLIN_2;
		end
		else
		begin
			next_state_tx   = CONTROLIN_3;
		end

	end
	CONTROLIN_3:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  CONTROLIN_3;
		end
		else
		begin
			next_state_tx   = CONTROLIN_4;
		end		
	end
	CONTROLIN_4:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = CONTROLIN_4;
		end
		else
		begin
			next_state_tx   = CONTROLIN_5;
		end		
	end
	CONTROLIN_5:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_5;
		end
		else
		begin
			next_state_tx = CONTROLIN_6;
		end		
	end
	CONTROLIN_6:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_6;
		end
		else
		begin
			next_state_tx = CONTROLIN_7;
		end		
	end
	CONTROLIN_7:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_7;
		end
		else
		begin
			next_state_tx = CONTROLIN_8;
		end		
	end
	CONTROLIN_8:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = CONTROLIN_8;
		end
		else 
		begin
			next_state_tx  = RESPONSE_CIN;
		end		
	end
	RESPONSE_CIN:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = RESPONSE_CIN;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx = DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx = NACK;
		end	
		
	end

	//NOW SENDING ADDRESS
	ADDRESS_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = ADDRESS_1;
		end
		else
		begin
			next_state_tx  =  ADDRESS_2;
		end	
	end
	ADDRESS_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_2;
		end
		else
		begin
			next_state_tx = ADDRESS_3;
		end	
	end
	ADDRESS_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_3;
		end
		else
		begin
			next_state_tx = ADDRESS_4;
		end	
	end
	ADDRESS_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_4;
		end
		else
		begin
			next_state_tx = ADDRESS_5;
		end	
	end
	ADDRESS_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_5;
		end
		else
		begin
			next_state_tx = ADDRESS_6;
		end	
	end
	ADDRESS_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_6;
		end
		else
		begin
			next_state_tx = ADDRESS_7;
		end	
	end
	ADDRESS_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_7;
		end
		else
		begin
			next_state_tx = ADDRESS_8;
		end	
	end
	ADDRESS_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_8;
		end
		else
		begin
			next_state_tx = RESPONSE_ADDRESS;
		end	
	end
	RESPONSE_ADDRESS:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = RESPONSE_ADDRESS;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx = DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK --> RESTART CONDITION AND BACK TO START BYTE AGAIN
		begin
			next_state_tx = NACK;
		end	
	end
	
	//data in
	DATA0_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_1;
		end
		else
		begin
			next_state_tx = DATA0_2;
		end
	end
	DATA0_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_2;
		end
		else
		begin
			next_state_tx = DATA0_3;
		end
	end
	DATA0_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_3;
		end
		else
		begin
			next_state_tx = DATA0_4;
		end
	end
	DATA0_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_4;
		end
		else
		begin
			next_state_tx = DATA0_5;
		end
	end
	DATA0_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_5;
		end
		else
		begin
			next_state_tx   = DATA0_6;
		end
	end
	DATA0_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_6;
		end
		else
		begin
			next_state_tx  = DATA0_7;
		end
	end
	DATA0_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_7;
		end
		else
		begin
			next_state_tx  = DATA0_8;
		end
	end
	DATA0_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_8;
		end
		else
		begin
			next_state_tx  =  RESPONSE_DATA0_1;
		end
	end
	RESPONSE_DATA0_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx  =   NACK;
		end	
	end

	//second byte
	DATA1_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_1;
		end
		else
		begin
			next_state_tx  = DATA1_2;
		end
	end
	DATA1_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_2;
		end
		else
		begin
			next_state_tx = DATA1_3;
		end
	end
	DATA1_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_3;
		end
		else
		begin
			next_state_tx  =  DATA1_4;
		end
	end
	DATA1_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_4;
		end
		else
		begin
			next_state_tx  = DATA1_5;
		end
	end
	DATA1_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_5;
		end
		else
		begin
			next_state_tx = DATA1_6;
		end
	end
	DATA1_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  DATA1_6;
		end
		else
		begin
			next_state_tx  =  DATA1_7;
		end
	end
	DATA1_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx =  DATA1_7;
		end
		else
		begin
			next_state_tx =  DATA1_8;
		end
	end
	DATA1_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_8;
		end
		else
		begin
			next_state_tx = RESPONSE_DATA1_1;
		end
	end
	RESPONSE_DATA1_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   =  RESPONSE_DATA1_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx   =  DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx   =  NACK;
		end	
	end
	DELAY_BYTES://THIS FORM WORKS 
	begin

		
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx =  DELAY_BYTES;
		end
		else
		begin

			if(count_tx == 2'd0)
			begin
				next_state_tx = ADDRESS_1;
			end
			else if(count_tx   == 2'd1)
			begin
				next_state_tx = DATA0_1;
			end
			else if(count_tx   == 2'd2)
			begin
				next_state_tx = DATA1_1;
			end
			else if(count_tx   == 2'd3)
			begin
				next_state_tx = STOP;
			end
			
		end

	end
	NACK://NOT TESTED YET !!!!
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2]*2'd2)
		begin
			next_state_tx  = NACK;
		end
		else
		begin
			if(count_tx == 2'd0)
			begin
				next_state_tx = CONTROLIN_1;
			end
			else if(count_tx == 2'd1)
			begin
				next_state_tx = ADDRESS_1;
			end
			else if(count_tx  == 2'd2)
			begin
				next_state_tx   = DATA0_1;
			end
			else if(count_tx == 2'd3)
			begin
				next_state_tx = DATA1_1;
			end
		end
	end
	STOP://THIS WORK
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = STOP;
		end
		else
		begin
			next_state_tx = IDLE;
		end
	end
	default:
	begin
		next_state_tx =  IDLE;
	end
	endcase


end



//SEQUENTIAL   
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		//SIGNALS MUST BE RESETED
		count_send_data <= 12'd0;
		state_tx   <= IDLE;	
		SDA_OUT<= 1'b1;
		fifo_tx_rd_en <= 1'b0;
		count_tx   <= 2'd0;
		BR_CLK_O <= 1'b1;
		RESPONSE<= 1'b0;	
	end
	else
	begin
		
		// SEQUENTIAL FUN START
		state_tx  <= next_state_tx;

		case(state_tx)
		IDLE:
		begin

			fifo_tx_rd_en <= 1'b0;
			
 
			if(DATA_CONFIG_REG[0] == 1'b0 && (fifo_tx_f_full == 1'b1 ||fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b0)
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b1;
				BR_CLK_O <= 1'b1;
			end
			else if(DATA_CONFIG_REG[0] == 1'b1 && ((fifo_tx_f_empty == 1'b0 && fifo_tx_f_full == 1'b0 )|| fifo_tx_f_full == 1'b1 ) && DATA_CONFIG_REG[1] == 1'b0)
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=1'b0;			
			end
			else if(DATA_CONFIG_REG[0] == 1'b1 && (fifo_tx_f_full == 1'b1 ||fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b1)
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b1;
				BR_CLK_O <= 1'b1;
			end			

		end
		START:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				BR_CLK_O <= 1'b0;
			end
			else
			begin
				count_send_data <= 12'd0;					
			end	

			if(count_send_data == DATA_CONFIG_REG[13:2]- 12'd1)
			begin
				SDA_OUT<=fifo_tx_data_out[0:0];
				count_tx   <= 2'd0;
			end

		end
		CONTROLIN_1:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[0:0];	

								
				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[1:1];
			end

				
		end
		
		CONTROLIN_2:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[1:1];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[2:2];
			end
				
		end

		CONTROLIN_3:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[2:2];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[3:3];
			end	


				
		end
		CONTROLIN_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[3:3];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[4:4];
			end
				
		end

		CONTROLIN_5:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[4:4];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[5:5];
			end	

		end
		CONTROLIN_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[5:5];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[6:6];
			end	

				
		end

		CONTROLIN_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[6:6];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[7:7];
			end	

				
		end
		CONTROLIN_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[7:7];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b0;
			end

				
		end
		RESPONSE_CIN:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
			end	


		end
		ADDRESS_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[8:8];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[9:9];
			end	
				
		end		
		ADDRESS_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[9:9];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[10:10];
			end	

		end
		ADDRESS_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[10:10];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[11:11];
			end	

		end
		ADDRESS_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[11:11];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[12:12];
			end	
		end
		ADDRESS_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[12:12];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[13:13];
			end	

				
		end
		ADDRESS_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[13:13];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;		
				SDA_OUT<=fifo_tx_data_out[14:14];
			end	
				
		end
		ADDRESS_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[14:14];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[15:15];
			end	

				
		end
		ADDRESS_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[15:15];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_ADDRESS:
		begin
			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
			end

		end
		DATA0_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[16:16];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;				
				SDA_OUT<=fifo_tx_data_out[17:17];
			end	

				
		end
		DATA0_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[17:17];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[18:18];
			end	

				
		end		
		DATA0_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[18:18];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[19:19];
			end	
				
		end
		DATA0_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[19:19];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[20:20];
			end	
				
		end
		DATA0_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[20:20];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[21:21];
			end

		end
		DATA0_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[21:21];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[22:22];
			end
				
		end
		DATA0_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[22:22];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[23:23];
			end	
				
		end
		DATA0_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[23:23];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_DATA0_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
			end

		end
		DATA1_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[24:24];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[25:25];

			end

				
		end
		DATA1_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[25:25];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[26:26];
			end	

		end
		DATA1_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[26:26];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[27:27];
			end	
				
		end
		DATA1_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[27:27];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[28:28];
			end	
				
		end
		DATA1_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[28:28];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[29:29];
			end	
				
		end
		DATA1_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[29:29];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[30:30];
			end	
				
		end
		DATA1_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[30:30];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[31:31];
			end	

				
		end
		DATA1_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[31:31];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_DATA1_1:
		begin
			//fifo_  _rd_en <= 1'b1;

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				fifo_tx_rd_en <= 1'b1;
			end	

		end
		DELAY_BYTES:
		begin
			
			fifo_tx_rd_en <= 1'b0;
		
			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				
				count_send_data <= count_send_data + 12'd1;	
				BR_CLK_O <= 1'b0;
				SDA_OUT<=1'b0;		
			end
			else
			begin


				if(count_tx == 2'd0)
				begin
					count_tx <= count_tx + 2'd1;
					SDA_OUT<=fifo_tx_data_out[8:8];
				end
				else if(count_tx   == 2'd1)
				begin
					count_tx <= count_tx + 2'd1;
					SDA_OUT<=fifo_tx_data_out[16:16];
				end
				else if(count_tx == 2'd2)
				begin
					count_tx <= count_tx + 2'd1;
					SDA_OUT<=fifo_tx_data_out[24:24];
				end
				else if(count_tx == 2'd3)
				begin
					count_tx <= 2'd0;
				end

				count_send_data <= 12'd0;
			
			end

		end
		//THIS BLOCK MUST BE CHECKED WITH CARE
		NACK:// MORE A RESTART 
		begin
			fifo_tx_rd_en <= 1'b0;
		
			if(count_send_data < DATA_CONFIG_REG[13:2]*2'd3)
			begin		
				count_send_data <= count_send_data + 12'd1;
	
				if(count_receive_data < DATA_CONFIG_REG[13:2]/12'd2)
				begin
					SDA_OUT<=1'b0;
				end
				else if(count_send_data > DATA_CONFIG_REG[13:2]/12'd2-12'd1 && count_send_data < DATA_CONFIG_REG[13:2])
				begin
					SDA_OUT<=1'b1;
				end
				else if(count_send_data  == DATA_CONFIG_REG[13:2]*2'd2)
				begin
					SDA_OUT<=1'b0;
				end

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd2)
				begin
					BR_CLK_O <= 1'b1;
				end
				else if(count_send_data > DATA_CONFIG_REG[13:2]/12'd2-12'd1 && count_send_data < DATA_CONFIG_REG[13:2])
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data < DATA_CONFIG_REG[13:2]*2'd2)
				begin
					BR_CLK_O <= 1'b1;
				end
		
			end
			else
			begin
				count_send_data <= 12'd0;

				if(count_tx == 2'd0)
				begin
					count_tx <= 2'd0;
					SDA_OUT<=fifo_tx_data_out[0:0];
				end
				else if(count_tx == 2'd1)
				begin
					count_tx <= 2'd1;
					SDA_OUT<=fifo_tx_data_out[8:8];
				end
				else if(count_tx == 2'd2)
				begin
					count_tx <= 2'd2;
					SDA_OUT<=fifo_tx_data_out[16:16];
				end
				else if(count_tx == 2'd3)
				begin
					count_tx <= 2'd3;
					SDA_OUT<=fifo_tx_data_out[24:24];
				end

			
			end
		end
		STOP:
		begin

			BR_CLK_O <= 1'b1;

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd2-12'd2)
				begin
					SDA_OUT<=1'b0;
				end
				else if(count_send_data > DATA_CONFIG_REG[13:2]/12'd2-12'd1 && count_send_data < DATA_CONFIG_REG[13:2])
				begin
					SDA_OUT<=1'b1;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
			end
		end
		default:
		begin
			fifo_tx_rd_en <= 1'b0;
			count_send_data <= 12'd4095;
		end
		endcase
		
	end


end 


	//STATE CONTROL 
	reg [5:0] state_rx;
	reg [5:0] next_state_rx;

assign ENABLE_SDA = (state_rx ==  RESPONSE_CIN|| 
		     state_rx ==  RESPONSE_ADDRESS|| 
		     state_rx == RESPONSE_DATA0_1|| 
		     state_rx == RESPONSE_DATA1_1)?1'b1:
		    (state_tx ==  RESPONSE_CIN|| 
		     state_tx ==  RESPONSE_ADDRESS|| 
		     state_tx == RESPONSE_DATA0_1|| 
		     state_tx == RESPONSE_DATA1_1)?1'b0:1'b1;


assign ENABLE_SCL = (state_rx ==  RESPONSE_CIN|| 
		     state_rx ==  RESPONSE_ADDRESS|| 
		     state_rx == RESPONSE_DATA0_1|| 
		     state_rx == RESPONSE_DATA1_1)?1'b1:
		    (state_tx ==  RESPONSE_CIN|| 
		     state_tx ==  RESPONSE_ADDRESS|| 
		     state_tx == RESPONSE_DATA0_1|| 
		     state_tx == RESPONSE_DATA1_1)?1'b1:1'b0;


//COMBINATIONAL BLOCK TO RX
always@(*)
begin

	//THE FUN START HERE :-)
	//COMBINATIONAL UPDATE STATE BE CAREFUL WITH WHAT YOU MAKE HERE
	next_state_rx = state_rx;

	case(state_rx)//state_rx IS MORE SECURE CHANGE ONLY IF YOU KNOW WHAT ARE YOU DOING 
	IDLE:
	begin
		//OBEYING SPEC
		if(DATA_CONFIG_REG[0] == 1'b0 && DATA_CONFIG_REG[1] == 1'b0)
		begin
			next_state_rx =   IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && DATA_CONFIG_REG[1] == 1'b1)
		begin
			next_state_rx =   IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b0 && DATA_CONFIG_REG[1] == 1'b1 && SDA_OUT_RX == 1'b0 && BR_CLK_O_RX == 1'b0)
		begin
			next_state_rx =   START;
		end


	end
	START://THIS IS USED TOO ALL STATE MACHINES THE COUNTER_SEND_DATA
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   START;
		end
		else if(fifo_rx_data_in[0] == 1'b0 && fifo_rx_data_in[1] == 1'b0)
		begin
			next_state_rx =   CONTROLIN_1;
		end
		else 
		begin
			next_state_rx =   IDLE;
		end
		
	end
	  CONTROLIN_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_1;
		end
		else
		begin
			next_state_rx =   CONTROLIN_2;
		end

	end
	  CONTROLIN_2:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_2;
		end
		else
		begin
			next_state_rx =   CONTROLIN_3;
		end

	end
	  CONTROLIN_3:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_3;
		end
		else
		begin
			next_state_rx =   CONTROLIN_4;
		end		
	end
	  CONTROLIN_4:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_4;
		end
		else
		begin
			next_state_rx =   CONTROLIN_5;
		end		
	end
	  CONTROLIN_5:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_5;
		end
		else
		begin
			next_state_rx =   CONTROLIN_6;
		end		
	end
	  CONTROLIN_6:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_6;
		end
		else
		begin
			next_state_rx =   CONTROLIN_7;
		end		
	end
	  CONTROLIN_7:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_7;
		end
		else
		begin
			next_state_rx =   CONTROLIN_8;
		end		
	end
	  CONTROLIN_8:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_8;
		end
		else 
		begin
			next_state_rx =   RESPONSE_CIN;
		end		
	end
	RESPONSE_CIN:
	begin

		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_CIN;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end
		
	end
	//NOW SENDING ADDRESS
	ADDRESS_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_1;
		end
		else
		begin
			next_state_rx =   ADDRESS_2;
		end	
	end
	ADDRESS_2:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_2;
		end
		else
		begin
			next_state_rx =   ADDRESS_3;
		end	
	end
	ADDRESS_3:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_3;
		end
		else
		begin
			next_state_rx =   ADDRESS_4;
		end	
	end
	ADDRESS_4:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_4;
		end
		else
		begin
			next_state_rx =   ADDRESS_5;
		end	
	end
	ADDRESS_5:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_5;
		end
		else
		begin
			next_state_rx =   ADDRESS_6;
		end	
	end
	ADDRESS_6:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_6;
		end
		else
		begin
			next_state_rx =   ADDRESS_7;
		end	
	end
	ADDRESS_7:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_7;
		end
		else
		begin
			next_state_rx =   ADDRESS_8;
		end	
	end
	ADDRESS_8:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_8;
		end
		else
		begin
			next_state_rx =   RESPONSE_ADDRESS;
		end	
	end
	RESPONSE_ADDRESS:
	begin
		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_ADDRESS;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end
	end
	//data in
	DATA0_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_1;
		end
		else
		begin
			next_state_rx =   DATA0_2;
		end
	end
	  DATA0_2:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_2;
		end
		else
		begin
			next_state_rx =   DATA0_3;
		end
	end
	  DATA0_3:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_3;
		end
		else
		begin
			next_state_rx =   DATA0_4;
		end
	end
	  DATA0_4:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_4;
		end
		else
		begin
			next_state_rx =   DATA0_5;
		end
	end
	  DATA0_5:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_5;
		end
		else
		begin
			next_state_rx =   DATA0_6;
		end
	end
	  DATA0_6:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_6;
		end
		else
		begin
			next_state_rx =   DATA0_7;
		end
	end
	  DATA0_7:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_7;
		end
		else
		begin
			next_state_rx =   DATA0_8;
		end
	end
	  DATA0_8:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_8;
		end
		else
		begin
			next_state_rx =   RESPONSE_DATA0_1;
		end
	end
	RESPONSE_DATA0_1:
	begin

		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end	
	end
	//second byte
	DATA1_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_1;
		end
		else
		begin
			next_state_rx =   DATA1_2;
		end
	end
	DATA1_2:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_2;
		end
		else
		begin
			next_state_rx =   DATA1_3;
		end
	end
	DATA1_3:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_3;
		end
		else
		begin
			next_state_rx =   DATA1_4;
		end
	end
	  DATA1_4:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_4;
		end
		else
		begin
			next_state_rx =   DATA1_5;
		end
	end
	  DATA1_5:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_5;
		end
		else
		begin
			next_state_rx =   DATA1_6;
		end
	end
	  DATA1_6:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_6;
		end
		else
		begin
			next_state_rx =   DATA1_7;
		end
	end
	  DATA1_7:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_7;
		end
		else
		begin
			next_state_rx =   DATA1_8;
		end
	end
	  DATA1_8:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_8;
		end
		else
		begin
			next_state_rx =   RESPONSE_DATA1_1;
		end
	end
	RESPONSE_DATA1_1:
	begin
		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end	
	
	end
	DELAY_BYTES://THIS FORM WORKS 
	begin

		
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DELAY_BYTES;
		end
		else
		begin

			if(count_rx == 2'd0)
			begin
				next_state_rx =   ADDRESS_1;
			end
			else if(count_rx == 2'd1)
			begin
				next_state_rx =   DATA0_1;
			end
			else if(count_rx == 2'd2)
			begin
				next_state_rx =   DATA1_1;
			end
			else if(count_rx == 2'd3)
			begin
				next_state_rx =   STOP;
			end
			
		end

	end
	  STOP://THIS WORK
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   STOP;
		end
		else
		begin
			next_state_rx =   IDLE;
		end
	end
	default:
	begin
			next_state_rx =   IDLE;
	end
	endcase


end



//SEQUENTIAL   
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		//SIGNALS MUST BE RESETED
		  count_receive_data <= 12'd0;
		state_rx <=   IDLE;	
		SDA_OUT_RX<= 1'b0;
		fifo_rx_wr_en <= 1'b0;
		count_rx <= 2'd0;
		BR_CLK_O_RX <= 1'b0;	
	end
	else 
	begin
		
		// SEQUENTIAL FUN START
		state_rx <= next_state_rx;

		case(state_rx)
		  IDLE:
		begin



			if(((fifo_rx_f_full == 1'b0 && fifo_rx_f_empty == 1'b0) || (fifo_rx_f_full == 1'b0 && fifo_rx_f_empty == 1'b1)) && DATA_CONFIG_REG[1] == 1'b1)
			begin

				  SDA_OUT_RX<= SDA;
				  BR_CLK_O_RX<=SCL;
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  SDA_OUT_RX<= SDA_OUT_RX;
				  BR_CLK_O_RX<=BR_CLK_O_RX;
				  count_receive_data <=   count_receive_data;		
			end
	
		end
		  START:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(  count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[0]<= SDA;
				fifo_rx_data_in[1]<= SCL;			
			end

		end
		  CONTROLIN_1:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[0]<= SDA;			
			end

		end		
		  CONTROLIN_2:
		begin
	
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[1]<= SDA;			
			end
				
		end
		  CONTROLIN_3:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end


			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[2]<= SDA;			
			end

		
		end
		  CONTROLIN_4:
		begin
	
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[3]<= SDA;			
			end
				
		end
		  CONTROLIN_5:
		begin

			
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
					fifo_rx_data_in[4]<= SDA;			
			end
		

		end
		  CONTROLIN_6:
		begin
				if(  count_receive_data < DATA_CONFIG_REG[13:2])
				begin
					  count_receive_data <=   count_receive_data + 12'd1;
				end
				else
				begin
					  count_receive_data <= 12'd0;
				end

				if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					fifo_rx_data_in[5]<= SDA;			
				end		
		end

		  CONTROLIN_7:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[6]<= SDA;			
			end
		end
		  CONTROLIN_8:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[7]<= SDA;			
			end
	

				
		end
		  RESPONSE_CIN:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

		end
		  ADDRESS_1:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[8]<= SDA;			
			end
	
				
		end		
		  ADDRESS_2:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[9]<= SDA;			
			end
	

		end
		  ADDRESS_3:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[10]<= SDA;			
			end
	
	

		end
		  ADDRESS_4:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[11]<= SDA;			
			end
	
		end
		  ADDRESS_5:
		begin


				
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[12]<= SDA;			
			end

					
		end
		  ADDRESS_6:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[13]<= SDA;			
			end
	
		end
		  ADDRESS_7:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[14]<= SDA;			
			end
				
		end
		  ADDRESS_8:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[15]<= SDA;			
			end

				
		end
		  RESPONSE_ADDRESS:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end


		end
		  DATA0_1:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[16]<= SDA;			
			end
	

				
		end
		  DATA0_2:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[17]<= SDA;			
			end
	
				
		end		
		  DATA0_3:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[18]<= SDA;			
			end
				
		end
		  DATA0_4:
		begin



			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[19]<= SDA;			
			end
	
		end
		  DATA0_5:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[20]<= SDA;			
			end


		end
		  DATA0_6:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[21]<= SDA;			
			end
	
		end
		  DATA0_7:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[22]<= SDA;			
			end
				
		end
		  DATA0_8:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[23]<= SDA;			
			end
		
		end
		  RESPONSE_DATA0_1:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

		end
		  DATA1_1:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[24]<= SDA;			
			end
				
		end
		  DATA1_2:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[25]<= SDA;			
			end


		end
		  DATA1_3:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[26]<= SDA;			
			end

				
		end
		  DATA1_4:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[27]<= SDA;			
			end
	
				
		end
		  DATA1_5:
		begin



			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[28]<= SDA;			
			end
	
				
		end
		  DATA1_6:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[29]<= SDA;			
			end


				
		end
		  DATA1_7:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[30]<= SDA;			
			end


				
		end
		  DATA1_8:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[31]<= SDA;			
			end
				
		end
		RESPONSE_DATA1_1:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end
			//fifo_  _rd_en <= 1'b1;

		end
		DELAY_BYTES:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin


				if(count_rx == 2'd0)
				begin
					count_rx <= count_rx + 2'd1;
					//SDA_OUT<=fifo_tx_data_out[8:8];
				end
				else if(count_rx   == 2'd1)
				begin
					count_rx <= count_tx + 2'd1;
					//SDA_OUT<=fifo_tx_data_out[16:16];
				end
				else if(count_rx == 2'd2)
				begin
					count_rx <= count_rx + 2'd1;
					//SDA_OUT<=fifo_tx_data_out[24:24];
				end
				else if(count_rx == 2'd3)
				begin
					count_rx <= 2'd0;
				end

				count_receive_data <= 12'd0;
			
			end


		end
		STOP:
		begin
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end
			fifo_rx_wr_en <= 1'b0;
		end
		default:
		begin
			fifo_rx_wr_en <= 1'b0;
			  count_receive_data <= 12'd4095;
		end
		endcase
		
	end


end 

//USED ONLY TO COUNTER TIME
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		count_timeout <= 12'd0;
	end
	else
	begin
		if(count_timeout <= TIMEOUT_TX && state_tx == IDLE)
		begin
			if(SDA == 1'b0 && SCL == 1'b0)
			count_timeout <= count_timeout + 12'd1;
		end
		else
		begin
			count_timeout <= 12'd0;
		end

	end

end


endmodule
","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""the flag that indicates whether the RX FIFO is empty"",
      ""RX_EMPTY"": ""the output signal reflecting the empty status of the RX FIFO""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between the two operands"",
      ""|->"": ""implies that if the antecedent is true then the consequent must be true in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the flag indicating that the RX FIFO is empty evaluates to true then, in the next cycle, the output signal reflecting the RX empty status must also be true""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""the flag that indicates whether the RX FIFO is empty"",
      ""RX_EMPTY"": ""the output signal reflecting the empty status of the RX FIFO""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between the two operands"",
      ""|->"": ""implies that if the antecedent is true then the consequent must be true in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the flag indicating that the RX FIFO is empty is false then, in the next cycle, the output signal reflecting the RX empty status must also be false""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""the flag that indicates whether the RX FIFO is empty"",
      ""RX_EMPTY"": ""the output signal reflecting the empty status of the RX FIFO""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between the two operands"",
      ""|->"": ""implies that if the antecedent is true then the consequent must be true in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the flag indicating that the RX FIFO is empty evaluates to true then, in the next cycle, the output signal reflecting the RX empty status must also be true""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""the flag that indicates whether the RX FIFO is empty"",
      ""RX_EMPTY"": ""the output signal reflecting the empty status of the RX FIFO""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between the two operands"",
      ""|->"": ""implies that if the antecedent is true then the consequent must be true in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the flag indicating that the RX FIFO is empty is false then, in the next cycle, the output signal reflecting the RX empty status must also be false""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(DATA_CONFIG_REG[1] == 0) |-> (ERROR == 0)"",
    ""Signals"": [
      ""DATA_CONFIG_REG[1]"",
      ""ERROR""
    ],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[1]"": ""bit 1 of the register configuration signal used to determine operating modes"",
      ""ERROR"": ""the signal that indicates an error condition in the module""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between the two operands"",
      ""|->"": ""implies that if the cause condition is met then the result condition must hold in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the second bit of the configuration register indicates a value of zero then, in the following cycle, the error signal must be zero""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(DATA_CONFIG_REG[0] == 0) |-> (ERROR == 0)"",
    ""Signals"": [
      ""DATA_CONFIG_REG[0]"",
      ""ERROR""
    ],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[0]"": ""bit 0 of the register configuration signal that selects operational aspects of the module"",
      ""ERROR"": ""the signal that indicates an error condition in the module""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between two operands"",
      ""|->"": ""indicates that if the condition on the left side holds then the right side must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the first bit of the configuration register equals zero then, in the subsequent cycle, the error signal must also equal zero""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(DATA_CONFIG_REG[0] == 1 & DATA_CONFIG_REG[1] == 1) |-> (ERROR == 1)"",
    ""Signals"": [
      ""DATA_CONFIG_REG[0]"",
      ""DATA_CONFIG_REG[1]"",
      ""ERROR""
    ],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[0]"": ""bit 0 of the register configuration signal that selects operational aspects of the module"",
      ""DATA_CONFIG_REG[1]"": ""bit 1 of the register configuration signal used to determine operating modes"",
      ""ERROR"": ""the signal that indicates an error condition in the module""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between two operands"",
      ""&"": ""performs a logical AND between the conditions"",
      ""|->"": ""implies that if the compound condition on the left is true then the condition on the right must be true in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if both the first and second bits of the configuration register are set to one then, in the following cycle, the error signal must be one""
  }
}","{
""Assertion 1"": ""assert property (fifo_rx_f_empty == 1'b1 |-> fifo_rx_empty == 1'b1);"",
""Assertion 2"": ""assert property (fifo_rx_f_empty == 1'b0 |-> RX_EMPTY == 1'b0);"",
""Assertion 3"": ""assert property (fifo_rx_f_empty == 1'b1 |-> (RX_EMPTY == 1'b1));"",
""Assertion 4"": ""assert property (fifo_rx_f_empty == 1'b0 |-> fifo_rx_f_empty == 1'b0);"",
""Assertion 5"": ""assert property (DATA_CONFIG_REG[1] == 1'b0 |=> ERROR == 1'b0);"",
""Assertion 6"": ""assert property (DATA_CONFIG_REG[0] == 1'b0 |-> (ERROR == 1'b0));"",
""Assertion 7"": ""assert property (DATA_CONFIG_REG[0] == 1'b1 && DATA_CONFIG_REG[1] == 1'b1 |-> ERROR == 1'b1);""
}"
delay2,"module delay2 
#(
          parameter N = 750, 
          parameter CBITS = 10
) 
(input clk, input rst, output reg sig);
  reg [CBITS-1 :0] cnt;
  always @(posedge clk) begin
    if (rst) cnt = 0;
    else cnt = cnt + 1;
    if (cnt > N) begin sig = 1;
      cnt = 0; end
    else sig = 0;
  end

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""rst || sig == 1"",
""Signals"": [""rst"", ""sig""],
""Signal Explanations"": {
          ""rst"": ""the reset signal that reinitializes the counter when active"",
          ""sig"": ""the output signal that is set to 1 when the counter exceeds the parameter N""
},
""Logical Operators"": [""||"", ""==""],
""Logical Operators Explanation"": {
          ""||"": ""logical OR operator that results true if at least one of its operands is true"",
          ""=="": ""equality operator that checks if two values are identical""
},
""Assertion Explaination"": ""ensures that eventually either the condition of the reset being active is met or the condition of the output signal matching the active state is satisfied, meaning that either a reset occurs or the delayed output becomes active""
}
}","{
""Assertion 1"": ""assert property (rst || (sig == 1));""
}"
simple_req_ack,"module simple_req_ack (
	input  clk,
	input  rst_n,

	input  req,
	output ack
);
	logic req_ff, ack_ff;

	always_ff @(negedge rst_n, posedge clk)
		if (!rst_n)
			req_ff <= '0;
		else
			if (req_ff)
				req_ff <= '0;
			else
				req_ff <= req;

	always_ff @(negedge rst_n, posedge clk)
		if (!rst_n)
			ack_ff <= '0;
		else
		if (ack_ff)
			ack_ff <= '0;
		else
		if (req_ff)
			ack_ff <= '1;

	assign ack = ack_ff;

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff(!rst_n)"",
""logical expression"": ""$rose(req) |-> ##2 $rose(ack)"",
""Signals"": [""req"", ""ack""],
""Signal Explanations"": {
  ""req"": ""input request signal of the verilog module"",
  ""ack"": ""output acknowledgement signal of the verilog module""
},
""Logical Operators"": [""$rose"", ""|->"", ""##2""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects when a signal makes a rising (positive) transition"",
  ""|->"": ""non-overlapping implication, meaning if the antecedent is true the consequent must hold after the specified delay"",
  ""##2"": ""indicates a delay of two clock cycles before evaluating the consequent""
},
""Assertion Explaination"": ""if a rising edge is detected on the input request signal, then two clock cycles later a rising edge must be detected on the output acknowledgement signal""
}
}","{
""Assertion 1"": ""assert property (req[1] |-> (ack[1] ##1 ack[1]));""
}"
Gray_Code_Counter,"module Gray_Code_Counter #(parameter
  DATA_WIDTH = 4
) (
  input clk,
  input resetn,
  output logic [DATA_WIDTH-1:0] out
);

reg  [DATA_WIDTH-1:0] bin_q;	
wire [DATA_WIDTH-1:0] bin_next;	
wire                  unused_bin_inc;
reg  [DATA_WIDTH-1:0] gray_q;	
wire [DATA_WIDTH-1:0] gray_next;	

always @(posedge clk)
begin
	if(~resetn) begin
		bin_q  <= {DATA_WIDTH{1'd1}};;
		gray_q <= {DATA_WIDTH{1'd0}};
	end else begin
		bin_q  <= bin_next;
		gray_q <= gray_next;
	end
end

assign { unused_bin_inc, bin_next } = bin_q + {DATA_WIDTH{1'd1}};
assign gray_next = bin_q ^ ( bin_q >> 1 );

assign out = gray_q;

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (~resetn)"",
""logical expression"": ""unused_bin_inc | $onehot(gray_next ^ gray_q)"",
""Signals"": [""unused_bin_inc"", ""gray_next"", ""gray_q""],
""Signal Explanations"": {
  ""unused_bin_inc"": ""carry-out bit from the binary counter addition that is not used"",
  ""gray_next"": ""next computed Gray code resulting from the binary-to-Gray conversion"",
  ""gray_q"": ""current Gray code state stored in the register and assigned to the output""
},
""Logical Operators"": [""|"", ""$onehot"", ""^""],
""Logical Operators Explanation"": {
  ""|"": ""logical OR operator that returns true when at least one operand is true"",
  ""$onehot"": ""built-in function that returns true if exactly one bit in its operand is set"",
  ""^"": ""bitwise XOR operator that yields true for bits that differ""
},
""Assertion Explaination"": ""Either the unutilized carry-out bit from the binary addition is asserted or the condition that verifies exactly one bit difference between the upcoming Gray code (computed from the binary counter) and the current Gray code holds""
}
}","{
""Assertion 1"": ""assert property (unused_bin_inc || (gray_next != gray_q && (gray_next & (gray_next - 1)) == 0));""
}"
uartTrans,"////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16


module uartTrans (clk, reset, sTick, txDoneTick, din, tx, txStart);

		parameter dataBits = `dataBits;
		parameter sbTick = `sbTick;
		
		input [dataBits-1 :0] din;
		input clk, reset, sTick, txStart;
		output tx, txDoneTick;
		
		reg txDoneTick;
		
/*
should be impleneted as a 4-state FSM : idle, start, data, stop;

*/

	localparam [1:0] idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11;
	
		reg [1:0] stateReg, stateNext;	// current and next states
		reg [3:0] sReg, sNext;		//	counter
		reg [2:0] nReg, nNext;		// counter
		reg [7:0] bReg, bNext;		// perhaps keeps data to be sent
		reg		 txReg, txNext;	// current bit being transferred
		
		
		//	reset and non-reset conditions:
		
		always @ (posedge clk or posedge reset)
		begin
			if (reset)
			begin
				stateReg <= idle;
				sReg <= 1'b0;
				bReg <= 1'b0;
				nReg <= 1'b0;
				txReg <= 1'b1;
			end	// end if
			
			else
			begin
				stateReg <= stateNext;
				sReg <= sNext;
				bReg <= bNext;
				nReg <= nNext;
				txReg <= txNext;
			end	// end else
		
		end	// end always
		
		// FSM:
		
		always @ *
		begin
				stateNext = stateReg;
				sNext = sReg;
				bNext = bReg;
				nNext = nReg;
				txNext = txReg;
				
				txDoneTick = 1'b0;		// not done yet!
				
			case	(stateReg)
			
				idle	:	begin
								txNext = 1'b1;	// start bit '0'; thus, send '1' in idle
								
								if (txStart)
								begin
									txDoneTick = 1'b1;	// generate rd for fifo **
									stateNext = start;	// should go into start state
									sNext = 0;
								end	// end if txStart
							// in idle state unless txStart...
							end	// end idle case
							
				start	:	begin
								txNext = 0;
								txDoneTick = 1'b0;		// **
								bNext = din;		// take din into bReg
								if (sTick)
									if (sReg == 15)
									begin
										stateNext = data;
										sNext = 1'b0;
										nNext = 1'b0;
									end	// end if sReg==15
									
									else
										sNext = sReg + 1;	// keep incrementing sNext (sReg)
										// sReg = sNext on each clk edge !!
							end	// end start case
							
				data	:	begin
								txNext = bReg[0];	// keep sending LSB of bReg
								
								if (sTick)
									if (sReg == 15)
									begin
										sNext = 0;	// reset counter
										bNext = bReg >> 1;	// shift word to be sent
										
										if (nReg == (dataBits-1))
											stateNext = stop;
										else
											nNext = nReg +1;
									end	// end if sReg==15
								else
									sNext = sReg + 1;
				
							end	// end data state
							
				stop	:	begin
								txNext = 1'b1;
								
								if (sTick)
									if (sReg == sbTick-1)
									begin
										stateNext = idle;
										//txDoneTick = 1'b1; it's working as read signal to
										// fifo, so, used at starting . . .
									end //end if sReg==15
									else
										sNext = sReg + 1;
							end	// end stop state
			
			endcase
		
		end	// end always combinatorial

		
		// output bit-stream
		
		assign tx = txReg;

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""none"",
""logical expression"": ""(txNext == 0) |=> (tx == 0)"",
""Signals"": [""txNext"", ""tx""],
""Signal Explanations"": {
  ""txNext"": ""the combinatorial next value computed for the transmission bit"",
  ""tx"": ""the actual transmission bit output of the module""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""checks equality"",
  ""|=>"": ""non-overlapping implication meaning that if the condition on the left is true at a clock edge, then the condition on the right must hold at the next relevant clock cycle""
},
""Assertion Explaination"": ""if the computed next value for the transmission bit is equal to the low level then in the subsequent clock cycle the actual transmission bit output must be low""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""none"",
""logical expression"": ""(txNext == 1) |=> (tx == 1)"",
""Signals"": [""txNext"", ""tx""],
""Signal Explanations"": {
  ""txNext"": ""the combinatorial next value computed for the transmission bit"",
  ""tx"": ""the actual transmission bit output of the module""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""checks equality"",
  ""|=>"": ""non-overlapping implication meaning that if the condition on the left is true at a clock edge, then the condition on the right must hold at the next relevant clock cycle""
},
""Assertion Explaination"": ""if the computed next value for the transmission bit is equal to the high level then in the subsequent clock cycle the actual transmission bit output must be high""
},
""Assertion 3"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""none"",
""logical expression"": ""(stateReg[0] == 1) |-> (txDoneTick == 0)"",
""Signals"": [""stateReg[0]"", ""txDoneTick""],
""Signal Explanations"": {
  ""stateReg[0]"": ""the least significant bit of the current finite state machine state register"",
  ""txDoneTick"": ""the flag indicating the completion of the transmission operation""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""checks equality"",
  ""|->"": ""overlapping implication meaning that if the condition on the left is true, then the condition on the right must be true concurrently at the same clock cycle""
},
""Assertion Explaination"": ""if the least significant bit of the current state is equal to high then at that same clock cycle the flag signaling transmission completion must be low""
},
""Assertion 4"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""none"",
""logical expression"": ""(txStart == 0) |-> (txDoneTick == 0)"",
""Signals"": [""txStart"", ""txDoneTick""],
""Signal Explanations"": {
  ""txStart"": ""the signal indicating the start of a transmission operation"",
  ""txDoneTick"": ""the flag indicating the completion of the transmission operation""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""checks equality"",
  ""|->"": ""overlapping implication meaning that if the condition on the left is true, then the condition on the right must be true concurrently at the same clock cycle""
},
""Assertion Explaination"": ""if the transmission start signal is low then at the same clock cycle the transmission completion flag must also be low""
}
}","{
""Assertion 1"": ""assert property (txNext == 1'b0 |-> tx == 1'b0);"",
""Assertion 2"": ""assert property (txNext == 1'b1 |-> tx == 1'b1);"",
""Assertion 3"": ""assert property (stateReg[0] == 1'b1 -> txDoneTick == 1'b0);"",
""Assertion 4"": ""assert property (txStart == 1'b0 |-> txDoneTick == 1'b0);""
}"
i2c,"module i2c #(parameter divider = 125, parameter CBITS = 9) (input clk, input rst, input scl_not_ena, output reg data_clk);
	reg [CBITS - 1:0] cnt;	//0 to 4*divider
	reg scl_clk;
	reg stretch;
	always @(posedge clk) begin
		if(rst == 1) begin
			stretch = 0;
			cnt = 0;
		end
		if(cnt >= divider*4 - 1)
			cnt = 0;
		else if(stretch == 0)
			cnt = cnt + 1;

		if( cnt <= divider - 1) begin
			scl_clk = 0;
			data_clk = 0;
		end
		else if( divider <= cnt && cnt <= 2*divider - 1) begin
			scl_clk = 0;
			data_clk = 1;
		end
		else if( 2*divider <= cnt && cnt <= 3*divider - 1) begin
			if(scl_clk == 0 & scl_not_ena == 0)
				stretch = 1;
			else
				stretch = 0;
			scl_clk = 1;
			data_clk = 1;
		end
		else begin
			scl_clk = 1;
			data_clk = 0;
		end
	end

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""s_eventually rst == 1 || scl_not_ena == 1 || stretch == 1"",
    ""Signals"": [
      ""rst"",
      ""scl_not_ena"",
      ""stretch""
    ],
    ""Signal Explanations"": {
      ""rst"": ""reset input signal"",
      ""scl_not_ena"": ""input signal that controls whether the serial clock line is enabled"",
      ""stretch"": ""flag register indicating if clock stretching is active""
    },
    ""Logical Operators"": [
      ""s_eventually"",
      ""=="",
      ""||""
    ],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""asserts that eventually, in the future, the specified condition holds true"",
      ""=="": ""checks if the value is equal to"",
      ""||"": ""logical OR operator combining conditions""
    },
    ""Assertion Explaination"": ""Eventually, it is required that either the reset input becomes active (equal to 1) or the control for enabling the serial clock line becomes active (equal to 1) or the flag indicating active clock stretching is set (equal to 1)""
  }
}","{
""Assertion 1"": ""assert property (rst == 1 || scl_not_ena == 1 || stretch == 1);""
}"
uartRec,"////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16


module uartRec(clk, reset, sTick, rx, rxDoneTick, dOut);

		parameter dataBits = `dataBits;
		parameter sbTick = `sbTick;
		
		input clk, reset, sTick, rx;
		output rxDoneTick;
		output [dataBits-1:0] dOut;
		
		reg rxDoneTick;
		// states:
		
	localparam idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11;
	
		reg [1:0] stateReg, stateNext;	// current and next states
		reg [3:0] sReg, sNext;		//	counter
		reg [2:0] nReg, nNext;		// counter
		reg [7:0] bReg, bNext;		// data recieved in this..
		
		
		always @ (posedge clk or posedge reset)
		begin
			if (reset)
			begin
				stateReg <= idle;
				sReg <= 1'b0;
				bReg <= 1'b0;
				nReg <= 1'b0;
			end	// end if
			
			else
			begin
				stateReg <= stateNext;
				sReg <= sNext;
				bReg <= bNext;
				nReg <= nNext;
			end	// end else
		
		end	// end always
		
		
		
		// FSM next state logic:
		
		always @ *
		begin
		
				stateNext = stateReg;
				sNext = sReg;
				bNext = bReg;
				nNext = nReg;
				rxDoneTick = 1'b0;
				
			case (stateReg)
			
			idle	:	if (~rx)
						begin
							stateNext = start;	// start when rx is activated
							sNext = 0;	// initialize sampling counter
						end	// end if rx
						
			start	:	if (sTick)
							if (sReg == 7)
							begin
								stateNext = data;		// at middle of oversampled start
													// bit, go to data state
								sNext = 0;
								nNext = 0;
							end	// end if sReg==7
							
							else
								sNext = sReg + 1;	// otherwise keep increment sReg upto 7
			
			data	:	if (sTick)
							if (sReg == 15)	// if reached middle of next bit
							begin
								sNext = 0;	// reset counter
								bNext = {rx, bReg[7:1]};	// LSB first, and the
														//data recieved in bReg
								if (nReg == (dataBits-1))	// if all data recvd,
									stateNext = stop;	// go to stop bit(s) state
								else
									nNext = nReg + 1;
							end	// end if sReg==15
							
							else
								sNext = sReg + 1;	// otherwise keep increment sReg upto 15
							
			stop	:	if (sTick)
							if (sReg == (sbTick-1))
							begin
								stateNext = idle;		// done reception, go to idle state
								rxDoneTick = 1'b1;	// raise done tick!
							end	// end if sReg==sbTick-1
							
							else
								sNext = sReg + 1;		// otherwise keep increment sReg 
															//upto (sbTick-1)
			endcase
		
		end	// end always combinatorial
		
		
		// recvd data output
		
		assign dOut = bReg;


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(stateReg[0] == 0) |-> (rxDoneTick == 0)"",
    ""Signals"": [
      ""stateReg[0]"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""stateReg[0]"": ""the least significant bit of the register holding the current finite‐state machine state of the receiver"",
      ""rxDoneTick"": ""the indicator signal that flags the completion of a UART reception""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""tests equality between two values"",
      ""|->"": ""non-overlapping implication operator meaning that if the left‐hand condition holds at the current cycle then the right-hand condition is expected to hold starting at the next relevant evaluation""
    },
    ""Assertion Explaination"": ""if the bit representing the current state’s least significant portion is inactive then, in the subsequent evaluation, the indicator for completed reception must also be inactive""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sReg[2] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sReg[2]"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sReg[2]"": ""the third bit of the register that counts the number of sampling ticks during oversampling"",
      ""rxDoneTick"": ""the signal that designates when the reception process has successfully completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|=>"": ""overlapping implication operator meaning that if the left-hand condition is true, then the right-hand condition must hold concurrently in the same cycle""
    },
    ""Assertion Explaination"": ""if the specified bit of the oversampling counter is inactive then concurrently the completion indicator for reception must also be inactive""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sReg[1] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sReg[1]"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sReg[1]"": ""the second bit of the oversampling counter register used to time the sampling process"",
      ""rxDoneTick"": ""the flag signal that indicates finalization of the reception process""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""tests for equality between the two compared values"",
      ""|=>"": ""represents an overlapping implication stating that if the condition on the left is met, then the condition on the right should hold in the same evaluation cycle""
    },
    ""Assertion Explaination"": ""if the bit corresponding to the mid-order portion of the oversampling counter is inactive then the reception complete indicator must be inactive at that moment""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(nReg[1] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""nReg[1]"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""nReg[1]"": ""the second bit of the register counting the number of received data bits"",
      ""rxDoneTick"": ""the signal that signifies the end of the UART data reception""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""indicates equality between the compared value and zero"",
      ""|=>"": ""implies that when the left-hand condition is met, the right-hand condition must hold in the same clock cycle""
    },
    ""Assertion Explaination"": ""if the bit from the data bit counter is inactive then, at that same moment, the indicator for completed reception must also be inactive""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(nReg[0] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""nReg[0]"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""nReg[0]"": ""the least significant bit of the register tracking the count of received data bits"",
      ""rxDoneTick"": ""the signal indicating that the reception process has been finalized""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies that both sides are equal"",
      ""|=>"": ""denotes overlapping implication meaning that if the left-hand condition is true then the right-hand condition must also hold in the current cycle""
    },
    ""Assertion Explaination"": ""if the least significant portion of the data bit counter is inactive then, simultaneously, the signal indicating that reception is done must also remain inactive""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sTick == 0) |-> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sTick"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sTick"": ""the pulse signal used to indicate when to sample the incoming data bit during oversampling"",
      ""rxDoneTick"": ""the flag that signals the completion of the UART reception""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""checks whether the value on the left equals the value on the right"",
      ""|->"": ""non-overlapping implication operator which means that if the condition on the left holds at the current clock edge then the condition on the right must hold starting from the subsequent relevant cycle""
    },
    ""Assertion Explaination"": ""if the sampling tick pulse is inactive at a clock edge, then in the following evaluation the reception completion indicator is required to be inactive""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sNext[0] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sNext[0]"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sNext[0]"": ""the least significant bit of the signal representing the next value of the oversampling counter"",
      ""rxDoneTick"": ""the signal that flags when the reception of data is complete""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""compares two values for equality"",
      ""|=>"": ""implies that if the left-hand condition is met, then the right-hand condition must hold concurrently within the same clock cycle""
    },
    ""Assertion Explaination"": ""if the evaluated least significant portion of the upcoming oversampling counter value is inactive then concurrently the finished reception indicator must be inactive""
  }
}","{
""Assertion 1"": ""assert property (!(stateReg[0]) || (rxDoneTick == 1'b0));"",
""Assertion 2"": ""assert property (sReg[3] == 1'b0 |-> rxDoneTick == 1'b0);"",
""Assertion 3"": ""assert property (sReg[3] === 1'b0 || rxDoneTick === 1'b0);"",
""Assertion 4"": ""assert property (!(nReg < `dataBits) || rxDoneTick);"",
""Assertion 5"": ""assert property (nReg[dataBits-1:0] == 0 |=> rxDoneTick == 1'b0);"",
""Assertion 6"": ""assert property (!(sTick) |-> !rxDoneTick);"",
""Assertion 7"": ""assert property (sReg[2:0] == 3'b000 |-> rxDoneTick == 1'b0);""
}"
APB_FSM_Controller,"
// AHB to APG Bridge | Maven Silicon
//
//
//
// APB FSM Controller
// Date:08-06-2022
//
// By-Prajwal Kumar Sahu

module APB_FSM_Controller( Hclk,Hresetn,valid,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata,Hwrite,Haddr,Hwdata,Hwritereg,tempselx, 
			   Pwrite,Penable,Pselx,Paddr,Pwdata,Hreadyout);

input Hclk,Hresetn,valid,Hwrite,Hwritereg;
input [31:0] Hwdata,Haddr,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata;
input [2:0] tempselx;
output reg Pwrite,Penable;
output reg Hreadyout;  
output reg [2:0] Pselx;
output reg [31:0] Paddr,Pwdata;

//////////////////////////////////////////////////////PARAMETERS

parameter ST_IDLE=3'b000;
parameter ST_WWAIT=3'b001;
parameter ST_READ= 3'b010;
parameter ST_WRITE=3'b011;
parameter ST_WRITEP=3'b100;
parameter ST_RENABLE=3'b101;
parameter ST_WENABLE=3'b110;
parameter ST_WENABLEP=3'b111;


//////////////////////////////////////////////////// PRESENT STATE LOGIC

reg [2:0] PRESENT_STATE,NEXT_STATE;

always @(posedge Hclk)
 begin:PRESENT_STATE_LOGIC
  if (~Hresetn)
    PRESENT_STATE<=ST_IDLE;
  else
    PRESENT_STATE<=NEXT_STATE;
 end


/////////////////////////////////////////////////////// NEXT STATE LOGIC

always @(PRESENT_STATE,valid,Hwrite,Hwritereg)
 begin:NEXT_STATE_LOGIC
  case (PRESENT_STATE)
    
 	ST_IDLE:begin
		 if (~valid)
		  NEXT_STATE=ST_IDLE;
		 else if (valid && Hwrite)
		  NEXT_STATE=ST_WWAIT;
		 else 
		  NEXT_STATE=ST_READ;
		end    

	ST_WWAIT:begin
		 if (~valid)
		  NEXT_STATE=ST_WRITE;
		 else
		  NEXT_STATE=ST_WRITEP;
		end

	ST_READ: begin
		   NEXT_STATE=ST_RENABLE;
		 end

	ST_WRITE:begin
		  if (~valid)
		   NEXT_STATE=ST_WENABLE;
		  else
		   NEXT_STATE=ST_WENABLEP;
		 end

	ST_WRITEP:begin
		   NEXT_STATE=ST_WENABLEP;
		  end

	ST_RENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLEP:begin
		      if (~valid && Hwritereg)
		       NEXT_STATE=ST_WRITE;
		      else if (valid && Hwritereg)
		       NEXT_STATE=ST_WRITEP;
		      else
		       NEXT_STATE=ST_READ;
		    end

	default: begin
		   NEXT_STATE=ST_IDLE;
		  end
  endcase
 end


////////////////////////////////////////////////////////OUTPUT LOGIC:COMBINATIONAL

reg Penable_temp,Hreadyout_temp,Pwrite_temp;
reg [2:0] Pselx_temp;
reg [31:0] Paddr_temp, Pwdata_temp;

always @(*)
 begin:OUTPUT_COMBINATIONAL_LOGIC
   case(PRESENT_STATE)
    
	ST_IDLE: begin
			  if (valid && ~Hwrite) 
			   begin:IDLE_TO_READ
			        Paddr_temp=Haddr;
				Pwrite_temp=Hwrite;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Hreadyout_temp=0;
			   end
			  
			  else if (valid && Hwrite)
			   begin:IDLE_TO_WWAIT
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;			   
			   end
			   
			  else
                            begin:IDLE_TO_IDLE
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;	
			   end
		     end    

	ST_WWAIT:begin
	          if (~valid) 
			   begin:WAIT_TO_WRITE
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Pwdata_temp=Hwdata;
				Hreadyout_temp=0;
			   end
			  
			  else 
			   begin:WAIT_TO_WRITEP
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Pwdata_temp=Hwdata;
				Penable_temp=0;
				Hreadyout_temp=0;		   
			   end
			   
		     end  

	ST_READ: begin:READ_TO_RENABLE
			  Penable_temp=1;
			  Hreadyout_temp=1;
		     end

	ST_WRITE:begin
              if (~valid) 
			   begin:WRITE_TO_WENABLE
				Penable_temp=1;
				Hreadyout_temp=1;
			   end
			  
			  else 
			   begin:WRITE_TO_WENABLEP ///DOUBT
				Penable_temp=1;
				Hreadyout_temp=1;		   
			   end
		     end

	ST_WRITEP:begin:WRITEP_TO_WENABLEP
               Penable_temp=1;
			   Hreadyout_temp=1;
		      end

	ST_RENABLE:begin
	            if (valid && ~Hwrite) 
				 begin:RENABLE_TO_READ
					Paddr_temp=Haddr;
					Pwrite_temp=Hwrite;
					Pselx_temp=tempselx;
					Penable_temp=0;
					Hreadyout_temp=0;
				 end
			  
			  else if (valid && Hwrite)
			    begin:RENABLE_TO_WWAIT
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;			   
			    end
			   
			  else
                begin:RENABLE_TO_IDLE
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;	
			    end

		       end

	ST_WENABLEP:begin
                 if (~valid && Hwritereg) 
			      begin:WENABLEP_TO_WRITEP
			       Paddr_temp=Haddr2;
				   Pwrite_temp=Hwrite;
				   Pselx_temp=tempselx;
				   Penable_temp=0;
				   Pwdata_temp=Hwdata;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLEP_TO_WRITE_OR_READ /////DOUBT
			      Paddr_temp=Haddr2;
				  Pwrite_temp=Hwrite;
				  Pselx_temp=tempselx;
				  Pwdata_temp=Hwdata;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end
		        end

	ST_WENABLE :begin
	             if (~valid && Hwritereg) 
			      begin:WENABLE_TO_IDLE
				   Pselx_temp=0;
				   Penable_temp=0;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLE_TO_WAIT_OR_READ /////DOUBT
				  Pselx_temp=0;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end

		        end

 endcase
end


////////////////////////////////////////////////////////OUTPUT LOGIC:SEQUENTIAL

always @(posedge Hclk)
 begin
  
  if (~Hresetn)
   begin
    Paddr<=0;
	Pwrite<=0;
	Pselx<=0;
	Pwdata<=0;
	Penable<=0;
	Hreadyout<=0;
   end
  
  else
   begin
        Paddr<=Paddr_temp;
	Pwrite<=Pwrite_temp;
	Pselx<=Pselx_temp;
	Pwdata<=Pwdata_temp;
	Penable<=Penable_temp;
	Hreadyout<=Hreadyout_temp;
   end
 end
 ///////////////////////


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""1 |-> ##2 PRESENT_STATE == $past(NEXT_STATE)"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""NEXT_STATE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine""
    },
    ""Logical Operators"": [
      ""|->"",
      ""##2"",
      ""=="",
      ""$past""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""a non-overlapping implication operator indicating that when the antecedent is true, the consequent must hold starting immediately"",
      ""##2"": ""a delay operator specifying that the consequent is checked two clock cycles after the antecedent"",
      ""=="": ""an equality comparison operator verifying that two values are equal"",
      ""$past"": ""a function that returns the value of a signal from previous clock cycles""
    },
    ""Assertion Explaination"": ""if the always-true antecedent holds, then after a delay of two clock cycles the current state stored in the finite state machine must be equal to the previously computed future state""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""(PRESENT_STATE == ST_IDLE && valid && Hwrite) |-> (NEXT_STATE == ST_WWAIT)"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_IDLE"",
      ""valid"",
      ""Hwrite"",
      ""NEXT_STATE"",
      ""ST_WWAIT""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_IDLE"": ""the constant representing the idle state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwrite"": ""a control signal indicating that a write operation is requested"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WWAIT"": ""the constant representing the wait-for-write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator ensuring that multiple conditions are simultaneously true"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent holds then the consequent must follow from the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the idle state and the transaction is valid with a write operation requested, then the computed future state of the finite state machine must be the wait-for-write state""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_IDLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_IDLE"",
      ""valid"",
      ""Hwrite"",
      ""NEXT_STATE"",
      ""ST_READ""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_IDLE"": ""the constant representing the idle state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwrite"": ""a control signal indicating that a write operation is requested"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_READ"": ""the constant representing the read state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator confirming that multiple conditions are simultaneously true"",
      ""!"": ""a logical NOT operator indicating the inversion of a signal’s value"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent is true then the consequent must hold from the next evaluation""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the idle state, the transaction is valid, and a write operation is not requested, then the computed future state must be the read state""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_IDLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_IDLE"",
      ""valid"",
      ""NEXT_STATE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_IDLE"": ""the constant representing the idle state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator ensuring that all involved conditions are true simultaneously"",
      ""!"": ""a logical NOT operator negating a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator indicating that if the condition on the left is true then the condition on the right must follow in the next evaluation""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the idle state and the validity signal is not asserted, then the computed future state remains the idle state""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WWAIT && !valid |-> NEXT_STATE == ST_WRITE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WWAIT"",
      ""valid"",
      ""NEXT_STATE"",
      ""ST_WRITE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WWAIT"": ""the constant representing the wait-for-write state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WRITE"": ""the constant representing the write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator ensuring that all conditions are simultaneously met"",
      ""!"": ""a logical NOT operator indicating the inversion of a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator indicating that if the conditions on the left hold then the condition on the right must be true starting from the next evaluation""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the wait-for-write state and the validity signal is not asserted, then the computed future state becomes the write state""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WWAIT && valid |-> NEXT_STATE == ST_WRITEP"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WWAIT"",
      ""valid"",
      ""NEXT_STATE"",
      ""ST_WRITEP""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WWAIT"": ""the constant representing the wait-for-write state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WRITEP"": ""the constant representing the pipelined write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator verifying that both conditions are true"",
      ""|->"": ""a non-overlapping implication operator indicating that if the condition on the left is met then the condition on the right must hold in the subsequent evaluation""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the wait-for-write state and the validity signal is asserted, then the computed future state must become the pipelined write state""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_READ"",
      ""NEXT_STATE"",
      ""ST_RENABLE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_READ"": ""the constant representing the read state of the finite state machine"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_RENABLE"": ""the constant representing the read-enable state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""|->"": ""a non-overlapping implication operator specifying that if the condition on the left is satisfied then the condition on the right must follow in the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the read state, then the computed future state must become the read-enable state""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITE && !valid |-> NEXT_STATE == ST_WENABLE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WRITE"",
      ""valid"",
      ""NEXT_STATE"",
      ""ST_WENABLE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WRITE"": ""the constant representing the write state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WENABLE"": ""the constant representing the write-enable state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator ensuring that all combined conditions are true simultaneously"",
      ""!"": ""a logical NOT operator indicating the inversion of a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent holds then the consequent must be true in the following cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the write state and the validity signal is not asserted, then the computed future state must become the write-enable state""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITE && valid |-> NEXT_STATE == ST_WENABLEP"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WRITE"",
      ""valid"",
      ""NEXT_STATE"",
      ""ST_WENABLEP""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WRITE"": ""the constant representing the write state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WENABLEP"": ""the constant representing the pipelined write-enable state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator ensuring that combined conditions are simultaneously true"",
      ""|->"": ""a non-overlapping implication operator indicating that if the conditions on the left are true then the condition on the right must hold from the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the write state and the validity signal is asserted, then the computed future state must become the pipelined write-enable state""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WRITEP"",
      ""NEXT_STATE"",
      ""ST_WENABLEP""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WRITEP"": ""the constant representing the pipelined write state of the finite state machine"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WENABLEP"": ""the constant representing the pipelined write-enable state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""|->"": ""a non-overlapping implication operator specifying that if the condition on the left is satisfied then the condition on the right must hold in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the pipelined write state, then the computed future state must become the pipelined write-enable state""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_RENABLE"",
      ""valid"",
      ""NEXT_STATE"",
      ""ST_IDLE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_RENABLE"": ""the constant representing the read-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_IDLE"": ""the constant representing the idle state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator verifying that two values are equal"",
      ""&&"": ""a logical AND operator ensuring that all conditions are met simultaneously"",
      ""!"": ""a logical NOT operator indicating the inversion of a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent holds then the consequent must follow in the next evaluation""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the read-enable state and the validity signal is not asserted, then the computed future state must revert to the idle state""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_RENABLE"",
      ""valid"",
      ""Hwrite"",
      ""NEXT_STATE"",
      ""ST_WWAIT""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_RENABLE"": ""the constant representing the read-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwrite"": ""a control signal indicating that a write operation is requested"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WWAIT"": ""the constant representing the wait-for-write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator ensuring that each of the conditions is true"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent conditions hold then the consequent must occur starting from the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the read-enable state, the transaction is valid, and a write operation is requested, then the computed future state must be the wait-for-write state""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_RENABLE"",
      ""valid"",
      ""Hwrite"",
      ""NEXT_STATE"",
      ""ST_READ""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_RENABLE"": ""the constant representing the read-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwrite"": ""a control signal indicating that a write operation is requested"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_READ"": ""the constant representing the read state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator verifying that two values are equal"",
      ""&&"": ""a logical AND operator ensuring that multiple conditions are all true"",
      ""!"": ""a logical NOT operator inverting the condition of a signal"",
      ""|->"": ""a non-overlapping implication operator specifying that if the antecedent is true then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the read-enable state, the transaction is valid, and a write operation is not requested, then the computed future state must become the read state""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WENABLE"",
      ""valid"",
      ""NEXT_STATE"",
      ""ST_IDLE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WENABLE"": ""the constant representing the write-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_IDLE"": ""the constant representing the idle state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking for value equivalence"",
      ""&&"": ""a logical AND operator ensuring that all conditions are true"",
      ""!"": ""a logical NOT operator that inverts a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold starting from the next evaluation""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the write-enable state and the transaction is not valid, then the computed future state must revert to the idle state""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WENABLE"",
      ""valid"",
      ""Hwrite"",
      ""NEXT_STATE"",
      ""ST_WWAIT""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WENABLE"": ""the constant representing the write-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwrite"": ""a control signal indicating that a write operation is requested"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WWAIT"": ""the constant representing the wait-for-write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking whether two values are equal"",
      ""&&"": ""a logical AND operator ensuring all conditions are true"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent is met then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the write-enable state, the transaction is valid, and a write operation is requested, then the computed future state must change to the wait-for-write state""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WENABLE"",
      ""valid"",
      ""Hwrite"",
      ""NEXT_STATE"",
      ""ST_READ""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WENABLE"": ""the constant representing the write-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwrite"": ""a control signal indicating that a write operation is requested"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_READ"": ""the constant representing the read state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking if two values are equal"",
      ""&&"": ""a logical AND operator verifying that all conditions are concurrently true"",
      ""!"": ""a logical NOT operator inverting the condition of a signal"",
      ""|->"": ""a non-overlapping implication operator indicating that if the antecedent holds then the consequent must occur in the subsequent cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the write-enable state, the transaction is valid, and a write operation is not requested, then the computed future state must become the read state""
  },
  ""Assertion 17"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && !valid && Hwritereg |-> NEXT_STATE == ST_WRITE"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WENABLEP"",
      ""valid"",
      ""Hwritereg"",
      ""NEXT_STATE"",
      ""ST_WRITE""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WENABLEP"": ""the constant representing the pipelined write-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwritereg"": ""a control signal indicating the status of a write register used for pipelined operations"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WRITE"": ""the constant representing the write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator confirming equivalence of two values"",
      ""&&"": ""a logical AND operator ensuring that each condition is true"",
      ""!"": ""a logical NOT operator inverting a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator stating that if the antecedent conditions hold then the consequent must hold from the next evaluation cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the pipelined write-enable state, the transaction is not valid, and the pipelined write register is asserted, then the computed future state must become the write state""
  },
  ""Assertion 18"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && valid && Hwritereg |-> NEXT_STATE == ST_WRITEP"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WENABLEP"",
      ""valid"",
      ""Hwritereg"",
      ""NEXT_STATE"",
      ""ST_WRITEP""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WENABLEP"": ""the constant representing the pipelined write-enable state of the finite state machine"",
      ""valid"": ""a control signal indicating that the current transaction is valid"",
      ""Hwritereg"": ""a control signal indicating the status of a write register used for pipelined operations"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_WRITEP"": ""the constant representing the pipelined write state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""&&"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking for equivalent values"",
      ""&&"": ""a logical AND operator ensuring all conditions are met simultaneously"",
      ""|->"": ""a non-overlapping implication operator meaning that if the antecedent holds then the consequent must follow in the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the pipelined write-enable state, the transaction is valid, and the pipelined write register is asserted, then the computed future state must become the pipelined write state""
  },
  ""Assertion 19"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && !Hwritereg |-> NEXT_STATE == ST_READ"",
    ""Signals"": [
      ""PRESENT_STATE"",
      ""ST_WENABLEP"",
      ""Hwritereg"",
      ""NEXT_STATE"",
      ""ST_READ""
    ],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the register holding the current state of the finite state machine"",
      ""ST_WENABLEP"": ""the constant representing the pipelined write-enable state of the finite state machine"",
      ""Hwritereg"": ""a control signal indicating the status of a write register used for pipelined operations"",
      ""NEXT_STATE"": ""the computed future state of the finite state machine"",
      ""ST_READ"": ""the constant representing the read state of the finite state machine""
    },
    ""Logical Operators"": [
      ""=="",
      ""&&"",
      ""!"",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""an equality comparison operator checking equivalence of two values"",
      ""&&"": ""a logical AND operator that requires all conditions to be true simultaneously"",
      ""!"": ""a logical NOT operator that negates a signal’s condition"",
      ""|->"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold starting from the next cycle""
    },
    ""Assertion Explaination"": ""if the finite state machine is in the pipelined write-enable state and the pipelined write register is not asserted, then the computed future state must become the read state""
  }
}","{
""Assertion 1"": ""assert property (PRESENT_STATE == NEXT_STATE);"",
""Assertion 2"": ""assert property (PRESENT_STATE == ST_IDLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT);"",
""Assertion 3"": ""assert property (PRESENT_STATE == ST_IDLE && valid && ~Hwrite |-> NEXT_STATE == ST_READ);"",
""Assertion 4"": ""assert property (PRESENT_STATE == ST_IDLE && ~valid |-> NEXT_STATE == ST_IDLE);"",
""Assertion 5"": ""assert property (PRESENT_STATE == ST_WWAIT && ~valid |-> NEXT_STATE == ST_WRITE);"",
""Assertion 6"": ""assert property (PRESENT_STATE == ST_WWAIT && valid -> NEXT_STATE == ST_WRITEP);"",
""Assertion 7"": ""assert property (PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE);"",
""Assertion 8"": ""assert property (PRESENT_STATE == ST_WRITE && ~valid || NEXT_STATE == ST_WENABLE);"",
""Assertion 9"": ""assert property (PRESENT_STATE == ST_WRITE && valid |-> NEXT_STATE == ST_WENABLEP);"",
""Assertion 10"": ""assert property (PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP);"",
""Assertion 11"": ""assert property (PRESENT_STATE == ST_RENABLE && ~valid |-> NEXT_STATE == ST_IDLE);"",
""Assertion 12"": ""assert property (PRESENT_STATE == ST_RENABLE && valid && Hwrite |=> NEXT_STATE == ST_WWAIT);"",
""Assertion 13"": ""assert property (PRESENT_STATE == ST_RENABLE && valid && ~Hwrite || NEXT_STATE == ST_READ);"",
""Assertion 14"": ""assert property (PRESENT_STATE == ST_WENABLE && ~valid |-> NEXT_STATE == ST_IDLE);"",
""Assertion 15"": ""assert property (PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT);"",
""Assertion 16"": ""assert property (PRESENT_STATE == ST_WENABLE && valid && ~Hwrite |-> NEXT_STATE == ST_READ);"",
""Assertion 17"": ""assert property (PRESENT_STATE == ST_WENABLEP && ~valid && Hwritereg |-> NEXT_STATE == ST_WRITE);"",
""Assertion 18"": ""assert property (PRESENT_STATE == ST_WENABLE && valid && Hwritereg |-> (NEXT_STATE == ST_WENABLEP));"",
""Assertion 19"": ""assert property (PRESENT_STATE == ST_WENABLEP && (~Hwritereg) |-> NEXT_STATE == ST_READ);""
}"
register,"module register
  #(
    parameter WIDTH=8
    )
   (
    input logic              clk,
    input logic              rst,
    input logic              en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );
   
   always_ff @(posedge clk or posedge rst) begin
      if (rst)
        out <= '0;
      else if (en)
        out <= in;      
   end 
   
endmodule
","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""en |=> out == $past(in,1)"",
""Signals"": [""en"", ""out"", ""in""],
""Signal Explanations"": {
  ""en"": ""enable signal that controls when the register updates"",
  ""out"": ""the output signal of the register storing the data"",
  ""in"": ""the input signal that provides new data to the register""
},
""Logical Operators"": [""|=>"", ""=="", ""$past""],
""Logical Operators Explanation"": {
  ""|=>"": ""non-overlapping implication, meaning that if the condition on the left is true at this cycle, then the condition on the right must hold at the next cycle"",
  ""=="": ""equality comparison, ensuring that two values are the same"",
  ""$past"": ""references the value of a signal from the previous clock cycle""
},
""Assertion Explaination"": ""if the condition that controls data loading is active, then the stored data becomes identical to the new data as it was one cycle ago""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""!en |=> out == $past(out,1)"",
""Signals"": [""en"", ""out""],
""Signal Explanations"": {
  ""en"": ""enable signal that controls when the register updates"",
  ""out"": ""the output signal of the register storing the data""
},
""Logical Operators"": [""!"", ""|=>"", ""=="", ""$past""],
""Logical Operators Explanation"": {
  ""!"": ""logical negation, indicating the inverse of the condition"",
  ""|=>"": ""non-overlapping implication, meaning that if the condition on the left is true at this cycle, then the condition on the right must hold at the next cycle"",
  ""=="": ""equality comparison, ensuring that two values are the same"",
  ""$past"": ""references the value of a signal from the previous clock cycle""
},
""Assertion Explaination"": ""if the condition that controls data loading is inactive, then the stored data remains equal to the data held in the previous cycle""
}
}","{
""Assertion 1"": ""assert property (en |=> (out == in));"",
""Assertion 2"": ""assert property (en == 0 |-> (out == $past(out)));""
}"
SEVEN,"module SEVEN #(parameter freq = 250, parameter CBITS = 8) (input clk, input rst, input [13:0] both7seg, output reg[6:0] segment);
	reg [CBITS-1:0] cnt;
	reg digit_select;

	always @(posedge clk) begin
		if(rst == 1) begin
			cnt = 0;
			digit_select = 0;
			segment = 0;
		end
		if(cnt < freq)
			cnt = cnt + 1;
		else begin
			cnt = 0;
			if(digit_select == 0) begin
				digit_select = 1;
				segment = both7seg[13:7];
			end
			else begin
				digit_select = 0;
				segment = both7seg[6:0];
			end
		end
	end
endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""rst == 1 || digit_select == 1"",
""Signals"": [""rst"", ""digit_select""],
""Signal Explanations"": {
  ""rst"": ""the signal that initializes or clears the state of the module"",
  ""digit_select"": ""the flip-flop that chooses which seven‐segment display digit to drive""
},
""Logical Operators"": [""=="", ""||""],
""Logical Operators Explanation"": {
  ""=="": ""returns true when the compared value exactly matches the expected value"",
  ""||"": ""evaluates to true if at least one of its operands is true""
},
""Assertion Explaination"": ""either the signal that initializes or clears the state of the module has a value equal to its active state or the flip-flop controlling the chosen display digit has a value equal to its active state""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""rst == 1 || digit_select == 0"",
""Signals"": [""rst"", ""digit_select""],
""Signal Explanations"": {
  ""rst"": ""the signal that initializes or clears the state of the module"",
  ""digit_select"": ""the flip-flop that chooses which seven‐segment display digit to drive""
},
""Logical Operators"": [""=="", ""||""],
""Logical Operators Explanation"": {
  ""=="": ""returns true when the compared value exactly matches the expected value"",
  ""||"": ""evaluates to true if at least one of its operands is true""
},
""Assertion Explaination"": ""either the signal that initializes or clears the state of the module has a value equal to its active state or the flip-flop controlling the chosen display digit has a value equal to its inactive state""
}
}","{
""Assertion 1"": ""assert property (rst == 1 || digit_select == 1);"",
""Assertion 2"": ""assert property (rst == 1 || digit_select == 0);""
}"
arbiter,"//EE382M-Verification of Digital Systems
//Lab 4 - Formal Property Verification
//
//
//Module - PNSeqGen
//Pseudo-random pattern generator

module PNSeqGen(
  input        clk,
  input        rst_n,
  output [1:0] rand_out
  );

reg s1, s2, s3;
wire s0;

assign s0 = s1 ^ s3;

always @ (posedge clk or negedge rst_n) begin
  if(!rst_n) begin
   s1 <= 1;
   s2 <= 0;
   s3 <= 0;
  end else begin   
   s1 <= s0;
   s2 <= s1;
   s3 <= s2;
  end
end

assign rand_out = {s3,s2};

endmodule

module arbiter(
  clk,
  rst_n,
  req,
  arb_type,
  gnt
  );

// Input and Output ports
input        clk;
input        rst_n;
input  [3:0] req;
input  [2:0] arb_type;

output [3:0] gnt;

// Internal variables
wire [3:0] req;

reg  [3:0] r_gnt_p0; // P0 priority scheme output
reg  [3:0] r_gnt_p1; // P1 priority scheme output
reg  [3:0] r_gnt_p2; // P2 priority scheme output
reg  [3:0] r_gnt_p3; // P3 priority scheme output
reg  [3:0] r_gnt_rr; // Prr: Round robin arbitration scheme output
reg  [3:0] r_gnt_px; // Prand: Random arbitration scheme output
reg  [3:0] r_gnt;

wire [1:0] rand_out;
wire [1:0] r_gnt_rr_encoded;

assign gnt   = r_gnt;

// P0 Fixed Priority req[0]
always @(*) begin
  if(req[0])
    r_gnt_p0 = 4'b0001;
  else if(req[1])
    r_gnt_p0 = 4'b0010;
  else if(req[2])
    r_gnt_p0 = 4'b0100;
  else if(req[3])
    r_gnt_p0 = 4'b1000; // Saqib changed this from r_gnt_p0 = 4'b0000;
  else
    r_gnt_p0 = 4'b0000;
end

// P1 Fixed Priority req[1]
always @(*) begin
  if(req[1])
    r_gnt_p1 = 4'b0010;
  else if(req[0])
    r_gnt_p1 = 4'b0001;
  else if(req[2])
    r_gnt_p1 = 4'b0100;
  else if(req[3])
    r_gnt_p1 = 4'b1000;
  else
    r_gnt_p1 = 4'b0000;
end

// P2 Fixed Priority req[2]
always @(*) begin
  if(req[2])
    r_gnt_p2 = 4'b0100;
  else if(req[0])
    r_gnt_p2 = 4'b0001;
  else if(req[1])
    r_gnt_p2 = 4'b0010;
  else if(req[3])
    r_gnt_p2 = 4'b1000;
  else
    r_gnt_p2 = 4'b0000;
end

// P3 Fixed Priority req[3]
always @(*) begin
  if(req[3])
    r_gnt_p3 = 4'b1000;
  else if(req[0])
    r_gnt_p3 = 4'b0001;
  else if(req[1])
    r_gnt_p3 = 4'b0010;
  else if(req[2])
    r_gnt_p3 = 4'b0100;
  else
    r_gnt_p3 = 4'b0000;
end

// Prr: Round robin arbiter
always @ (*) begin
  r_gnt_rr[0] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & req[0]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & req[0]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & req[0]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & ~req[1] & req[0]) ;

  r_gnt_rr[1] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & req[1]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[0] & req[1]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & ~req[0] & req[1]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & req[1]) ;
  
  r_gnt_rr[2] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & ~req[1] & req[2]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[0] & ~req[1] & req[2]) |  // Saqib changed req[1] to ~req[1]
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & req[2]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[1] & req[2]) ;
 
  r_gnt_rr[3] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & ~req[1] & ~req[2] & req[3]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & req[3]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[2] & req[3]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[1] & ~req[2] & req[3]) ;
end

// encode the 4b r_gnt_rrs to 2b
assign r_gnt_rr_encoded = {r_gnt[3] | r_gnt[2], r_gnt[3] | r_gnt[1]};

// Prand: Random arbitration
PNSeqGen u_PNSeqGen ( .clk(clk), .rst_n(rst_n), .rand_out(rand_out) );

always @(*) begin
  case(rand_out)

  2'b00: begin
    if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end
  
  2'b01: begin
    if(req[1])
      r_gnt_px = 4'b0010;  // Saqib change 4'b0001 to 4'b0010
    else if(req[0])
      r_gnt_px = 4'b0001;  // Saqib change 4'b0010 to 4'b0001
    else if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end

  2'b10: begin
    if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end

  2'b11: begin
    if(req[3])
      r_gnt_px = 4'b1000;
    else if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[2])
      r_gnt_px = 4'b0100;
    else
      r_gnt_px = 4'b0000;
  end

  endcase
end

// Priority selection
always @(posedge clk or negedge rst_n)
begin
  if(!rst_n)
    r_gnt <= 4'b0000;
  else
    case(arb_type)
      4'b0000: r_gnt <= r_gnt_p0;
      4'b0001: r_gnt <= r_gnt_p1;
      4'b0010: r_gnt <= r_gnt_p2;
      4'b0011: r_gnt <= r_gnt_p3;
      4'b0100: r_gnt <= r_gnt_rr;
      4'b0101: r_gnt <= r_gnt_px;
      default: r_gnt <= 4'b0000;
    endcase
end

endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd0)) |-> $past(req[0])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""the output grant signal for channel 0 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND that requires both operands to be true"",
      ""$past"": ""refers to the value of a signal from the previous clock cycle"",
      ""=="": ""checks equality between two values"",
      ""|->"": ""non-overlapping implication meaning that if the condition on the left is true then the condition on the right must have held in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the first channel is active and, in the previous cycle, the arbitration selection indicated a fixed priority configuration with the first channel having highest priority, then the request input for that same channel was active in the previous cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd0)) |-> $past(req[1] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""the output grant signal for channel 1 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND that requires both operands to be true"",
      ""$past"": ""refers to the value of a signal from the previous clock cycle"",
      ""=="": ""checks equality between two values"",
      ""&"": ""logical conjunction within the past expression combining conditions"",
      ""~"": ""logical negation indicating a false or de‐asserted condition"",
      ""|->"": ""non-overlapping implication meaning that if the left side is true then the right side must have been true in the relevant previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the second channel is active and the previous cycle showed that the arbitration scheme was the fixed priority type where channel 0 has higher priority than channel 1, then during the previous cycle the request input for the second channel was active while the request input for the first channel was inactive""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd0)) |-> $past(req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""the output grant signal for channel 2 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND that requires both conditions to be true"",
      ""$past"": ""refers to the value of a signal from the previous clock cycle"",
      ""=="": ""checks equality"",
      ""&"": ""combines multiple conditions"",
      ""~"": ""indicates the negation of a condition"",
      ""|->"": ""non-overlapping implication signifying that when the antecedent is fulfilled, the consequent must have been true in the prior cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the third channel is active and the previous cycle indicated the fixed priority arbitration configuration with the first two channels having higher priority, then in the previous cycle the request input for the third channel was active while the request inputs for the first and second channels were inactive""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd0)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""the output grant signal for channel 3 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[3]"": ""the input request signal for channel 3"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND that requires all operand conditions to be true"",
      ""$past"": ""refers to the value of a signal from the previous clock cycle"",
      ""=="": ""performs an equality comparison"",
      ""&"": ""combines several conditions together"",
      ""~"": ""denotes the negation of a condition"",
      ""|->"": ""non-overlapping implication ensuring that if the antecedent is true then the consequent was true in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the fourth channel is active and the previous cycle established a fixed priority arbitration where all lower priority requests were absent, then in that previous cycle the request for the fourth channel was active while all higher priority request inputs were inactive""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd1)) |-> $past(req[0] & ~req[1])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""the output grant signal for channel 0 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[0]"": ""the input request signal for channel 0"",
      ""req[1]"": ""the input request signal for channel 1""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND requiring both conditions to hold"",
      ""$past"": ""refers to a value from the previous clock cycle"",
      ""=="": ""determines equality between the current arbitration type and a constant"",
      ""&"": ""combines conditions within the past evaluation"",
      ""~"": ""logical negation indicating an inactive condition"",
      ""|->"": ""non-overlapping implication indicating that the consequent must have held in the corresponding past cycle if the antecedent holds now""
    },
    ""Assertion Explaination"": ""if the grant output for the first channel is active and the previous cycle showed that the arbitration type corresponded to the configuration where channel 1 has priority over channel 0, then in that previous cycle the request for the first channel was active while the request for the second channel was inactive""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd1)) |-> $past(req[1])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""the output grant signal for channel 1 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[1]"": ""the input request signal for channel 1""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND that ensures both conditions are met"",
      ""$past"": ""refers to the signal value in the previous clock cycle"",
      ""=="": ""compares the previous arbitration type to a constant value"",
      ""|->"": ""non-overlapping implication meaning that if the left side is true then the right side must have been true in the relevant past cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the second channel is active and the previous cycle indicated that the arbitration selection was for the configuration prioritizing channel 1, then the request input for the second channel was active in the previous cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd1)) |-> $past(req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""the output grant signal for channel 2 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND requiring both conditions to be true"",
      ""$past"": ""refers to the value carried over from the previous clock cycle"",
      ""=="": ""used for verifying equality with a constant"",
      ""&"": ""combines multiple conditions in the past evaluation"",
      ""~"": ""negates a condition to indicate its inactivity"",
      ""|->"": ""non-overlapping implication ensuring that the consequence was true in the previous cycle if the antecedent holds now""
    },
    ""Assertion Explaination"": ""if the grant output for the third channel is active and the previous cycle reflected an arbitration configuration that favors channel 1 over the others, then in that previous cycle the request for channel 2 was active while the requests for channels 1 and 0 were not active""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd1)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""the output grant signal for channel 3 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[3]"": ""the input request signal for channel 3"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND where both conditions must be satisfied"",
      ""$past"": ""refers to the signal values from the previous cycle"",
      ""=="": ""performs an equality check against the expected arbitration type"",
      ""&"": ""combines individual conditions within the past reference"",
      ""~"": ""denotes the inversion of a condition, meaning it is inactive"",
      ""|->"": ""non-overlapping implication indicating that if the antecedent holds then the consequent must have been true in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the fourth channel is active and the previous cycle’s arbitration configuration corresponded to the fixed priority type where channel 1 is highest, then during that previous cycle the request for the fourth channel was active while the requests for channels 2, 1, and 0 were inactive""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd2)) |-> $past(req[0] & ~req[2])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[2]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""the output grant signal for channel 0 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[0]"": ""the input request signal for channel 0"",
      ""req[2]"": ""the input request signal for channel 2""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND enforcing simultaneous truth"",
      ""$past"": ""captures the value from the previous clock cycle"",
      ""=="": ""compares the previous arbitration type with a designated constant"",
      ""&"": ""combines conditions within the past evaluation"",
      ""~"": ""negates a condition to indicate it should not be active"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent is true then the consequent held in the prior cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the first channel is active and the previous cycle indicated an arbitration configuration corresponding to the second scheme, then in that previous cycle the request for the first channel was active while the request for the third channel was inactive""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd2)) |-> $past(req[1] & ~req[2] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[2]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""the output grant signal for channel 1 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND requiring both conditions to be satisfied"",
      ""$past"": ""uses the value from the previous clock cycle"",
      ""=="": ""performs an equality test"",
      ""&"": ""combines multiple conditions together"",
      ""~"": ""represents a negated or inactive condition"",
      ""|->"": ""non-overlapping implication that relates the antecedent to a past consequence""
    },
    ""Assertion Explaination"": ""if the grant output for the second channel is active and the previous cycle showed the arbitration type matching the second scheme, then in that previous cycle the request for the second channel was active while the requests for the first and third channels were inactive""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd2)) |-> $past(req[2])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""the output grant signal for channel 2 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[2]"": ""the input request signal for channel 2""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND which requires both the current and past conditions to be true"",
      ""$past"": ""fetches the previous clock cycle's value"",
      ""=="": ""checks for equality with a constant"",
      ""|->"": ""non-overlapping implication implying that the antecedent guarantees the consequent in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the third channel is active and the previous cycle had the arbitration type set to the second scheme, then in that previous cycle the request for the third channel was active""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd2)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""the output grant signal for channel 3 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[3]"": ""the input request signal for channel 3"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND ensuring both current and past conditions hold"",
      ""$past"": ""retrieves values from the previous cycle"",
      ""=="": ""verifies equality with an expected constant"",
      ""&"": ""combines several conditions within the past expression"",
      ""~"": ""denotes the negation (inactivity) of a condition"",
      ""|->"": ""non-overlapping implication meaning if the antecedent holds then the consequent was true in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the fourth channel is active and the previous cycle indicated the second arbitration scheme, then in that cycle the request for the fourth channel was active while the requests for all other channels were inactive""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd3)) |-> $past(req[0] & ~req[3])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[3]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""the output grant signal for channel 0 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[0]"": ""the input request signal for channel 0"",
      ""req[3]"": ""the input request signal for channel 3""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND checking for simultaneous truth"",
      ""$past"": ""refers to the previous clock cycle’s value"",
      ""=="": ""compares the past arbitration type with a specified constant"",
      ""&"": ""combines multiple conditions inside the past evaluation"",
      ""~"": ""indicates that a condition is not active"",
      ""|->"": ""non-overlapping implication that mandates the consequent held in the previous cycle if the antecedent is true""
    },
    ""Assertion Explaination"": ""if the grant output for the first channel is active and the previous cycle had the arbitration type corresponding to a configuration where channel 3 has the highest priority, then in the previous cycle the request for the first channel was active while the request for the fourth channel was inactive""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd3)) |-> $past(req[1] & ~req[3] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[3]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""the output grant signal for channel 1 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[1]"": ""the input request signal for channel 1"",
      ""req[3]"": ""the input request signal for channel 3"",
      ""req[0]"": ""the input request signal for channel 0""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND ensuring both conditions are met concurrently"",
      ""$past"": ""retrieves the value from the previous cycle"",
      ""=="": ""performs an equality comparison"",
      ""&"": ""aggregates multiple conditions within the past operator"",
      ""~"": ""signifies the negation of a condition"",
      ""|->"": ""non-overlapping implication meaning that the antecedent guarantees the consequent in the prior cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the second channel is active and the previous cycle’s arbitration configuration indicated that channel 3 was prioritized over channels 1 and 0, then in that previous cycle the request for the second channel was active while the requests for the first and fourth channels were inactive""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd3)) |-> $past(req[2] & ~req[3] & ~req[0] & ~req[1])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[3]"", ""req[0]"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""the output grant signal for channel 2 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[2]"": ""the input request signal for channel 2"",
      ""req[3]"": ""the input request signal for channel 3"",
      ""req[0]"": ""the input request signal for channel 0"",
      ""req[1]"": ""the input request signal for channel 1""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""&"", ""~"", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND requiring all listed conditions to be true"",
      ""$past"": ""selects the previous cycle's value"",
      ""=="": ""compares the previous arbitration type against the expected value"",
      ""&"": ""groups multiple conditions together"",
      ""~"": ""denotes a condition is not asserted"",
      ""|->"": ""non-overlapping implication meaning that the truth of the antecedent necessitates the truth of the consequent in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the third channel is active and the previous cycle indicated an arbitration configuration where channel 3 is highest priority, then in that previous cycle the request for the third channel was active while all other channel requests were inactive""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd3)) |-> $past(req[3])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""the output grant signal for channel 3 produced by the arbiter"",
      ""arb_type"": ""the input that selects the arbitration scheme type"",
      ""req[3]"": ""the input request signal for channel 3""
    },
    ""Logical Operators"": [""&&"", ""$past"", ""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND ensuring simultaneous truth of conditions"",
      ""$past"": ""refers to the previous clock cycle value"",
      ""=="": ""checks for equality with a constant"",
      ""|->"": ""non-overlapping implication indicating that if the antecedent holds then the consequent was true in the previous cycle""
    },
    ""Assertion Explaination"": ""if the grant output for the fourth channel is active and the previous cycle had the arbitration type corresponding to the configuration that prioritizes channel 3, then in that previous cycle the request for the fourth channel was active""
  }
}","{
""Assertion 1"": ""assert property (gnt[0] == 1'b1 && arb_type == 4'b0000 |-> req[0] == 1'b1);"",
""Assertion 2"": ""assert property (r_gnt[1] === 1'b1 && arb_type == 4'b0000 |-> (req[1] === 1'b1 && req[0] === 1'b0));"",
""Assertion 3"": ""assert property (gnt[2] == 1'b1 && arb_type == 3'b0000 |-> (req[2] == 1'b1 && req[0] == 1'b0 && req[1] == 1'b0));"",
""Assertion 4"": ""assert property ((gnt[3] == 1'b1) && (r_gnt_p3 == 4'b1000) && (req[0] == 1'b0) && (req[1] == 1'b0) && (req[2] == 1'b0) |-> (req[3] == 1'b1));"",
""Assertion 5"": ""assert property (gnt[0] == 1'b1 && arb_type == 4'b0001 |-> (req[1] == 1'b1 && req[0] == 1'b0));"",
""Assertion 6"": ""assert property ((gnt[1] == 1'b1) && (r_gnt_p1 == 4'b0010) |-> (req[1] == 1'b1));"",
""Assertion 7"": ""assert property (gnt[2] && (r_gnt_p1 == 4'b0010) -> (req[1] && !req[0] && !req[3]));"",
""Assertion 8"": ""assert property ( (gnt[3] && arb_type == 4'b0001) |-> (req[3] && !req[2] && !req[1] && !req[0]) );"",
""Assertion 9"": ""assert property ((gnt[0] == 1'b1) && (arb_type == 3'b001) |=> ((req[0] == 1'b1) && (req[2] == 1'b0)));"",
""Assertion 10"": ""assert property (gnt[1] == 1'b1 && arb_type == 4'b0001 |-> (req[1] == 1'b1 && req[0] == 1'b0 && req[2] == 1'b0));"",
""Assertion 11"": ""assert property (gnt[2] == 1'b1 && arb_type == 3'b001 && req[2] == 1'b0);"",
""Assertion 12"": ""assert property (gnt[3] == 1'b1 && arb_type == 3'b0011 |-> (req[3] == 1'b1 && req[2] == 1'b0 && req[1] == 1'b0 && req[0] == 1'b0));"",
""Assertion 13"": ""assert property (r_gnt[0] ==> (arb_type == 4'b0011 ? (req[0] && !req[3]) : 1'b1));"",
""Assertion 14"": ""assert property (gnt[1] == 1'b1 && r_gnt_p3 == 4'b1000 && r_gnt_p0 == 4'b0000 && r_gnt_p1 == 4'b0000);"",
""Assertion 15"": ""assert property (gnt[3] && (arb_type == 4'b0011) |-> (req[3] && !req[0] && !req[1] && !req[2]));"",
""Assertion 16"": ""assert property (r_gnt[3] == 1'b1 && arb_type == 4'b0011 |-> req[3] == 1'b1);""
}"
simple_pipeline,"// Greg Stitt
// University of Florida

// Module: simple_pipeline
// Description: This module takes 8 WIDTH-bit inputs, multiplies the 4 pairs,
// and then sums the products using a 2-level adder tree. Each stage of the
// pipeline is registered, and all overflow is ignored at each stage.

//===================================================================
// Parameter Description
// WIDTH : The data width (number of bits) of the input and output
//===================================================================

//===================================================================
// Interface Description
// clk  : Clock input
// rst  : Reset input (active high)
// in   : An array of 8 WIDTH-bit inputs
// valid_in : User should assert any time the input data on ""in"" is valid.
// out  : The output of the multiply accumulate computation.
// valid_out : Asserted whenever ""out"" contains valid data.
//===================================================================

module simple_pipeline
  #(
    parameter int WIDTH=16
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic [WIDTH-1:0]  in[8],
    input logic 	     valid_in,
    output logic [WIDTH-1:0] out,
    output logic 	     valid_out
    );

   // Specifies the cycle latency of the pipeline.
   localparam int 	     LATENCY = 4;
   
   logic [WIDTH-1:0] 	     in_r[8];
   logic [WIDTH-1:0] 	     mult_r[4];
   logic [WIDTH-1:0] 	     add_r[2];
   logic [WIDTH-1:0] 	     out_r;   
   logic [0:LATENCY-1] 	     valid_delay_r;

   assign out = out_r;
   
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
	 // Reset all the registers.
	 for (int i=0; i < 8; i++) in_r[i] <= '0;
	 for (int i=0; i < 4; i++) mult_r[i] <= '0;
	 for (int i=0; i < 2; i++) add_r[i] <= '0;
	 out_r <= '0;	 
      end
      else begin
	 // Register the inputs.
	 for (int i=0; i < 8; i++) in_r[i] <= in[i];
	 // Perform the multiplications.
	 for (int i=0; i < 4; i++) mult_r[i] <= in_r[i*2] * in_r[i*2+1];
	 // Create the first level of adders.
	 for (int i=0; i < 2; i++) add_r[i] <= mult_r[i*2] + mult_r[i*2+1];
	 // Create the final adder.
	 out_r <= add_r[0] + add_r[1];
      end
   end 

   // Delay that determines when out is valid based on the pipeline latency.
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
	 for (int i=0; i < LATENCY; i++) valid_delay_r[i] = '0;
      end
      else begin
	 valid_delay_r[0] <= valid_in;	 
	 for (int i=1; i < LATENCY; i++) valid_delay_r[i] <= valid_delay_r[i-1];
      end      
   end

   assign valid_out = valid_delay_r[LATENCY-1];   
endmodule

","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""count < LATENCY |-> valid_out == 1'b0"",
""Signals"": [""count"", ""LATENCY"", ""valid_out""],
""Signal Explanations"": {
          ""count"": ""a counter that increments each clock cycle until reaching the pipeline latency"",
          ""LATENCY"": ""a constant representing the number of cycles in the pipeline (here 4)"",
          ""valid_out"": ""a signal that indicates when the pipeline's output is valid""
},
""Logical Operators"": [""<"", ""|->"", ""==""],
""Logical Operators Explanation"": {
          ""<"": ""tests whether the left-hand value is less than the right-hand constant"",
          ""|->"": ""if the antecedent condition holds then the consequent condition must hold in the same cycle"",
          ""=="": ""checks for equality between two values""
},
""Assertion Explaination"": ""when the counter is less than the pipeline latency, it implies that the signal indicating output validity must equal the constant false""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""count == LATENCY |-> valid_out == $past(valid_in, LATENCY)"",
""Signals"": [""count"", ""LATENCY"", ""valid_out"", ""valid_in""],
""Signal Explanations"": {
          ""count"": ""a counter that increments each clock cycle until it reaches the pipeline latency"",
          ""LATENCY"": ""a constant that sets the number of cycles required for the pipeline computation"",
          ""valid_out"": ""a signal that shows when the output data of the pipeline is valid"",
          ""valid_in"": ""a signal asserted to indicate that the input data is valid""
},
""Logical Operators"": [""=="", ""|->"", ""$past""],
""Logical Operators Explanation"": {
          ""=="": ""verifies that two values are equal"",
          ""|->"": ""if the antecedent condition is true then the consequent condition must be true on the following clock cycle"",
          ""$past"": ""refers to the value of a signal a specified number of clock cycles in the past""
},
""Assertion Explaination"": ""when the counter equals the pipeline latency, it implies that the signal indicating output validity must equal the value of the signal indicating input validity from a number of clock cycles equal to the pipeline latency""
}
}","{
""Assertion 1"": ""assert property (valid_delay_r < LATENCY |-> (valid_out == 1'b0));"",
""Assertion 2"": ""assert property (valid_out === valid_delay_r[LATENCY - 1]);""
}"
lcd,"module lcd #(parameter clk_freq = 1, parameter CBITS = 9) (input rst, input clk, input [6:0] in_data, input lcd_enable, input [9:0] lcd_bus, output reg e, output reg[7:0] lcd_data, output reg rw, output reg rs, output reg busy);
	reg [CBITS - 1:0] cnt;			// 0 to 500*clk_freg
	reg [1:0] state;

	always @(posedge clk) begin
		rw = 0;
		rs = 0;
		busy = 0;
		lcd_data = 0;
		e = 0;
		if(state == 0) begin
			busy = 1;
			if(cnt < 500*clk_freq)				// wait 500
				cnt = cnt + 1;
			else begin							// power-up completed
				cnt = 0;
				rs = 0;
				rw = 0;
				lcd_data = 8'b00110000;
				state = 1;
			end
		end
		if(state == 1) begin
			busy = 1;
			cnt = cnt + 1;
			if(cnt < (10*clk_freq))begin			//function set
				lcd_data = {4'b0011, in_data[6], in_data[5], 2'b00};
				e = 1;
			end
			else if(cnt < (60*clk_freq))begin		// wait 50
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (70*clk_freq))begin		//display on/off control
				lcd_data = {5'b00001, in_data[4], in_data[3], in_data[2]};
				e = 1;
			end
			else if(cnt < (120*clk_freq))begin		// wait 50
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (130*clk_freq))begin		// display clear
				lcd_data = 8'b00000001;
				e = 1;
			end
			else if(cnt < (330*clk_freq))begin		// wait 200
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (340*clk_freq))begin		// entry mode set
				lcd_data = {6'b000001, in_data[1], in_data[0]};
				e = 1;
			end
			else if(cnt < (440*clk_freq))begin		// wait 100
				lcd_data = 8'b00000000;
				e = 0;
			end
			else begin								// initialization complete
				cnt = 0;
				busy = 0;
				state = 2;
			end
		end
		if(state == 2) begin
			if(lcd_enable == 1) begin
				busy = 1;
				rs = lcd_bus[9];
				rw = lcd_bus[8];
				lcd_data = lcd_bus[7:0];
				cnt = 0;
				state = 3;
			end
			else begin
				busy = 0;
				rs = 0;
				rw = 0;
				lcd_data = 8'b00000000;
				cnt = 0;
			end
		end
		if(state == 3) begin
			if(cnt < 50* clk_freq) begin 		// do not exit for 50
				if(cnt < clk_freq)
					e = 0;
				else if(cnt < 14*clk_freq)		// positive enable half-cycle
					e = 1;
				else if(cnt < 27*clk_freq)		// negative enable half-cycle
					e = 0;
				cnt = cnt + 1;
			end
			else begin
				cnt = 0;
				state = 2;
			end
		end
	end

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""lcd_enable == 0 || state == 2"",
""Signals"": [""lcd_enable"", ""state""],
""Signal Explanations"": {
  ""lcd_enable"": ""the control signal that determines whether the lcd bus command sequence is activated"",
  ""state"": ""the variable representing the current phase of initialization or command execution within the lcd control state machine""
},
""Logical Operators"": [""=="", ""||""],
""Logical Operators Explanation"": {
  ""=="": ""checks if two values are equal"",
  ""||"": ""logical OR that evaluates to true if at least one of its operands is true""
},
""Assertion Explaination"": ""on every positive clock edge, eventually either the control signal for the lcd bus operation is deactivated or the state machine reaches its idle phase that denotes the completion of the initialization sequence""
}
}","{
""Assertion 1"": ""assert property ( (state == 2) || (e == 0) );""
}"
Parallel_In_Serial_Out_Shift_Reg,"module Parallel_In_Serial_Out_Shift_Reg #(
	parameter DATA_WIDTH = 16
) 
(
	input clk,
	input resetn,
	input [DATA_WIDTH-1:0] din,
	input                  din_en,
	output logic           dout
);

reg  [DATA_WIDTH-1:0] data_q;
wire [DATA_WIDTH-1:0] data_next;

assign data_next = din_en ? din : data_q >> 1;

always @(posedge clk)
begin
	if( ~resetn) begin
		data_q <= '0;
	end else begin
		data_q <= data_next;
	end
end

assign dout = data_q[0]; 


endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (~resetn)"",
""logical expression"": ""~v_f_q | (v_f_q & din_f_q[0] == dout)"",
""Signals"": [""v_f_q"", ""din_f_q[0]"", ""dout""],
""Signal Explanations"": {
  ""v_f_q"": ""an internal register that holds a flag indicating that a valid data enable has been applied and the input data is considered valid"",
  ""din_f_q[0]"": ""the least significant bit of a registered, pipelined version of the parallel input data that is shifted over time"",
  ""dout"": ""the serialized output derived from the least significant bit of the primary shift register""
},
""Logical Operators"": [""~"", ""|"", ""&"", ""==""],
""Logical Operators Explanation"": {
  ""~"": ""a logical negation that inverts the value of the operand"",
  ""|"": ""a logical OR operator that yields true if at least one of the operands is true"",
  ""&"": ""a logical AND operator that yields true only if both operands are true"",
  ""=="": ""an equality operator that compares two values for equivalence""
},
""Assertion Explaination"": ""This assertion means that either the flag indicating valid data is not set (negation of the valid flag) or, if the flag is set, then the condition requires that the least significant bit of the pipelined version of the parallel input data matches the current serialized output bit. In other words, when the data is considered valid, the serialized output must equal the buffered input’s least significant bit.""
}
}","{
""Assertion 1"": ""assert property ((!din_en) || (dout == din[0]));""
}"
fifo,"module fifo
  #(
    parameter WIDTH=8,
    parameter DEPTH=16
    )
   (
    input logic              clk,
    input logic              rst,
    output logic             full,
    input logic              wr_en,
    input logic [WIDTH-1:0]  wr_data,
    output logic             empty, 
    input logic              rd_en,
    output logic [WIDTH-1:0] rd_data  
    );

   localparam int READ_LATENCY = 1;
   
   logic [WIDTH-1:0]         ram[DEPTH];
   logic                     valid_wr, valid_rd;

   localparam int            ADDR_WIDTH = $clog2(DEPTH)+1;
   logic [ADDR_WIDTH-1:0]   wr_addr_r, rd_addr_r;

   always_ff @(posedge clk) begin
      if (valid_wr) ram[wr_addr_r[ADDR_WIDTH-2:0]] <= wr_data;
      rd_data <= ram[rd_addr_r[ADDR_WIDTH-2:0]];      
   end
      
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
         rd_addr_r <= '0;
         wr_addr_r <= '0;
      end
      else begin         
         if (valid_wr) wr_addr_r <= wr_addr_r + 1'b1;
         if (valid_rd) rd_addr_r <= rd_addr_r + 1'b1;
      end
   end 
      
   assign valid_wr = wr_en && !full;
   assign valid_rd = rd_en && !empty;

   assign full = rd_addr_r[ADDR_WIDTH-2:0] == wr_addr_r[ADDR_WIDTH-2:0] && rd_addr_r[ADDR_WIDTH-1] != wr_addr_r[ADDR_WIDTH-1];

   assign empty = rd_addr_r == wr_addr_r;
      
endmodule

","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""valid_wr |-> !full"",
""Signals"": [""valid_wr"", ""full""],
""Signal Explanations"": {
  ""valid_wr"": ""a derived signal that indicates that a write request is valid when a write enable is asserted and the FIFO is not full"",
  ""full"": ""an output signal that indicates the FIFO is full by comparing the write and read pointer portions""
},
""Logical Operators"": [""|->"", ""!""],
""Logical Operators Explanation"": {
  ""|->"": ""non-overlapping implication meaning that if the first condition holds in a clock cycle then the second must hold in that same cycle"",
  ""!"": ""logical negation indicating that the condition is false""
},
""Assertion Explaination"": ""if the condition indicating that a write request is valid is met then it implies that the status indicating the FIFO is full must be false""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""valid_rd |-> !empty"",
""Signals"": [""valid_rd"", ""empty""],
""Signal Explanations"": {
  ""valid_rd"": ""a derived signal that indicates that a read request is valid when a read enable is asserted and the FIFO is not empty"",
  ""empty"": ""an output signal that indicates the FIFO is empty by checking if the read and write pointers are equal""
},
""Logical Operators"": [""|->"", ""!""],
""Logical Operators Explanation"": {
  ""|->"": ""non-overlapping implication meaning that if the first condition holds in a clock cycle then the second must hold in that same cycle"",
  ""!"": ""logical negation indicating that the condition is false""
},
""Assertion Explaination"": ""if the condition indicating that a read request is valid is met then it implies that the status indicating the FIFO is empty must be false""
}
}","{
""Assertion 1"": ""assert property (valid_wr |-> !full);"",
""Assertion 2"": ""assert property (valid_rd implies !empty);""
}"
or1200_if,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's instruction fetch                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  PC, instruction fetch, interface to IC.                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_if.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_if(
	// Clock and reset
	clk, rst,

	// External i/f to IC
	icpu_dat_i, icpu_ack_i, icpu_err_i, icpu_adr_i, icpu_tag_i,

	// Internal i/f
	if_freeze, if_insn, if_pc, if_flushpipe, saving_if_insn, 
	if_stall, no_more_dslot, genpc_refetch, rfe,
	except_itlbmiss, except_immufault, except_ibuserr
);

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External i/f to IC
//
input	[31:0]			icpu_dat_i;
input				icpu_ack_i;
input				icpu_err_i;
input	[31:0]			icpu_adr_i;
input	[3:0]			icpu_tag_i;

//
// Internal i/f
//
input				if_freeze;
output	[31:0]			if_insn;
output	[31:0]			if_pc;
input				if_flushpipe;
output				saving_if_insn;
output				if_stall;
input				no_more_dslot;
output				genpc_refetch;
input				rfe;
output				except_itlbmiss;
output				except_immufault;
output				except_ibuserr;

//
// Internal wires and regs
//
wire			save_insn;
wire			if_bypass;
reg			if_bypass_reg;
reg	[31:0]		insn_saved;
reg	[31:0]		addr_saved;
reg	[2:0]		err_saved;
reg			saved;

assign save_insn = (icpu_ack_i | icpu_err_i) & if_freeze & !saved;
assign saving_if_insn = !if_flushpipe & save_insn;

//
// IF bypass 
//
assign if_bypass = icpu_adr_i[0] ? 1'b0 : if_bypass_reg | if_flushpipe;

always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		if_bypass_reg <=  1'b0;
	else
		if_bypass_reg <=  if_bypass;

//
// IF stage insn
//
assign if_insn = no_more_dslot | rfe | if_bypass ? {`OR1200_OR32_NOP, 26'h041_0000} : saved ? insn_saved : icpu_ack_i ? icpu_dat_i : {`OR1200_OR32_NOP, 26'h061_0000};
assign if_pc = saved ? addr_saved : {icpu_adr_i[31:2], 2'h0};
assign if_stall = !icpu_err_i & !icpu_ack_i & !saved;
assign genpc_refetch = saved & icpu_ack_i;
assign except_itlbmiss = no_more_dslot ? 1'b0 : saved ? err_saved[0] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_TE);
assign except_immufault = no_more_dslot ? 1'b0 : saved ? err_saved[1] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_PE);
assign except_ibuserr = no_more_dslot ? 1'b0 : saved ? err_saved[2] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_BE);

//
// Flag for saved insn/address
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		saved <=  1'b0;
	else if (if_flushpipe)
		saved <=  1'b0;
	else if (save_insn)
		saved <=  1'b1;
	else if (!if_freeze)
		saved <=  1'b0;

//
// Store fetched instruction
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (if_flushpipe)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (save_insn)
		insn_saved <=  icpu_err_i ? {`OR1200_OR32_NOP, 26'h041_0000} : icpu_dat_i;
	else if (!if_freeze)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};

//
// Store fetched instruction's address
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		addr_saved <=  32'h00000000;
	else if (if_flushpipe)
		addr_saved <=  32'h00000000;
	else if (save_insn)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};
	else if (!if_freeze)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};

//
// Store fetched instruction's error tags 
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		err_saved <=  3'b000;
	else if (if_flushpipe)
		err_saved <=  3'b000;
	else if (save_insn) begin
		err_saved[0] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_TE);
		err_saved[1] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_PE);
		err_saved[2] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_BE);
	end
	else if (!if_freeze)
		err_saved <=  3'b000;


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""no_more_dslot |-> (except_itlbmiss == 0 && except_immufault == 0 && except_ibuserr == 0)"",
    ""Signals"": [
      ""no_more_dslot"",
      ""except_itlbmiss"",
      ""except_immufault"",
      ""except_ibuserr""
    ],
    ""Signal Explanations"": {
      ""no_more_dslot"": ""signal indicating that there is no additional delay slot instruction"",
      ""except_itlbmiss"": ""signal indicating an instruction TLB miss exception"",
      ""except_immufault"": ""signal indicating an instruction immediate memory fault exception"",
      ""except_ibuserr"": ""signal indicating an instruction bus error exception""
    },
    ""Logical Operators"": [
      ""|->"",
      ""=="",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""if the left‐side condition is true then the right‐side condition is required to hold"",
      ""=="": ""equality check between two values"",
      ""&&"": ""logical AND ensuring both conditions are true""
    },
    ""Assertion Explaination"": ""if the signal indicating absence of a delay slot is active then it must follow that the exception indicator for a translation lookaside buffer miss, the exception indicator for an immediate fault, and the exception indicator for an instruction bus error are all equal to zero""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 saved == 1"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""saved""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""saved"": ""flag that indicates the fetched instruction and related data have been saved""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT, meaning the condition is inverted"",
      ""&&"": ""logical AND, meaning both conditions must be true"",
      ""|->"": ""implication: if the condition on the left is true then the condition on the right must follow"",
      ""##1"": ""delay operator indicating the condition must be met one clock cycle later"",
      ""=="": ""equality to verify that two values are the same""
    },
    ""Assertion Explaination"": ""if the signal indicating a pipeline flush is not active and the condition for saving the instruction is true then in the next cycle the flag indicating that the instruction has been saved must be equal to one""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 saved == 0"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""if_freeze"",
      ""saved""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""if_freeze"": ""signal indicating that the instruction fetch stage is frozen"",
      ""saved"": ""flag that indicates the fetched instruction and related data have been saved""
    },
    ""Logical Operators"": [
      ""|"",
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|"": ""logical OR meaning at least one of the conditions must be true"",
      ""!"": ""logical NOT, meaning the condition is inverted"",
      ""&&"": ""logical AND requiring both conditions to be true"",
      ""|->"": ""implication: if the left-hand side condition is met then the right-hand side condition must follow"",
      ""##1"": ""delay operator specifying the next clock cycle"",
      ""=="": ""equality check to ensure both sides are identical""
    },
    ""Assertion Explaination"": ""if either the signal for flushing the pipeline is active or both the condition for saving is false and the signal for freezing the instruction fetch stage is inactive, then one clock cycle later the flag indicating that the instruction has been saved must be equal to zero""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn && !icpu_err_i) |-> ##1 (insn_saved == $past(icpu_dat_i))"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""icpu_err_i"",
      ""insn_saved"",
      ""icpu_dat_i""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""icpu_err_i"": ""signal from the instruction cache interface that indicates an error"",
      ""insn_saved"": ""register holding the saved instruction"",
      ""icpu_dat_i"": ""data input carrying the fetched instruction from the instruction cache interface""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""$past""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT, indicating a condition is false"",
      ""&&"": ""logical AND where all conditions must be true"",
      ""|->"": ""implication meaning that if the left-hand side condition holds then the right-hand side must follow"",
      ""##1"": ""delay operator signifying the condition must be satisfied one clock cycle later"",
      ""=="": ""equality check to verify both sides are identical"",
      ""$past"": ""function that retrieves the value of a signal from the previous clock cycle""
    },
    ""Assertion Explaination"": ""if the signal for flushing the pipeline is inactive, the condition for saving the instruction is true, and the error signal from the instruction cache is not active then one cycle later the register holding the saved instruction must equal the value that was present on the instruction data input in the previous cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 (insn_saved == {6'b000101, 26'h041_0000})"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""if_freeze"",
      ""insn_saved""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""if_freeze"": ""signal indicating that the instruction fetch stage is frozen"",
      ""insn_saved"": ""register holding the saved instruction""
    },
    ""Logical Operators"": [
      ""|"",
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|"": ""logical OR meaning that at least one of the enclosed conditions is true"",
      ""!"": ""logical NOT, meaning the condition is inverted"",
      ""&&"": ""logical AND requiring both sub-conditions to be true"",
      ""|->"": ""implication indicating that if the left-hand side condition holds, then the right-hand side condition must follow"",
      ""##1"": ""delay operator meaning the condition must hold in the next clock cycle"",
      ""=="": ""equality check ensuring that both sides are equal""
    },
    ""Assertion Explaination"": ""if either the signal to flush the pipeline is active or both the condition for saving the instruction is false and the signal indicating a freeze in the instruction fetch stage is inactive then one clock cycle later the register holding the saved instruction must equal the constant representing a no-operation instruction""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && (save_insn | !if_freeze)) |-> ##1 (addr_saved == {$past(icpu_adr_i[31:2]), 2'b00})"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""if_freeze"",
      ""addr_saved"",
      ""icpu_adr_i""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""if_freeze"": ""signal indicating that the instruction fetch stage is frozen"",
      ""addr_saved"": ""register holding the saved instruction address"",
      ""icpu_adr_i"": ""address input from the instruction cache interface""
    },
    ""Logical Operators"": [
      ""!"",
      ""|"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""$past""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT meaning the condition is false"",
      ""|"": ""logical OR meaning at least one of the conditions is true"",
      ""&&"": ""logical AND requiring both conditions to be true"",
      ""|->"": ""implication that if the left-hand side condition holds then the right-hand side condition must follow"",
      ""##1"": ""delay operator signifying that the condition must hold one clock cycle later"",
      ""=="": ""equality check verifying that two values are identical"",
      ""$past"": ""function retrieving the value of a signal from the previous clock cycle""
    },
    ""Assertion Explaination"": ""if the signal for flushing the pipeline is inactive and either the condition for saving the instruction is true or the freeze signal is inactive then one cycle later the register holding the saved address must equal the value formed by taking the upper bits of the previous cycle's address input and appending two zeros""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe) |-> ##1 (addr_saved == 32'h00000000)"",
    ""Signals"": [
      ""if_flushpipe"",
      ""addr_saved""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""addr_saved"": ""register holding the saved instruction address""
    },
    ""Logical Operators"": [
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""implication meaning that if the left-hand side condition is true then the right-hand side condition must follow"",
      ""##1"": ""delay operator indicating the next clock cycle"",
      ""=="": ""equality check used to confirm both sides are the same""
    },
    ""Assertion Explaination"": ""if the flush signal for the pipeline is active then one clock cycle later the register holding the saved address must be equal to zero""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[0] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hd)))"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""err_saved[0]"",
      ""icpu_err_i"",
      ""icpu_tag_i""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""err_saved[0]"": ""bit in the saved error register corresponding to a TLB miss exception"",
      ""icpu_err_i"": ""signal from the instruction cache interface indicating an error"",
      ""icpu_tag_i"": ""tag input from the instruction cache interface used to classify the type of error""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""$past"",
      ""&""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT meaning the condition is false"",
      ""&&"": ""logical AND requiring both conditions to be true"",
      ""|->"": ""implication indicating that if the left-hand side condition holds then the right-hand side condition must subsequently hold"",
      ""##1"": ""delay operator meaning that the consequent must be true in the next clock cycle"",
      ""=="": ""equality check ensuring both sides match"",
      ""$past"": ""function that provides the value of a signal from the previous clock cycle"",
      ""&"": ""bitwise AND used here to combine a previous error signal with a comparison result""
    },
    ""Assertion Explaination"": ""if the pipeline flush signal is inactive and the condition for saving the instruction is true then one cycle later the bit in the saved error register corresponding to a translation lookaside buffer miss must equal the result of the bitwise AND of the previous cycle's error signal and the condition that the previous cycle's tag equals the hexadecimal value d""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[1] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hc)))"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""err_saved[1]"",
      ""icpu_err_i"",
      ""icpu_tag_i""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""err_saved[1]"": ""bit in the saved error register corresponding to an immediate memory fault exception"",
      ""icpu_err_i"": ""signal from the instruction cache interface indicating an error"",
      ""icpu_tag_i"": ""tag input from the instruction cache interface used to classify the type of error""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""$past"",
      ""&""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT indicating the inverted condition"",
      ""&&"": ""logical AND requiring both conditions to be true"",
      ""|->"": ""implication meaning that if the left-hand side holds then the right-hand side must follow"",
      ""##1"": ""delay operator specifying that the check is performed one clock cycle later"",
      ""=="": ""equality check ensuring both sides are identical"",
      ""$past"": ""function that returns the value of a signal from the previous cycle"",
      ""&"": ""bitwise AND combining the previous error signal and the result of the previous tag equality test""
    },
    ""Assertion Explaination"": ""if the flush signal is inactive and the condition to save the instruction is true then one cycle later the bit in the saved error register for an immediate memory fault must equal the result of bitwise AND of the previous cycle's error signal with the condition that the previous cycle's error tag equals the hexadecimal value c""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[2] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hb)))"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""err_saved[2]"",
      ""icpu_err_i"",
      ""icpu_tag_i""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""err_saved[2]"": ""bit in the saved error register corresponding to an instruction bus error exception"",
      ""icpu_err_i"": ""signal from the instruction cache interface indicating an error"",
      ""icpu_tag_i"": ""tag input from the instruction cache interface used to classify the type of error""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""$past"",
      ""&""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT meaning the condition is false"",
      ""&&"": ""logical AND requiring that both conditions are true simultaneously"",
      ""|->"": ""implication meaning that if the left-hand condition holds then the right-hand condition must subsequently hold"",
      ""##1"": ""delay operator indicating that the consequent is evaluated one clock cycle later"",
      ""=="": ""equality check verifying that both sides are identical"",
      ""$past"": ""function retrieving the value of a signal from the previous cycle"",
      ""&"": ""bitwise AND used to combine the previous error signal with the outcome of the previous tag equality check""
    },
    ""Assertion Explaination"": ""if the flush signal is inactive and the condition for saving the instruction is true then one cycle later the bit in the saved error register for an instruction bus error must equal the result of the bitwise AND of the error signal from the previous cycle with the test that the previous cycle's error tag is equal to the hexadecimal value b""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 (err_saved == 3'b000)"",
    ""Signals"": [
      ""if_flushpipe"",
      ""save_insn"",
      ""if_freeze"",
      ""err_saved""
    ],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""signal indicating a request to flush the instruction pipeline"",
      ""save_insn"": ""signal that becomes true when the current instruction must be saved"",
      ""if_freeze"": ""signal indicating that the instruction fetch stage is frozen"",
      ""err_saved"": ""register holding the saved error tags for the fetched instruction""
    },
    ""Logical Operators"": [
      ""|"",
      ""!"",
      ""&&"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|"": ""logical OR meaning at least one of the conditions must hold"",
      ""!"": ""logical NOT indicating the inversion of a condition"",
      ""&&"": ""logical AND meaning both conditions must be true"",
      ""|->"": ""implication meaning that if the left-hand side condition holds then the right-hand side must follow"",
      ""##1"": ""delay operator specifying that the condition is evaluated in the next clock cycle"",
      ""=="": ""equality check ensuring both sides are the same""
    },
    ""Assertion Explaination"": ""if either the signal to flush the pipeline is active or both the condition for saving the instruction is false and the signal indicating a freeze in the instruction fetch stage is inactive then one cycle later the register holding the saved error tags must equal zero for all bits""
  }
}","{
""Assertion 1"": ""assert property (no_more_dslot |=> ((except_itlbmiss == 1'b0) && (except_immufault == 1'b0) && (except_ibuserr == 1'b0)));"",
""Assertion 2"": ""assert property ((!if_flushpipe && save_insn) |-> (saved == 1'b1));"",
""Assertion 3"": ""assert property (if_flushpipe || (!save_insn && !if_freeze) -> !saved);"",
""Assertion 4"": ""assert property ((!if_flushpipe && save_insn && !icpu_err_i) |-> (insn_saved == icpu_dat_i));"",
""Assertion 5"": ""assert property (if_flushpipe || (!save_insn && !if_freeze) |-> (insn_saved == {`OR1200_OR32_NOP, 26'h041_0000}));"",
""Assertion 6"": ""assert property (if_flushpipe == 1'b0 && (save_insn || !if_freeze) |-> (addr_saved == {icpu_adr_i[31:2], 2'b00}));"",
""Assertion 7"": ""assert property (if_flushpipe |-> (addr_saved == 32'h00000000));"",
""Assertion 8"": ""assert property (if_flushpipe == 1'b0 && save_insn |=> (err_saved[0] == (icpu_err_i[0] && (icpu_tag_i == 4'hD))));"",
""Assertion 9"": ""assert property (if_flushpipe == 1'b0 && save_insn == 1'b1 |-> (err_saved[1] == icpu_err_i[1] && (icpu_tag_i == 4'hc)));"",
""Assertion 10"": ""assert property (if_flushpipe == 1'b0 && save_insn[*1] -> (err_saved[2] == (icpu_err_i[0] && (icpu_tag_i == 4'hB))));"",
""Assertion 11"": ""assert property (if_flushpipe || (!save_insn && !if_freeze) |-> (err_saved == 3'b000));""
}"
uart_transmit,"module uart_transmit #(localparam d_width = 4, localparam c_width = 3) (input clk, input rst, input tx_ena, input [d_width - 1: 0] tx_data, output reg tx, output reg tx_busy);
	reg [c_width-1:0] tx_cnt;
	reg tx_state;
	reg [d_width+1:0] tx_buffer;

	always @(posedge clk) begin
		if(rst == 1) begin
			tx_cnt = 0;
			tx = 1;
			tx_busy = 0;
			tx_state = 0;
		end
		if(tx_state == 0) begin
			if(tx_ena == 1) begin
				tx_buffer = {tx_data, 2'b01};
				tx_busy = 1;
				tx_cnt = 0;
				tx_state = 1;
			end
			else
				tx_busy = 0;
		end
		else if(tx_state == 1) begin
			if(tx_cnt < d_width+3) begin
				tx_state = 1;
				tx_cnt = tx_cnt + 1;
				tx_buffer = {1'b1, tx_buffer[d_width+1:1]};
			end
			else begin
				tx_cnt = 0;
				tx_state = 0;
			end
		end
		tx = tx_buffer[0];
	end
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""rst == 1 || tx_state == 0"",
    ""Signals"": [""rst"", ""tx_state""],
    ""Signal Explanations"": {
      ""rst"": ""the input used to asynchronously reset and initialize the module"",
      ""tx_state"": ""the internal indicator representing whether the transmission process is active or idle (0 indicates idle)""
    },
    ""Logical Operators"": [""=="", ""||""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between two signals"",
      ""||"": ""evaluates as true if at least one of the connected conditions is true""
    },
    ""Assertion Explaination"": ""using a logical OR operator, the assertion verifies that either the signal responsible for initializing the module is at its active state, or the internal indicator confirms that the transmission is not active; in other words, it ensures that eventually the module is either being reset or remains in the idle state required by the design""
  }
}","{
""Assertion 1"": ""assert property (rst == 1'b1 || tx_busy == 1'b0);""
}"
ff,"module ff
  (
   input logic clk, rst, en, in,
   output logic out   
   );

   always_ff @(posedge clk or posedge rst)
      if (rst) out = 1'b0;
      else if (en) out = in;         
endmodule

","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""en |=> out == $past(in,1)"",
    ""Signals"": [""en"", ""out"", ""in""],
    ""Signal Explanations"": {
      ""en"": ""enable signal"",
      ""out"": ""output signal of the verilog module"",
      ""in"": ""input signal of the verilog module""
    },
    ""Logical Operators"": [""|=>"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""|=>"": ""non-overlapping implication meaning that if the antecedent is true in the current clock cycle, then the consequent must be true in the following clock cycle"",
      ""=="": ""equality comparison"",
      ""$past"": ""refers to the value of a signal in the previous clock cycle""
    },
    ""Assertion Explaination"": ""when the enable signal is active, the output signal must equal the input signal's value from the previous clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""!en |=> out == $past(out,1)"",
    ""Signals"": [""en"", ""out""],
    ""Signal Explanations"": {
      ""en"": ""enable signal"",
      ""out"": ""output signal of the verilog module""
    },
    ""Logical Operators"": [""!"", ""|=>"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation indicating the signal is not active"",
      ""|=>"": ""non-overlapping implication meaning that if the antecedent is true in the current clock cycle, then the consequent must be true in the following clock cycle"",
      ""=="": ""equality comparison"",
      ""$past"": ""refers to the value of a signal in the previous clock cycle""
    },
    ""Assertion Explaination"": ""when the enable signal is inactive, the output signal must equal its own value from the previous clock cycle""
  }
}","{
""Assertion 1"": ""assert property (en |=> (out == $past(in)));"",
""Assertion 2"": ""assert property (en == 1'b0 |-> out == out[1]);""
}"
BusArbiter,"parameter N_MASTERS = 3;
typedef bit [N_MASTERS-1:0] arb_vector;
parameter arb_vector NO_REQUEST = '{default: '0};
parameter arb_vector NO_GRANT = '{default: '0};

module busarbiter(input clk, reset, bus_ack, input arb_vector bus_req, output arb_vector bus_grant);

    enum {READY, BUSY} state_s;
    arb_vector prio_req;
    reg found;
    always @(bus_req) begin: prio
        arb_vector prio_req_v;
	found = 0;
        for (int i=0; i < N_MASTERS; i++) begin
            if(~found & (bus_req[i]==1'b1)) begin
                prio_req_v[i] = 1'b1;
                found = 1;
            end
            else begin
                prio_req_v[i] = 1'b0;
            end
        end
        prio_req <= prio_req_v;
    end

    always @(posedge clk or posedge reset) begin: ctrl
        if(reset) begin //always block triggered by reset
            state_s <= READY;
            bus_grant <= NO_GRANT;
        end
        else begin //always block triggered by clk
            case (state_s)
                READY: begin
                    if (bus_req == NO_REQUEST) begin
			state_s <= READY;
                    end
                    else begin
                        state_s <= BUSY;
                    end 
                    bus_grant <= prio_req;
                end

                BUSY: begin
                    if (bus_ack) begin
                        if (bus_req == NO_REQUEST) begin
                            state_s <= READY;
                        end
                        else begin
                            state_s <= BUSY;
                        end 
		        bus_grant <= prio_req;
		    end
                end
            endcase 
        end
    end
endmodule","{
""Assertion 1"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""bus_grant[0] + bus_grant[1] + bus_grant[2] < 2"",
  ""Signals"": [""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
  ""Signal Explanations"": {
    ""bus_grant[0]"": ""the grant indicator bit for master 0"",
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[2]"": ""the grant indicator bit for master 2""
  },
  ""Logical Operators"": [""+"", ""<""],
  ""Logical Operators Explanation"": {
    ""+"": ""arithmetic addition of binary values"",
    ""<"": ""checks if the left value is less than the right value""
  },
  ""Assertion Explaination"": ""the sum of the three individual grant indicator bits is compared against the value two to ensure that at most one grant indicator is active at any given time""
},
""Assertion 2"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""bus_grant[0] |-> (!bus_grant[1] && !bus_grant[2])"",
  ""Signals"": [""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
  ""Signal Explanations"": {
    ""bus_grant[0]"": ""the grant indicator bit for master 0"",
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[2]"": ""the grant indicator bit for master 2""
  },
  ""Logical Operators"": [""|->"", ""!"", ""&&""],
  ""Logical Operators Explanation"": {
    ""|->"": ""non-overlapping implication that states if the left condition is true then the right condition must hold in the relevant cycle"",
    ""!"": ""logical NOT"",
    ""&&"": ""logical AND, which requires both conditions be true""
  },
  ""Assertion Explaination"": ""when the grant indicator for master 0 is active, it implies that both the grant indicators for master 1 and master 2 are inactive""
},
""Assertion 3"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""bus_grant[1] |-> (!bus_grant[0] && !bus_grant[2])"",
  ""Signals"": [""bus_grant[1]"", ""bus_grant[0]"", ""bus_grant[2]""],
  ""Signal Explanations"": {
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[0]"": ""the grant indicator bit for master 0"",
    ""bus_grant[2]"": ""the grant indicator bit for master 2""
  },
  ""Logical Operators"": [""|->"", ""!"", ""&&""],
  ""Logical Operators Explanation"": {
    ""|->"": ""non-overlapping implication indicating that if the left condition holds then the right condition must follow"",
    ""!"": ""logical NOT"",
    ""&&"": ""logical AND which confirms that all combined conditions must be true""
  },
  ""Assertion Explaination"": ""when the grant indicator for master 1 is active, it implies that both the grant indicator for master 0 and master 2 are inactive""
},
""Assertion 4"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""bus_grant[2] |-> (!bus_grant[1] && !bus_grant[0])"",
  ""Signals"": [""bus_grant[2]"", ""bus_grant[1]"", ""bus_grant[0]""],
  ""Signal Explanations"": {
    ""bus_grant[2]"": ""the grant indicator bit for master 2"",
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[0]"": ""the grant indicator bit for master 0""
  },
  ""Logical Operators"": [""|->"", ""!"", ""&&""],
  ""Logical Operators Explanation"": {
    ""|->"": ""non-overlapping implication meaning that if the left part is true then the right part must hold"",
    ""!"": ""logical NOT"",
    ""&&"": ""logical AND that requires both conditions to be satisfied""
  },
  ""Assertion Explaination"": ""when the grant indicator for master 2 is active, it implies that both the grant indicators for master 1 and master 0 are inactive""
},
""Assertion 5"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""bus_grant != NO_GRANT && bus_ack != 1 |=> $stable(bus_grant)"",
  ""Signals"": [""bus_grant"", ""NO_GRANT"", ""bus_ack""],
  ""Signal Explanations"": {
    ""bus_grant"": ""the overall grant vector indicating which master is granted access"",
    ""NO_GRANT"": ""a constant vector representing the state of no active grant"",
    ""bus_ack"": ""the acknowledgement signal indicating that a currently granted operation has been completed""
  },
  ""Logical Operators"": [""!="", ""&&"", ""|=>"", ""$stable""],
  ""Logical Operators Explanation"": {
    ""!="": ""inequality, checking that two signals are not equal"",
    ""&&"": ""logical AND ensuring all combined conditions are true"",
    ""|=>"": ""non-overlapping implication indicating that if the left side holds then the right side must follow in the next evaluation"",
    ""$stable"": ""a system function that verifies that the signal value has not changed from the previous clock cycle""
  },
  ""Assertion Explaination"": ""when the overall grant vector signals an active grant (i.e. it does not equal the no-grant constant) and the acknowledgement signal is not asserted, it implies that the grant vector will remain unchanged in the following cycle""
},
""Assertion 6"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""(bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[0]) |=> (bus_grant[0] && !bus_grant[1] && !bus_grant[2])"",
  ""Signals"": [""bus_req[0]"", ""bus_grant"", ""NO_GRANT"", ""bus_ack"", ""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
  ""Signal Explanations"": {
    ""bus_req[0]"": ""the request signal for master 0"",
    ""bus_grant"": ""the overall grant vector indicating current grant status"",
    ""NO_GRANT"": ""a constant vector denoting that no grant is active"",
    ""bus_ack"": ""the acknowledgement signal indicating completion of the current grant operation"",
    ""bus_grant[0]"": ""the grant indicator bit for master 0"",
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[2]"": ""the grant indicator bit for master 2""
  },
  ""Logical Operators"": [""&&"", ""=="", ""||"", ""|=>"", ""&&"", ""!""],
  ""Logical Operators Explanation"": {
    ""&&"": ""logical AND which requires both conditions to be true"",
    ""=="": ""equality check ensuring two signals are identical"",
    ""||"": ""logical OR meaning at least one of the conditions must be true"",
    ""|=>"": ""non-overlapping implication indicating that if the left condition is true then the right condition must hold in the next cycle"",
    ""!"": ""logical NOT which inverts the condition""
  },
  ""Assertion Explaination"": ""if master 0 is requesting access while no grant is currently active, or if an acknowledgement is received while master 0 is requesting, then it implies that only master 0 will be granted access and both master 1 and master 2 will have inactive grant indicators""
},
""Assertion 7"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""(bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[1] && !bus_req[0]) |=> (!bus_grant[0] && bus_grant[1] && !bus_grant[2])"",
  ""Signals"": [""bus_req[1]"", ""bus_req[0]"", ""bus_grant"", ""NO_GRANT"", ""bus_ack"", ""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
  ""Signal Explanations"": {
    ""bus_req[1]"": ""the request signal for master 1"",
    ""bus_req[0]"": ""the request signal for master 0"",
    ""bus_grant"": ""the overall grant vector indicating current grant status"",
    ""NO_GRANT"": ""a constant vector representing no active grant"",
    ""bus_ack"": ""the acknowledgement signal that denotes the completion of a granted operation"",
    ""bus_grant[0]"": ""the grant indicator bit for master 0"",
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[2]"": ""the grant indicator bit for master 2""
  },
  ""Logical Operators"": [""&&"", ""!"", ""=="", ""||"", ""|=>"", ""&&"", ""!""],
  ""Logical Operators Explanation"": {
    ""&&"": ""logical AND, meaning all conditions must be true"",
    ""!"": ""logical NOT, which inverts a condition"",
    ""=="": ""equality check to compare signal values"",
    ""||"": ""logical OR, meaning at least one condition must be true"",
    ""|=>"": ""non-overlapping implication specifying that if the left side holds then the right side must hold in the subsequent cycle""
  },
  ""Assertion Explaination"": ""if master 1 is requesting access while master 0 is not requesting and no grant is currently active, or if an acknowledgement is received together with master 1’s request while master 0 is not requesting, then it implies that only master 1 will be granted access and both master 0 and master 2 will have inactive grant indicators""
},
""Assertion 8"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""(bus_req[2] && !bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[2] && !bus_req[0] && !bus_req[1]) |=> (!bus_grant[0] && !bus_grant[1] && bus_grant[2])"",
  ""Signals"": [""bus_req[2]"", ""bus_req[1]"", ""bus_req[0]"", ""bus_grant"", ""NO_GRANT"", ""bus_ack"", ""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
  ""Signal Explanations"": {
    ""bus_req[2]"": ""the request signal for master 2"",
    ""bus_req[1]"": ""the request signal for master 1"",
    ""bus_req[0]"": ""the request signal for master 0"",
    ""bus_grant"": ""the overall grant vector indicating current grant status"",
    ""NO_GRANT"": ""a constant vector representing that no grant is active"",
    ""bus_ack"": ""the acknowledgement signal indicating that a granted operation is done"",
    ""bus_grant[0]"": ""the grant indicator bit for master 0"",
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_grant[2]"": ""the grant indicator bit for master 2""
  },
  ""Logical Operators"": [""&&"", ""!"", ""=="", ""||"", ""|=>"", ""&&"", ""!""],
  ""Logical Operators Explanation"": {
    ""&&"": ""logical AND which requires all listed conditions to be true"",
    ""!"": ""logical NOT that inverts a condition"",
    ""=="": ""equality check to verify exact match"",
    ""||"": ""logical OR meaning at least one of the conditions must be true"",
    ""|=>"": ""non-overlapping implication indicating that if the left-hand side is true then the right-hand side must subsequently hold""
  },
  ""Assertion Explaination"": ""if master 2 is requesting access while neither master 0 nor master 1 are requesting and no grant is active, or if an acknowledgement is received together with master 2’s request while master 0 and master 1 are not requesting, then it implies that only master 2 will be granted access and both master 0 and master 1 will have inactive grant indicators""
},
""Assertion 9"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""$rose(bus_grant[1]) |-> ($past(bus_req[1]) && !$past(bus_req[0]))"",
  ""Signals"": [""bus_grant[1]"", ""bus_req[1]"", ""bus_req[0]""],
  ""Signal Explanations"": {
    ""bus_grant[1]"": ""the grant indicator bit for master 1"",
    ""bus_req[1]"": ""the request signal for master 1"",
    ""bus_req[0]"": ""the request signal for master 0""
  },
  ""Logical Operators"": [""$rose"", ""|->"", ""$past"", ""&&"", ""!""],
  ""Logical Operators Explanation"": {
    ""$rose"": ""detects a rising edge transition of a signal"",
    ""|->"": ""non-overlapping implication meaning that if the condition on the left is met then the condition on the right must hold in the subsequent evaluation"",
    ""$past"": ""refers to the value of a signal in the previous clock cycle"",
    ""&&"": ""logical AND requiring all conditions to be true"",
    ""!"": ""logical NOT that negates the condition""
  },
  ""Assertion Explaination"": ""if a rising edge is detected on the grant indicator for master 1, it implies that in the previous cycle the request for master 1 was active and the request for master 0 was inactive""
},
""Assertion 10"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""$rose(bus_grant[2]) |-> ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0]))"",
  ""Signals"": [""bus_grant[2]"", ""bus_req[2]"", ""bus_req[1]"", ""bus_req[0]""],
  ""Signal Explanations"": {
    ""bus_grant[2]"": ""the grant indicator bit for master 2"",
    ""bus_req[2]"": ""the request signal for master 2"",
    ""bus_req[1]"": ""the request signal for master 1"",
    ""bus_req[0]"": ""the request signal for master 0""
  },
  ""Logical Operators"": [""$rose"", ""|->"", ""$past"", ""&&"", ""!""],
  ""Logical Operators Explanation"": {
    ""$rose"": ""detects a rising edge transition of a signal"",
    ""|->"": ""non-overlapping implication meaning that if the left condition holds then the right condition must follow in the next evaluation"",
    ""$past"": ""retrieves the value of a signal from the previous clock cycle"",
    ""&&"": ""logical AND ensuring all conditions are simultaneously true"",
    ""!"": ""logical NOT which inverts a condition""
  },
  ""Assertion Explaination"": ""if a rising edge is detected on the grant indicator for master 2, it implies that in the previous cycle the request for master 2 was active while the requests for master 1 and master 0 were inactive""
}
}","{
""Assertion 1"": ""assert property (bus_grant[0] + bus_grant[1] + bus_grant[2] <= 1);"",
""Assertion 2"": ""assert property (bus_grant[0] -> (bus_grant[1] == 1'b0 && bus_grant[2] == 1'b0));"",
""Assertion 3"": ""assert property (bus_grant[1] ==> (bus_grant[0] == 1'b0) && (bus_grant[2] == 1'b0));"",
""Assertion 4"": ""assert property (bus_grant[2] ==> (!bus_grant[1] && !bus_grant[0]));"",
""Assertion 5"": ""assert property (bus_grant != NO_GRANT && !bus_ack |-> (bus_grant == bus_grant));"",
""Assertion 6"": ""assert property ((bus_req[0] && (bus_grant == NO_GRANT)) || (bus_ack && bus_req[0]) |-> ((bus_grant == (1'b1 << 0)) && (bus_grant[1] == 1'b0) && (bus_grant[2] == 1'b0)));"",
""Assertion 7"": ""assert property ((bus_req[1] == 1'b1 && bus_req[0] == 1'b0 && bus_grant != 2'b01) || (bus_ack && bus_req[1] == 1'b1 && bus_req[0] == 1'b0) |=> (bus_grant == 2'b10));"",
""Assertion 8"": ""assert property (     (bus_req[2] && !bus_req[0] && !bus_req[1] && bus_grant != 3'b100) ||     (bus_ack && bus_req[2] && !bus_req[0] && !bus_req[1])     |=> (bus_grant == 3'b100 && bus_grant[0] == 1'b0 && bus_grant[1] == 1'b0) );"",
""Assertion 9"": ""assert property (bus_grant[1] == 1'b1 |-> (bus_req[1] == 1'b1 && bus_req[0] == 1'b0));"",
""Assertion 10"": ""assert property (bus_grant[2] == 1'b1 |-> (bus_req[2] == 1'b1 && bus_req[1] == 1'b0 && bus_req[0] == 1'b0));""
}"
eth_rxstatem,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  eth_rxstatem.v                                              ////
////                                                              ////
////  This file is part of the Ethernet IP core project           ////
////  http://www.opencores.org/project,ethmac                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Igor Mohor (igorM@opencores.org)                      ////
////      - Novan Hartadi (novan@vlsi.itb.ac.id)                  ////
////      - Mahmud Galela (mgalela@vlsi.itb.ac.id)                ////
////                                                              ////
////  All additional information is avaliable in the Readme.txt   ////
////  file.                                                       ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2001 Authors                                   ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: not supported by cvs2svn $
// Revision 1.5  2002/01/23 10:28:16  mohor
// Link in the header changed.
//
// Revision 1.4  2001/10/19 08:43:51  mohor
// eth_timescale.v changed to timescale.v This is done because of the
// simulation of the few cores in a one joined project.
//
// Revision 1.3  2001/10/18 12:07:11  mohor
// Status signals changed, Adress decoding changed, interrupt controller
// added.
//
// Revision 1.2  2001/09/11 14:17:00  mohor
// Few little NCSIM warnings fixed.
//
// Revision 1.1  2001/08/06 14:44:29  mohor
// A define FPGA added to select between Artisan RAM (for ASIC) and Block Ram (For Virtex).
// Include files fixed to contain no path.
// File names and module names changed ta have a eth_ prologue in the name.
// File eth_timescale.v is used to define timescale
// All pin names on the top module are changed to contain _I, _O or _OE at the end.
// Bidirectional signal MDIO is changed to three signals (Mdc_O, Mdi_I, Mdo_O
// and Mdo_OE. The bidirectional signal must be created on the top level. This
// is done due to the ASIC tools.
//
// Revision 1.1  2001/07/30 21:23:42  mohor
// Directory structure changed. Files checked and joind together.
//
// Revision 1.2  2001/07/03 12:55:41  mohor
// Minor changes because of the synthesys warnings.
//
//
// Revision 1.1  2001/06/27 21:26:19  mohor
// Initial release of the RxEthMAC module.
//
//
//
//

module eth_rxstatem (MRxClk, Reset, MRxDV, ByteCntEq0, ByteCntGreat2, Transmitting, MRxDEq5, MRxDEqD, 
                     IFGCounterEq24, ByteCntMaxFrame, StateData, StateIdle, StatePreamble, StateSFD, 
                     StateDrop
                    );

input         MRxClk;
input         Reset;
input         MRxDV;
input         ByteCntEq0;
input         ByteCntGreat2;
input         MRxDEq5;
input         Transmitting;
input         MRxDEqD;
input         IFGCounterEq24;
input         ByteCntMaxFrame;

output [1:0]  StateData;
output        StateIdle;
output        StateDrop;
output        StatePreamble;
output        StateSFD;

reg           StateData0;
reg           StateData1;
reg           StateIdle;
reg           StateDrop;
reg           StatePreamble;
reg           StateSFD;

wire          StartIdle;
wire          StartDrop;
wire          StartData0;
wire          StartData1;
wire          StartPreamble;
wire          StartSFD;


// Defining the next state
assign StartIdle = ~MRxDV & (StateDrop | StatePreamble | StateSFD | (|StateData));

assign StartPreamble = MRxDV & ~MRxDEq5 & (StateIdle & ~Transmitting);

assign StartSFD = MRxDV & MRxDEq5 & (StateIdle & ~Transmitting | StatePreamble);

assign StartData0 = MRxDV & (StateSFD & MRxDEqD & IFGCounterEq24 | StateData1);

assign StartData1 = MRxDV & StateData0 & (~ByteCntMaxFrame);

assign StartDrop = MRxDV & (StateIdle & Transmitting | StateSFD & ~IFGCounterEq24 &
                   MRxDEqD |  StateData0 &  ByteCntMaxFrame);

// Rx State Machine
always @ (posedge MRxClk or posedge Reset)
begin
  if(Reset)
    begin
      StateIdle     <=  1'b0;
      StateDrop     <=  1'b1;
      StatePreamble <=  1'b0;
      StateSFD      <=  1'b0;
      StateData0    <=  1'b0;
      StateData1    <=  1'b0;
    end
  else
    begin
      if(StartPreamble | StartSFD | StartDrop)
        StateIdle <=  1'b0;
      else
      if(StartIdle)
        StateIdle <=  1'b1;

      if(StartIdle)
        StateDrop <=  1'b0;
      else
      if(StartDrop)
        StateDrop <=  1'b1;

      if(StartSFD | StartIdle | StartDrop)
        StatePreamble <=  1'b0;
      else
      if(StartPreamble)
        StatePreamble <=  1'b1;

      if(StartPreamble | StartIdle | StartData0 | StartDrop)
        StateSFD <=  1'b0;
      else
      if(StartSFD)
        StateSFD <=  1'b1;

      if(StartIdle | StartData1 | StartDrop)
        StateData0 <=  1'b0;
      else
      if(StartData0)
        StateData0 <=  1'b1;

      if(StartIdle | StartData0 | StartDrop)
        StateData1 <=  1'b0;
      else
      if(StartData1)
        StateData1 <=  1'b1;
    end
end

assign StateData[1:0] = {StateData1, StateData0};

endmodule","{
""Assertion 1"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartPreamble == 1) |=> (StatePreamble == 1)"",
    ""Signals"": [""StartPreamble"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""StartPreamble"": ""signal indicating when the state machine should transition to the preamble state"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the preamble state is active, then on the next cycle the state machine will be in the preamble state""
},
""Assertion 2"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [""StartDrop"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""StartDrop"": ""signal indicating when the state machine should transition to the drop state"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the drop state is active, then in the following cycle the state machine will not be in the preamble state""
},
""Assertion 3"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateSFD == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [""StateSFD"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator showing the SFD state is active, then on the next cycle the state machine will not be in the preamble state""
},
""Assertion 4"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData[0] == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [""StateData[0]"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""StateData[0]"": ""signal representing the first part of the data state"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the first portion of the data state is active, then on the following cycle the state machine will not be in the preamble state""
},
""Assertion 5"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateDrop == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [""StateDrop"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""StateDrop"": ""signal indicating that the state machine is in the drop state"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the drop state is active, then on the next cycle the state machine will not be in the preamble state""
},
""Assertion 6"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData1 == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [""StateData1"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""StateData1"": ""signal representing the second part of the data state"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the second portion of the data state is active, then in the following cycle the state machine will not be in the preamble state""
},
""Assertion 7"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StatePreamble == 1 & MRxDEq5 == 0 & MRxDV == 1) |=> (StatePreamble == 1)"",
    ""Signals"": [""StatePreamble"", ""MRxDEq5"", ""MRxDV""],
    ""Signal Explanations"": {
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state"",
        ""MRxDEq5"": ""signal indicating that the received data equals the value 5"",
        ""MRxDV"": ""signal indicating that the received data is valid""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if the entire antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the state machine is in the preamble state while the condition for the received data not matching the value 5 is met and the received data is valid, then on the next cycle the state machine will remain in the preamble state""
},
""Assertion 8"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDEq5 == 1) |=> (StatePreamble == 0)"",
    ""Signals"": [""MRxDEq5"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""MRxDEq5"": ""signal indicating that the received data equals the value 5"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition for the received data matching the value 5 is active, then on the next cycle the state machine will not be in the preamble state""
},
""Assertion 9"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StatePreamble == 0)"",
    ""Signals"": [""MRxDV"", ""StatePreamble""],
    ""Signal Explanations"": {
        ""MRxDV"": ""signal indicating that the received data is valid"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the valid received data condition is inactive, then on the next cycle the state machine will not be in the preamble state""
},
""Assertion 10"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartSFD == 1) |=> (StateSFD == 1)"",
    ""Signals"": [""StartSFD"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StartSFD"": ""signal indicating when the state machine should transition to the SFD state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the SFD state is active, then on the next cycle the state machine will be in the SFD state""
},
""Assertion 11"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartIdle == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""StartIdle"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StartIdle"": ""signal indicating when the state machine should transition to the idle state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the idle state is active, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 12"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""StartDrop"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StartDrop"": ""signal indicating when the state machine should transition to the drop state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the drop state is active, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 13"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartData0 == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""StartData0"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StartData0"": ""signal indicating when the state machine should transition to the first data state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the first data state is active, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 14"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartPreamble == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""StartPreamble"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StartPreamble"": ""signal indicating when the state machine should transition to the preamble state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the preamble state is active, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 15"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateSFD == 1 & StartIdle == 0 & MRxDEqD == 0) |=> (StateSFD == 1)"",
    ""Signals"": [""StateSFD"", ""StartIdle"", ""MRxDEqD""],
    ""Signal Explanations"": {
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state"",
        ""StartIdle"": ""signal indicating when the state machine should transition to the idle state"",
        ""MRxDEqD"": ""signal indicating that the received data equals the value D""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if the complete condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the SFD state is active while the condition for transitioning to idle is inactive and the received data does not match the value D, then on the next cycle the state machine will remain in the SFD state""
},
""Assertion 16"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData[0] == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""StateData[0]"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StateData[0]"": ""signal representing the first part of the data state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the first portion of the data state is active, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 17"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateDrop == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""StateDrop"", ""StateSFD""],
    ""Signal Explanations"": {
        ""StateDrop"": ""signal indicating that the state machine is in the drop state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the drop state is active, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 18"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDEq5 == 0 & StatePreamble == 1) |=> (StateSFD == 0)"",
    ""Signals"": [""MRxDEq5"", ""StatePreamble"", ""StateSFD""],
    ""Signal Explanations"": {
        ""MRxDEq5"": ""signal indicating that the received data does not match the value 5"",
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if all conditions in the antecedent hold then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition for received data not matching the value 5 is met while the state machine is in the preamble state, then on the next cycle the machine will not be in the SFD state""
},
""Assertion 19"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StateSFD == 0)"",
    ""Signals"": [""MRxDV"", ""StateSFD""],
    ""Signal Explanations"": {
        ""MRxDV"": ""signal indicating that the received data is valid"",
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the valid received data condition is inactive, then on the next cycle the state machine will not be in the SFD state""
},
""Assertion 20"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartIdle == 1) |=> (StateDrop == 0)"",
    ""Signals"": [""StartIdle"", ""StateDrop""],
    ""Signal Explanations"": {
        ""StartIdle"": ""signal indicating when the state machine should transition to the idle state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the idle state is active, then on the next cycle the state machine will not be in the drop state""
},
""Assertion 21"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StateDrop == 1)"",
    ""Signals"": [""StartDrop"", ""StateDrop""],
    ""Signal Explanations"": {
        ""StartDrop"": ""signal indicating when the state machine should transition to the drop state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the drop state is active, then on the following cycle the state machine will be in the drop state""
},
""Assertion 22"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateDrop == 1 & StartIdle == 0) |=> (StateDrop == 1)"",
    ""Signals"": [""StateDrop"", ""StartIdle""],
    ""Signal Explanations"": {
        ""StateDrop"": ""signal indicating that the state machine is in the drop state"",
        ""StartIdle"": ""signal indicating when the state machine should transition to the idle state""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if the combined condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the machine is in the drop state and the condition for transitioning to idle is not active, then on the next cycle the machine will remain in the drop state""
},
""Assertion 23"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateSFD == 1 & StartDrop == 0) |=> (StateDrop == 0)"",
    ""Signals"": [""StateSFD"", ""StartDrop"", ""StateDrop""],
    ""Signal Explanations"": {
        ""StateSFD"": ""signal indicating that the state machine is in the SFD state"",
        ""StartDrop"": ""signal indicating when the state machine should transition to the drop state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if the antecedent holds then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the machine is in the SFD state and the condition for transitioning to the drop state is inactive, then on the next cycle the machine will not be in the drop state""
},
""Assertion 24"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData[0] == 1 & StartDrop == 0) |=> (StateDrop == 0)"",
    ""Signals"": [""StateData[0]"", ""StartDrop"", ""StateDrop""],
    ""Signal Explanations"": {
        ""StateData[0]"": ""signal representing the first part of the data state"",
        ""StartDrop"": ""signal indicating when the state machine should transition to the drop state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if the combined condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the first part of the data state is active and the condition to transition to drop is inactive, then on the next cycle the machine will not be in the drop state""
},
""Assertion 25"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StatePreamble == 1) |=> (StateDrop == 0)"",
    ""Signals"": [""StatePreamble"", ""StateDrop""],
    ""Signal Explanations"": {
        ""StatePreamble"": ""signal indicating that the state machine is in the preamble state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the machine is in the preamble state, then on the next cycle it will not be in the drop state""
},
""Assertion 26"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StateData1 == 1) |=> (StateDrop == 0)"",
    ""Signals"": [""StateData1"", ""StateDrop""],
    ""Signal Explanations"": {
        ""StateData1"": ""signal representing the second part of the data state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the indicator for the second part of the data state is active, then on the next cycle the machine will not be in the drop state""
},
""Assertion 27"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StateDrop == 0)"",
    ""Signals"": [""MRxDV"", ""StateDrop""],
    ""Signal Explanations"": {
        ""MRxDV"": ""signal indicating that the received data is valid"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the valid received data condition is inactive, then on the next cycle the machine will not be in the drop state""
},
""Assertion 28"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(Transmitting == 0 & StateIdle == 1) |=> (StateDrop == 0)"",
    ""Signals"": [""Transmitting"", ""StateIdle"", ""StateDrop""],
    ""Signal Explanations"": {
        ""Transmitting"": ""signal indicating that the transmitter is active"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state"",
        ""StateDrop"": ""signal indicating that the state machine is in the drop state""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""&"": ""logical AND operator"",
        ""|=>"": ""implication operator asserting that if the combined condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the transmitter is inactive and the machine is in the idle state, then on the next cycle the machine will not be in the drop state""
},
""Assertion 29"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartIdle == 1) |=> (StateIdle == 1)"",
    ""Signals"": [""StartIdle"", ""StateIdle""],
    ""Signal Explanations"": {
        ""StartIdle"": ""signal indicating when the state machine should transition to the idle state"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the idle state is active, then on the next cycle the machine will be in the idle state""
},
""Assertion 30"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartDrop == 1) |=> (StateIdle == 0)"",
    ""Signals"": [""StartDrop"", ""StateIdle""],
    ""Signal Explanations"": {
        ""StartDrop"": ""signal indicating when the state machine should transition to the drop state"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the drop state is active, then on the next cycle the machine will not be in the idle state""
},
""Assertion 31"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartSFD == 1) |=> (StateIdle == 0)"",
    ""Signals"": [""StartSFD"", ""StateIdle""],
    ""Signal Explanations"": {
        ""StartSFD"": ""signal indicating when the state machine should transition to the SFD state"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the SFD state is active, then on the next cycle the machine will not be in the idle state""
},
""Assertion 32"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(StartPreamble == 1) |=> (StateIdle == 0)"",
    ""Signals"": [""StartPreamble"", ""StateIdle""],
    ""Signal Explanations"": {
        ""StartPreamble"": ""signal indicating when the state machine should transition to the preamble state"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the condition that triggers transitioning to the preamble state is active, then on the next cycle the machine will not be in the idle state""
},
""Assertion 33"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 1) |=> (StateIdle == 0)"",
    ""Signals"": [""MRxDV"", ""StateIdle""],
    ""Signal Explanations"": {
        ""MRxDV"": ""signal indicating that the received data is valid"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the valid received data condition is active, then on the next cycle the machine will not be in the idle state""
},
""Assertion 34"": {
    ""clock signal condition"": ""@(posedge MRxClk)"",
    ""disable condition"": """",
    ""logical expression"": ""(MRxDV == 0) |=> (StateIdle == 1)"",
    ""Signals"": [""MRxDV"", ""StateIdle""],
    ""Signal Explanations"": {
        ""MRxDV"": ""signal indicating that the received data is valid"",
        ""StateIdle"": ""signal indicating that the state machine is in the idle state""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks equality (is equal to)"",
        ""|=>"": ""implication operator asserting that if the condition holds then the result must hold in the next cycle""
    },
    ""Assertion Explaination"": ""if the valid received data condition is inactive, then on the next cycle the machine will be in the idle state""
}
}","{
""Assertion 1"": ""assert property (MRxDV && ~MRxDEq5 &&                   ((StateIdle && ~Transmitting) ||                    (StateSFD && MRxDEqD) ||                    |StateData ||                    StartDrop ||                    StartIdle ||                    StartData1 ||                    StartData0 ||                    StartSFD ||                    StartPreamble ||                    (StateDrop || StatePreamble || |StateData)));"",
""Assertion 2"": ""assert property (StartDrop -> ##1 !StatePreamble);"",
""Assertion 3"": ""assert property (StateSFD == 1'b1 |-> StatePreamble == 1'b0);"",
""Assertion 4"": ""assert property (StateData0 ##1 !StatePreamble);"",
""Assertion 5"": ""assert property (StateDrop |-> !StatePreamble);"",
""Assertion 6"": ""assert property (StateData[1] == 1'b1 |=> (StatePreamble == 1'b0));"",
""Assertion 7"": ""assert property (StatePreamble && ~MRxDEq5 && MRxDV |-> StatePreamble);"",
""Assertion 8"": ""assert property (MRxDEq5 |-> (StatePreamble == 1'b0));"",
""Assertion 9"": ""assert property ((~MRxDV) || (StatePreamble[1:0] == 2'b00));"",
""Assertion 10"": ""assert property ((MRxDV & MRxDEq5 & (StateIdle & ~Transmitting)) | (MRxDV & MRxDEq5 & StatePreamble) | (MRxDV & MRxDEq5 & StateDrop)) |=> (StateSFD));"",
""Assertion 11"": ""assert property (StartIdle | StartDrop | StartPreamble -> ##1 !StateSFD);"",
""Assertion 12"": ""assert property (StartDrop |=> !StateSFD);"",
""Assertion 13"": ""assert property (StartData0 | StartData1 -> (StateSFD == 1'b0));"",
""Assertion 14"": ""assert property (StartPreamble |-> (StateSFD == 1'b0));"",
""Assertion 15"": ""assert property (StateSFD && !StartIdle && !MRxDEqD |-> StateSFD);"",
""Assertion 16"": ""assert property (StateData[0] == 1'b1 |-> StateSFD == 1'b0);"",
""Assertion 17"": ""assert property (StateDrop |=> !StateSFD);"",
""Assertion 18"": ""assert property (StatePreamble && (MRxDEq5 == 0) |-> (StateSFD == 0));"",
""Assertion 19"": ""assert property (MRxDV == 0 |-> StateSFD == 0);"",
""Assertion 20"": ""assert property (StartIdle | StartPreamble | StartSFD | StartData0 | StartData1 | StartDrop | Transmitting | MRxDV | ~MRxDEq5 | ~MRxDEqD | ~IFGCounterEq24 | ~ByteCntMaxFrame | ~ByteCntEq0 | ~ByteCntGreat2 | Reset | MRxClk | StateIdle | (StateData[1:0] != 2'b10));"",
""Assertion 21"": ""assert property (StartDrop |-> next(StateDrop));"",
""Assertion 22"": ""assert property (StateDrop == 1'b1 && !(StartIdle) |=> (StateDrop == 1'b1));"",
""Assertion 23"": ""assert property (StateSFD && !StartDrop |-> !StateDrop);"",
""Assertion 24"": ""assert property (StateData[1] == 1'b1 && StartDrop == 1'b0 |-> StateDrop[1] == 1'b0);"",
""Assertion 25"": ""assert property (StatePreamble |-> !StateDrop);"",
""Assertion 26"": ""assert property ((StateData[1] == 1'b1) |-> (!StateDrop));"",
""Assertion 27"": ""assert property (MRxDV == 0 |-> StateDrop[1] == 0);"",
""Assertion 28"": ""assert property (Transmitting == 1'b0 && StateIdle == 1'b1 |-> (StateDrop == 1'b0));"",
""Assertion 29"": ""assert property (StartIdle | StartPreamble | StartDrop | StartSFD | StartData0 | StartData1 | ~StateIdle);"",
""Assertion 30"": ""assert property (StartDrop |-> not(StateIdle));"",
""Assertion 31"": ""assert property ( (MRxDV && MRxDEq5 && (StateIdle && ~Transmitting)) || StatePreamble || StateDrop || (|StateData) || (MRxDV && MRxDEq5 && StateIdle) || ~StateIdle );"",
""Assertion 32"": ""assert property (StartPreamble |-> !StateIdle);"",
""Assertion 33"": ""assert property (MRxDV |-> !StateIdle);"",
""Assertion 34"": ""assert property (MRxDV == 1'b0 |-> (StateIdle == 1'b1));""
}"
Gray_To_Binary,"module Gray_To_Binary #(
	parameter DATA_WIDTH = 3
) 
(
          input clk,
          input rst,
	input [DATA_WIDTH-1:0]        gray,
	output logic [DATA_WIDTH-1:0] bin
);

wire [DATA_WIDTH-1:0] tmp [DATA_WIDTH-1:1]; 
assign tmp[1] = ( gray >> 1 ) ^ gray;

genvar x;
generate
	for( x = 2; x < DATA_WIDTH ; x++) begin
		assign tmp[x] = ( gray >> x ) ^ tmp[x-1];
	end 
endgenerate

assign bin = tmp[DATA_WIDTH-1];

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (~rst)"",
""logical expression"": ""gray_f == gray"",
""Signals"": [""gray_f"", ""gray""],
""Signal Explanations"": {
          ""gray_f"": ""the generated gray code obtained by converting the binary output; it should match the input gray code"",
          ""gray"": ""the input gray code to be converted""
},
""Logical Operators"": [""==""],
""Logical Operators Explanation"": {
          ""=="": ""checks if the two signals are equal""
},
""Assertion Explaination"": ""if the generated gray code from the binary conversion is equal to the provided gray code, then the conversion process is correct""
}
}","{
""Assertion 1"": ""assert property (bin == (gray ^ (gray >> 1))                   && (bin[DATA_WIDTH-1:1] == (gray[DATA_WIDTH-1:1] ^ (gray[DATA_WIDTH-1:1] >> 1)))                   && (bin[DATA_WIDTH-2:2] == (gray[DATA_WIDTH-2:2] ^ (gray[DATA_WIDTH-2:2] >> 2)))                   && (bin[DATA_WIDTH-3:3] == (gray[DATA_WIDTH-3:3] ^ (gray[DATA_WIDTH-3:3] >> 3)))                   && (bin[DATA_WIDTH-4:4] == (gray[DATA_WIDTH-4:4] ^ (gray[DATA_WIDTH-4:4] >> 4)))                   && (bin[DATA_WIDTH-5:5] == (gray[DATA_WIDTH-5:5] ^ (gray[DATA_WIDTH-5:5] >> 5)))                   && (bin[DATA_WIDTH-6:6] == (gray[DATA_WIDTH-6:6] ^ (gray[DATA_WIDTH-6:6] >> 6)))                   && (bin[DATA_WIDTH-7:7] == (gray[DATA_WIDTH-7:7] ^ (gray[DATA_WIDTH-7:7] >> 7)))                   && (bin[DATA_WIDTH-8:8] == (gray[DATA_WIDTH-8:8] ^ (gray[DATA_WIDTH-8:8] >> 8)))                   && (bin[DATA_WIDTH-9:9] == (gray[DATA_WIDTH-9:9] ^ (gray[DATA_WIDTH-9:9] >> 9)))                   && (bin[DATA_WIDTH-10:10] == (gray[DATA_WIDTH-10:10] ^ (gray[DATA_WIDTH-10:10] >> 10)))                   && (bin[DATA_WIDTH-11:11] == (gray[DATA_WIDTH-11:11] ^ (gray[DATA_WIDTH-11:11] >> 11)))                   && (bin[DATA_WIDTH-12:12] == (gray[DATA_WIDTH-12:12] ^ (gray[DATA_WIDTH-12:12] >> 12)))                   && (bin[DATA_WIDTH-13:13] == (gray[DATA_WIDTH-13:13] ^ (gray[DATA_WIDTH-13:13] >> 13)))                   && (bin[DATA_WIDTH-14:14] == (gray[DATA_WIDTH-14:14] ^ (gray[DATA_WIDTH-14:14] >> 14)))                   && (bin[DATA_WIDTH-15:15] == (gray[DATA_WIDTH-15:15] ^ (gray[DATA_WIDTH-15:15] >> 15)))                   && (bin[1] == (gray[1] ^ (gray[1] >> 1)))                   && (bin[0] == gray[0]));""
}"
delay,"// Greg Stitt
// University of Florida
//
// This file illustrates how to implement a versatile delay module structurally
// as a sequence of registers. It introduces the unpacked array construct.


// Module: register
// Description: Register with flexible parameters.

module register
  #(
    parameter WIDTH = 8,
    parameter logic HAS_ASYNC_RESET = 1'b1,
    parameter logic RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic 	     en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );

   generate
      if (HAS_ASYNC_RESET) begin
	 always_ff @(posedge clk or posedge rst) begin
	    if (rst == RESET_ACTIVATION_LEVEL)
	      out <= RESET_VALUE;
	    else if (en)
	      out <= in;    	
	 end
      end
      else begin
	 always_ff @(posedge clk) begin
	    if (rst == RESET_ACTIVATION_LEVEL)
	      out <= RESET_VALUE;	      
	    else if (en)
	      out <= in;
	 end	
      end
   endgenerate
endmodule // register


// Module: delay
// Description: This module delays a provided WIDTH-bit input by CYCLES cycles.
// It also has configuration parmaters for reset type, activation level, and
// value. Finally, it has an enable signal that stalls the delay when not
// not asserted.
//
// See delay.pdf for an illustration of the schematic.

module delay
  #(
    parameter int 		CYCLES=4,
    parameter int 		WIDTH=8,
    parameter logic 		HAS_ASYNC_RESET = 1'b1,
    parameter logic 		RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk, rst, en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );

   // Ideally, every module would validate its parameters because often
   // certain values are undefined. For example, a negative cycles delay
   // doesn't make sense. Similarly, only positive widths make sense.
   // Unfortunately, parameter validation is somewhat lacking in SystemVerilog,
   // at least in the older versions. Some of the possibilities are shown
   // below.
   
   if (CYCLES < 0) begin
      // One workaround to missing validation constructs is to simply call
      // an undefined module with a name that specifies the error.
      cycles_parameter_must_be_ge_0();

      // The 2009 SV standard defines the $error function, which prints during
      // compilation. However, not every tool supports it yet. Also, despite 
      // the name, $error only created a warning in the version of Quartus
      // used for testing.
      //
      // $error(""ERROR: CYCLES parameter must be >= 0."");

      // $fatal does caused Quartus synthesis to terminate, but is not 
      // supported by every synthesis tool.
      //
      // $fatal(""ERROR: CYCLES parameter must be >= 0."");
   end
   if (WIDTH < 1) begin
      width_parameter_must_be_gt_0();      
      //$error(""ERROR: WIDTH parameter must be >= 1."");
      //$fatal(1, ""ERROR: WIDTH parameter must be >= 1."");      
   end

   // Create an array of WIDTH-bit signals, which will connect all the registers
   // together (see delay.pdf). The array uses CYCLES+1 elements because there
   // are CYCLES register outputs, plus the input to the first register.
   //
   // When creating an array this way, the CYCLES+1 section creates an unpacked
   // array. The [WIDTH-1:0] section creates a packed array. Packed arrays and
   // unpacked arrays support different operations, but generally you will use
   // the unpacked section to specify bits, and the unpacked section to specify
   // the total number of elements.
   //
   // The CYCLES+1 notation is short for [0:CYCLES+1-1]. A common convention is
   // to use ""downto"" syntax for the packed array, and ""to"" syntax for the
   // unpacked array. Most people are used to thinking of arrays starting at 
   // index 0, and the MSB starting at the highest number.
   //
   // VHDL COMPARISON: packed arrays are missing from VHDL, where you instead 
   // have to create a custom array type. In SV, every signal can become an
   // unpacked array simply by adding [], which is very convenient.
   logic [WIDTH-1:0] 	     regs[CYCLES+1];
   
   if (CYCLES == 0) begin
      // For CYCLES == 0, there is no delay, so just use a wire.
      assign out = in;
   end
   else if (CYCLES > 0) begin
      // Create a sequence of CYCLES registers, where each register adds one
      // cycle to the delay.
      
      for (genvar i=0; i < CYCLES; i++) begin : reg_array
	 register #(.WIDTH(WIDTH),
		    .HAS_ASYNC_RESET(HAS_ASYNC_RESET),
		    .RESET_ACTIVATION_LEVEL(RESET_ACTIVATION_LEVEL),
		    .RESET_VALUE(RESET_VALUE))
	 reg_array (.in(regs[i]), .out(regs[i+1]), .*);	 	 
      end

      // The first register's input comes from the delay's input.
      assign regs[0] = in;
      
      // The last register's output goes to the delay's output.
      assign out = regs[CYCLES];      
      
   end       

endmodule

","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""count < CYCLES || out == $past(in, CYCLES, en)"",
    ""Signals"": [""count"", ""CYCLES"", ""out"", ""in"", ""en""],
    ""Signal Explanations"": {
      ""count"": ""a counter that tracks how many delay stages have been clocked in"",
      ""CYCLES"": ""the configured number of cycles that the delay is intended to span"",
      ""out"": ""the final output value produced by the module after the delay"",
      ""in"": ""the input value provided to the delay module"",
      ""en"": ""an enable control signal that allows the delay to progress when asserted""
    },
    ""Logical Operators"": [""<"", ""||"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""<"": ""checks if one value is less than another"",
      ""||"": ""logical OR, meaning that if one of the conditions is true, the whole expression is true"",
      ""=="": ""determines equality between two values"",
      ""$past"": ""returns a signal's value from a specified number of previous cycles under an enable condition""
    },
    ""Assertion Explaination"": ""It states that either the delay stage counter is less than the configured delay cycle count using a less-than operator, or, by comparing for equality with a past value retrieved after the configured number of cycles (conditioned on the enable signal), the module output is exactly the same as the input from that many cycles earlier.""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""count == CYCLES || out == RESET_VALUE"",
    ""Signals"": [""count"", ""CYCLES"", ""out"", ""RESET_VALUE""],
    ""Signal Explanations"": {
      ""count"": ""a counter that tracks how many delay stages have been clocked in"",
      ""CYCLES"": ""the configured number of cycles that the delay is intended to span"",
      ""out"": ""the final output value produced by the module after the delay"",
      ""RESET_VALUE"": ""the value that the module output should assume when a reset is active""
    },
    ""Logical Operators"": [""=="", ""||""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks whether two values are equal"",
      ""||"": ""logical OR, meaning that if one of the conditions is true, the whole expression is true""
    },
    ""Assertion Explaination"": ""It requires that either the delay stage counter is exactly equal to the configured delay cycle count using an equality operator, or, if that is not the case, the module output must be equal to the predefined reset value, as determined by another equality operator combined with a logical OR.""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""!en |=> $stable(out)"",
    ""Signals"": [""en"", ""out""],
    ""Signal Explanations"": {
      ""en"": ""an enable control signal that allows the delay to progress when asserted"",
      ""out"": ""the final output value produced by the module after the delay""
    },
    ""Logical Operators"": [""!"", ""|=>"", ""$stable""],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, indicating the opposite of the signal's value"",
      ""|=>"": ""non-overlapping implication which means that if the antecedent (left-hand condition) is true at the current cycle, then the consequent (right-hand condition) must hold at the next cycle"",
      ""$stable"": ""ensures that a value remains unchanged from one clock cycle to the next""
    },
    ""Assertion Explaination"": ""It indicates that when the enable control is not active (as determined by a logical negation), then in the subsequent evaluation the output must remain unchanged, as enforced by the non-overlapping implication together with a stability check.""
  }
}","{
""Assertion 1"": ""assert property (CYCLES > 0 -> (delay_stage < CYCLES) || (en && out === regs[CYCLES - delay_stage]));"",
""Assertion 2"": ""assert property ( (out === in) || (out === RESET_VALUE) );"",
""Assertion 3"": ""assert property (en == 1'b0 |=> out == out[1]);""
}"
arb2,"module arb2(clk, rst, req1, req2, gnt1, gnt2);

input clk, rst;
input req1, req2;
output gnt1, gnt2;

reg state;
reg gnt1, gnt2;

always @ (posedge clk or posedge rst)
	if (rst)
		state <= 0;
	else
		state <= gnt1;

always @ (*)
	if (state)
	begin
		gnt1 = req1 & ~req2;
		gnt2 = req2;
	end
	else
	begin
		gnt1 = req1;
		gnt2 = req2 & ~req1;
	end

endmodule
","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(state == 1 & req2 == 1) |-> (gnt1 == 0)"",
""Signals"": [""state"", ""req2"", ""gnt1""],
""Signal Explanations"": {
          ""state"": ""internal control signal of the arbiter"",
          ""req2"": ""second request input signal"",
          ""gnt1"": ""first grant output signal""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""&"": ""logical AND"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the internal control signal is equal to one and the second request input signal is active, then it implies that the first grant output signal must be inactive""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req1 == 1 & state == 0) |-> (gnt1 == 1)"",
""Signals"": [""req1"", ""state"", ""gnt1""],
""Signal Explanations"": {
          ""req1"": ""first request input signal"",
          ""state"": ""internal control signal of the arbiter"",
          ""gnt1"": ""first grant output signal""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""&"": ""logical AND"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the first request input signal is active and the internal control signal is equal to zero, then it implies that the first grant output signal must be active""
},
""Assertion 3"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req1 == 0) |-> (gnt1 == 0)"",
""Signals"": [""req1"", ""gnt1""],
""Signal Explanations"": {
          ""req1"": ""first request input signal"",
          ""gnt1"": ""first grant output signal""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the first request input signal is inactive then it implies that the first grant output signal must be inactive""
},
""Assertion 4"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req1 == 1 & req2 == 0) |-> (gnt1 == 1)"",
""Signals"": [""req1"", ""req2"", ""gnt1""],
""Signal Explanations"": {
          ""req1"": ""first request input signal"",
          ""req2"": ""second request input signal"",
          ""gnt1"": ""first grant output signal""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""&"": ""logical AND"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the first request input signal is active and the second request input signal is inactive, then it implies that the first grant output signal must be active""
},
""Assertion 5"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req1 == 1 & state == 0) |-> (gnt2 == 0)"",
""Signals"": [""req1"", ""state"", ""gnt2""],
""Signal Explanations"": {
          ""req1"": ""first request input signal"",
          ""state"": ""internal control signal of the arbiter"",
          ""gnt2"": ""second grant output signal""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""&"": ""logical AND"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the first request input signal is active and the internal control signal is equal to zero, then it implies that the second grant output signal must be inactive""
},
""Assertion 6"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req2 == 1 & state == 1) |-> (gnt2 == 1)"",
""Signals"": [""req2"", ""state"", ""gnt2""],
""Signal Explanations"": {
          ""req2"": ""second request input signal"",
          ""state"": ""internal control signal of the arbiter"",
          ""gnt2"": ""second grant output signal""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""&"": ""logical AND"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the second request input signal is active and the internal control signal is equal to one, then it implies that the second grant output signal must be active""
},
""Assertion 7"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req2 == 0) |-> (gnt2 == 0)"",
""Signals"": [""req2"", ""gnt2""],
""Signal Explanations"": {
          ""req2"": ""second request input signal"",
          ""gnt2"": ""second grant output signal""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the second request input signal is inactive then it implies that the second grant output signal must be inactive""
},
""Assertion 8"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": """",
""logical expression"": ""(req2 == 1 & req1 == 0) |-> (gnt2 == 1)"",
""Signals"": [""req2"", ""req1"", ""gnt2""],
""Signal Explanations"": {
          ""req2"": ""second request input signal"",
          ""req1"": ""first request input signal"",
          ""gnt2"": ""second grant output signal""
},
""Logical Operators"": [""=="", ""&"", ""|->""],
""Logical Operators Explanation"": {
          ""=="": ""checks equality"",
          ""&"": ""logical AND"",
          ""|->"": ""non-overlapping implication; if the condition before this operator holds then the condition after must hold in the same evaluation""
},
""Assertion Explaination"": ""if the second request input signal is active and the first request input signal is inactive, then it implies that the second grant output signal must be active""
}
}","{
""Assertion 1"": ""assert property (state == 1 && req2 == 1 |-> gnt1 == 0);"",
""Assertion 2"": ""assert property (req1 == 1'b1 && state == 1'b0 |-> gnt1 == 1'b1);"",
""Assertion 3"": ""assert property (req1 == 0 |-> gnt1 == 0);"",
""Assertion 4"": ""assert property (req1 & ~req2 |-> gnt1);"",
""Assertion 5"": ""assert property (req1 && !state |-> !gnt2);"",
""Assertion 6"": ""assert property (req2 && state |-> gnt2);"",
""Assertion 7"": ""assert property (req2 == 0 |-> gnt2 == 0);"",
""Assertion 8"": ""assert property (req2 && ~req1 |-> gnt2);""
}"
Edge_Detector,"module Edge_Detector (
	input  clk,
	input  resetn,
	input  din,
	output dout
);

// trigger a pulse 1 cycle after din goes up
reg  edge_seen_q;
wire edge_seen_next;
reg  pulse_q;
wire pulse_next;
assign edge_seen_next = ( din & ~edge_seen_q) 
					  | ( din & edge_seen_q );
assign pulse_next      = din & ~edge_seen_q;
 
always @(posedge clk)
begin
	if ( ~resetn ) begin
		edge_seen_q <= 1'b0;
		pulse_q     <= 1'b0;
	end else begin
		edge_seen_q <= edge_seen_next;
		pulse_q     <= pulse_next;
	end
end

assign dout = pulse_q;

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (~resetn)"",
""logical expression"": ""$rose(din_f_q) == dout"",
""Signals"": [""din_f_q"", ""dout""],
""Signal Explanations"": {
  ""din_f_q"": ""a register that holds the delayed version of the input used to check for a low-to-high transition"",
  ""dout"": ""the output signal that produces a one-cycle pulse following the detection of a rising edge""
},
""Logical Operators"": [""$rose"", ""==""],
""Logical Operators Explanation"": {
  ""$rose"": ""evaluates to true when its argument transitions from low to high, indicating a rising edge"",
  ""=="": ""compares two values to determine if they are equal""
},
""Assertion Explaination"": ""if the delayed input signal experiences a low-to-high transition then the one-cycle pulse generating signal must be asserted""
}
}","{
""Assertion 1"": ""assert property (din[1] && !din[0] |-> pulse_q);""
}"
VGA,"module VGA #(localparam  size = 1, localparam h_bits = 7, localparam v_bits = 5) (input clk, input rst, output reg disp_ena, output reg n_blank, output reg n_sync, output reg [h_bits-1:0] col, output reg [v_bits-1:0] row);

	localparam h_pixels = 50*size;
	localparam h_pulse = 5*size;
	localparam h_bp = 8*size;
	localparam h_fp = 3*size;
	localparam h_pol = 0;

	localparam v_pixels =  25*size;
	localparam v_pulse = size;
	localparam v_bp = 1*size;
	localparam v_fp = size;
	localparam v_pol = 1;

	localparam h_period = h_pulse + h_bp + h_pixels + h_fp;
	localparam v_period = v_pulse + v_bp + v_pixels + v_fp;

	reg [h_bits-1:0] h_cnt;
	reg [v_bits-1:0] v_cnt;
	reg h_sync;
	reg v_sync;
	always @(posedge clk) begin
		if(rst == 1) begin
			h_cnt = 0;
			v_cnt = 0;
			h_sync = ~h_sync;
			v_sync = ~v_sync;
			disp_ena = 0;
			col = 0;
			row = 0;
		end
		else begin
			if(h_cnt < h_period - 1)
				h_cnt = h_cnt + 1;
			else begin
				h_cnt = 0;
				if(v_cnt < v_period - 1)
					v_cnt = v_cnt + 1;
				else
					v_cnt = 0;
			end
			if((h_cnt < (h_pixels + h_fp)) | (h_cnt >= (h_pixels + h_fp + h_pulse)))
				h_sync = ~h_sync;
			else
				h_sync = h_pol;

			if((v_cnt < (v_pixels + v_fp)) | (v_cnt >= (v_pixels + v_fp + v_pulse)))
				v_sync = ~v_sync;
			else
				v_sync = v_pol;

			if(h_cnt < h_pixels)
				col = h_cnt;

			if(v_cnt < v_pixels)
				row = v_cnt;

			if(h_cnt < h_pixels & v_cnt < v_pixels)
				disp_ena = 1;
			else
				disp_ena = 0;
		end
	end
endmodule
","{
""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""rst == 1 || disp_ena == 1"",
    ""Signals"": [""rst"", ""disp_ena""],
    ""Signal Explanations"": {
        ""rst"": ""reset input signal of the verilog module"",
        ""disp_ena"": ""display enable signal that is active when the current pixel is within the valid display area""
    },
    ""Logical Operators"": [""=="", ""||"", ""==""],
    ""Logical Operators Explanation"": {
        ""=="": ""checks if two values are equal"",
        ""||"": ""logical OR; returns true if at least one of the operands is true""
    },
    ""Assertion Explaination"": ""it is eventually ensured that either the reset input signal is equal to its active value as determined by an equality check, or the display enable signal is equal to its active value as determined by an equality check; the OR operation combines these conditions so that if one holds, the overall requirement is satisfied""
}
}","{
""Assertion 1"": ""assert property (rst == 1 || disp_ena == 1);""
}"
simple_router,"module simple_router #(
	parameter DATA_WIDTH = 32
) (
  input  rst,
  input  clk,
  input  [DATA_WIDTH-1:0] din,
  input  din_en,
  input  [1:0] addr,
  output logic [DATA_WIDTH-1:0] dout0,
  output logic [DATA_WIDTH-1:0] dout1,
  output logic [DATA_WIDTH-1:0] dout2,
  output logic [DATA_WIDTH-1:0] dout3
);

// data should be forced to 0 when not driven 
assign dout0 = {DATA_WIDTH{din_en & ( addr == 2'd0 )}} & din; 
assign dout1 = {DATA_WIDTH{din_en & ( addr == 2'd1 )}} & din; 
assign dout2 = {DATA_WIDTH{din_en & ( addr == 2'd2 )}} & din; 
assign dout3 = {DATA_WIDTH{din_en & ( addr == 2'd3 )}} & din; 


endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""din_en | ((dout0 == 0) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0))"",
    ""Signals"": [
      ""din_en"",
      ""dout0"",
      ""dout1"",
      ""dout2"",
      ""dout3""
    ],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal indicating that input data is active"",
      ""dout0"": ""data output for channel 0 that carries input data when selected, otherwise zero"",
      ""dout1"": ""data output for channel 1 that carries input data when selected, otherwise zero"",
      ""dout2"": ""data output for channel 2 that carries input data when selected, otherwise zero"",
      ""dout3"": ""data output for channel 3 that carries input data when selected, otherwise zero""
    },
    ""Logical Operators"": [
      ""|"",
      ""&"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|"": ""logical OR, condition is true if at least one operand is true"",
      ""&"": ""logical AND, condition is true if both operands are true"",
      ""=="": ""equality operator that checks if two values are the same""
    },
    ""Assertion Explaination"": ""Either the input data enable signal is active or all channel outputs are zero.""
  },
  ""Assertion 2"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd0)) | ((dout0 == din) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0))"",
    ""Signals"": [
      ""din_en"",
      ""addr"",
      ""dout0"",
      ""din"",
      ""dout1"",
      ""dout2"",
      ""dout3""
    ],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal indicating that input data is active"",
      ""addr"": ""input address used to select the output channel"",
      ""dout0"": ""data output for channel 0 that should carry the input data when selected"",
      ""din"": ""input data to be routed"",
      ""dout1"": ""data output for channel 1 that remains zero when channel 0 is selected"",
      ""dout2"": ""data output for channel 2 that remains zero when channel 0 is selected"",
      ""dout3"": ""data output for channel 3 that remains zero when channel 0 is selected""
    },
    ""Logical Operators"": [
      ""~"",
      ""&"",
      ""=="",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT that inverts the condition"",
      ""&"": ""logical AND ensuring both conditions occur simultaneously"",
      ""=="": ""equality operator that checks if two values are the same"",
      ""|"": ""logical OR, condition is true if at least one operand is true""
    },
    ""Assertion Explaination"": ""Either the condition for channel 0 to be active is not met, or when it is active the output routing delivers the input data to channel 0 and holds all other channel outputs at zero.""
  },
  ""Assertion 3"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd1)) | ((dout1 == din) & (dout0 == 0) & (dout2 == 0) & (dout3 == 0))"",
    ""Signals"": [
      ""din_en"",
      ""addr"",
      ""dout1"",
      ""din"",
      ""dout0"",
      ""dout2"",
      ""dout3""
    ],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal indicating that input data is active"",
      ""addr"": ""input address used to select the output channel"",
      ""dout1"": ""data output for channel 1 that should carry the input data when selected"",
      ""din"": ""input data to be routed"",
      ""dout0"": ""data output for channel 0 that remains zero when channel 1 is selected"",
      ""dout2"": ""data output for channel 2 that remains zero when channel 1 is selected"",
      ""dout3"": ""data output for channel 3 that remains zero when channel 1 is selected""
    },
    ""Logical Operators"": [
      ""~"",
      ""&"",
      ""=="",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT that inverts the condition"",
      ""&"": ""logical AND ensuring both conditions occur simultaneously"",
      ""=="": ""equality operator that checks if two values are the same"",
      ""|"": ""logical OR, condition is true if at least one operand is true""
    },
    ""Assertion Explaination"": ""Either the condition for channel 1 to be active is not met, or when active the routing ensures that channel 1 carries the input data while all other channel outputs remain zero.""
  },
  ""Assertion 4"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd2)) | ((dout2 == din) & (dout0 == 0) & (dout1 == 0) & (dout3 == 0))"",
    ""Signals"": [
      ""din_en"",
      ""addr"",
      ""dout2"",
      ""din"",
      ""dout0"",
      ""dout1"",
      ""dout3""
    ],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal indicating that input data is active"",
      ""addr"": ""input address used to select the output channel"",
      ""dout2"": ""data output for channel 2 that should carry the input data when selected"",
      ""din"": ""input data to be routed"",
      ""dout0"": ""data output for channel 0 that remains zero when channel 2 is selected"",
      ""dout1"": ""data output for channel 1 that remains zero when channel 2 is selected"",
      ""dout3"": ""data output for channel 3 that remains zero when channel 2 is selected""
    },
    ""Logical Operators"": [
      ""~"",
      ""&"",
      ""=="",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT that inverts the condition"",
      ""&"": ""logical AND ensuring both conditions occur simultaneously"",
      ""=="": ""equality operator that checks if two values are the same"",
      ""|"": ""logical OR, condition is true if at least one operand is true""
    },
    ""Assertion Explaination"": ""Either the condition for channel 2 to be active is not met, or when active the routing ensures that channel 2 carries the input data while all other channel outputs remain zero.""
  },
  ""Assertion 5"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""~(din_en & (addr == 2'd3)) | ((dout3 == din) & (dout0 == 0) & (dout1 == 0) & (dout2 == 0))"",
    ""Signals"": [
      ""din_en"",
      ""addr"",
      ""dout3"",
      ""din"",
      ""dout0"",
      ""dout1"",
      ""dout2""
    ],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal indicating that input data is active"",
      ""addr"": ""input address used to select the output channel"",
      ""dout3"": ""data output for channel 3 that should carry the input data when selected"",
      ""din"": ""input data to be routed"",
      ""dout0"": ""data output for channel 0 that remains zero when channel 3 is selected"",
      ""dout1"": ""data output for channel 1 that remains zero when channel 3 is selected"",
      ""dout2"": ""data output for channel 2 that remains zero when channel 3 is selected""
    },
    ""Logical Operators"": [
      ""~"",
      ""&"",
      ""=="",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT that inverts the condition"",
      ""&"": ""logical AND ensuring both conditions occur simultaneously"",
      ""=="": ""equality operator that checks if two values are the same"",
      ""|"": ""logical OR, condition is true if at least one operand is true""
    },
    ""Assertion Explaination"": ""Either the condition for channel 3 to be active is not met, or when active the routing ensures that channel 3 carries the input data while all other channel outputs remain zero.""
  }
}","{
""Assertion 1"": ""assert property (din_en | (dout0 == 0 && dout1 == 0 && dout2 == 0 && dout3 == 0));"",
""Assertion 2"": ""assert property (addr == 2'd0 -> (dout0 == din && dout1 == 0 && dout2 == 0 && dout3 == 0));"",
""Assertion 3"": ""assert property (addr != 2'd1 || (dout1 == din && dout0 == 0 && dout2 == 0 && dout3 == 0));"",
""Assertion 4"": ""assert property ( ( addr != 2'd2 ) || ( ( dout2 == din ) && ( dout0 == 0 ) && ( dout1 == 0 ) && ( dout3 == 0 ) ) );"",
""Assertion 5"": ""assert property (addr == 2'd3 ? (dout3 == din && dout0 == 0 && dout1 == 0 && dout2 == 0) : (dout3 == 0));""
}"
a25_wishbone,"//////////////////////////////////////////////////////////////////
//                                                              //
//  Wishbone master interface for the Amber 25 core             //
//                                                              //
//  This file is part of the Amber project                      //
//  http://www.opencores.org/project,amber                      //
//                                                              //
//  Description                                                 //
//  Turns memory access requests from the execute stage and     //
//  instruction and data caches into wishbone bus cycles.       //
//  For 4-word read requests from either cache and swap         //
//  accesses ( read followed by write to the same address)      //
//  from the execute stage, a block transfer is done.           //
//  All other requests result in single word transfers.         //
//                                                              //
//  Write accesses can be done in a single clock cycle on       //
//  the wishbone bus, is the destination allows it. The         //
//  next transfer will begin immediately on the                 //
//  next cycle on the bus. This looks like a block transfer     //
//  and does hold ownership of the wishbone bus, preventing     //
//  the other master ( the ethernet MAC) from gaining           //
//  ownership between those two cycles. But otherwise it would  //
//  be necessary to insert a wait cycle after every write,      //
//  slowing down the performance of the core by around 5 to     //
//  10%.                                                        //
//                                                              //
//  Author(s):                                                  //
//      - Conor Santifort, csantifort.amber@gmail.com           //
//                                                              //
//////////////////////////////////////////////////////////////////
//                                                              //
// Copyright (C) 2011 Authors and OPENCORES.ORG                 //
//                                                              //
// This source file may be used and distributed without         //
// restriction provided that this copyright statement is not    //
// removed from the file and that any derivative work contains  //
// the original copyright notice and the associated disclaimer. //
//                                                              //
// This source file is free software; you can redistribute it   //
// and/or modify it under the terms of the GNU Lesser General   //
// Public License as published by the Free Software Foundation; //
// either version 2.1 of the License, or (at your option) any   //
// later version.                                               //
//                                                              //
// This source is distributed in the hope that it will be       //
// useful, but WITHOUT ANY WARRANTY; without even the implied   //
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      //
// PURPOSE.  See the GNU Lesser General Public License for more //
// details.                                                     //
//                                                              //
// You should have received a copy of the GNU Lesser General    //
// Public License along with this source; if not, download it   //
// from http://www.opencores.org/lgpl.shtml                     //
//                                                              //
//////////////////////////////////////////////////////////////////


module a25_wishbone
(
input                       quick_n_reset,
input                       i_clk,

    // Instruction Cache Accesses
input                       i_icache_req,
input                       i_icache_qword,
input       [31:0]          i_icache_address,
output      [31:0]          o_icache_read_data,
output                      o_icache_ready,

    // Data Cache Accesses
input                       i_exclusive,      // high for read part of swap access
input                       i_dcache_cached_req,
input                       i_dcache_uncached_req,
input                       i_dcache_qword,
input                       i_dcache_write,
input       [31:0]          i_dcache_write_data,
input       [3:0]           i_dcache_byte_enable,    // valid for writes only
input       [31:0]          i_dcache_address,
output      [31:0]          o_dcache_read_data,
output                      o_dcache_cached_ready,
output                      o_dcache_uncached_ready,

// Wishbone Bus
output reg  [31:0]          o_wb_adr,
output reg  [3:0]           o_wb_sel,
output reg                  o_wb_we ,
input       [31:0]          i_wb_dat,
output reg  [31:0]          o_wb_dat,
output reg                  o_wb_cyc,
output reg                  o_wb_stb,
input                       i_wb_ack,
input                       i_wb_err

);


localparam [3:0] WB_IDLE            = 3'd0,
                 WB_BURST1          = 3'd1,
                 WB_BURST2          = 3'd2,
                 WB_BURST3          = 3'd3,
                 WB_WAIT_ACK        = 3'd4;

reg     [2:0]               wishbone_st;

wire                        icache_read_req_c;
wire                        icache_read_qword_c;
wire    [31:0]              icache_read_addr_c;
wire                        dcache_read_qword_c;

wire                        dcache_req_c;
wire                        write_req_c;
wire                        dcache_cached_rreq_c;
wire                        dcache_cached_wreq_c;
wire                        dcache_uncached_rreq_c;
wire                        dcache_uncached_wreq_c;

wire                        dcache_cached_rreq_in;
wire                        dcache_cached_wreq_in;
wire                        dcache_uncached_rreq_in;
wire                        dcache_uncached_wreq_in;

reg                         dcache_cached_rreq_r;
reg                         dcache_cached_wreq_r;
reg                         dcache_uncached_rreq_r;
reg                         dcache_uncached_wreq_r;

wire                        dcache_cached_wready;
wire                        dcache_uncached_wready;
wire                        dcache_cached_rready;
wire                        dcache_uncached_rready;

wire                        start_access;
wire    [3:0]               byte_enable;
reg                         exclusive_access;
wire                        read_ack;
wire                        wait_write_ack;
reg                         icache_read_req_r;
reg                         icache_read_qword_r;
reg     [31:0]              icache_read_addr_r;
reg                         dcache_read_qword_r;
wire                        icache_read_req_in;
wire                        icache_read_ready;
reg                         servicing_dcache_cached_read_r;
reg                         servicing_dcache_uncached_read_r;
reg                         servicing_icache_r;
wire                        extra_write;
reg                         extra_write_r;
reg     [31:0]              extra_write_data_r;
reg     [31:0]              extra_write_address_r;
reg     [3:0]               extra_write_be_r;

assign read_ack                 = !o_wb_we && i_wb_ack;

assign dcache_cached_rready     = dcache_cached_rreq_r   && servicing_dcache_cached_read_r   && read_ack;
assign dcache_uncached_rready   = dcache_uncached_rreq_r && servicing_dcache_uncached_read_r && read_ack;


assign o_dcache_cached_ready    = dcache_cached_rready   || dcache_cached_wready;
assign o_dcache_uncached_ready  = dcache_uncached_rready || dcache_uncached_wready;
assign o_dcache_read_data       = i_wb_dat;
                                 
assign icache_read_ready        = servicing_icache_r && read_ack;
assign o_icache_ready           = icache_read_ready; 
assign o_icache_read_data       = i_wb_dat;


assign dcache_cached_rreq_in    = i_dcache_cached_req   && !i_dcache_write;
assign dcache_cached_wreq_in    = i_dcache_cached_req   &&  i_dcache_write;
assign dcache_uncached_rreq_in  = i_dcache_uncached_req && !i_dcache_write;
assign dcache_uncached_wreq_in  = i_dcache_uncached_req &&  i_dcache_write;
assign icache_read_req_in       = i_icache_req && !o_icache_ready;

assign dcache_cached_rreq_c     = ( dcache_cached_rreq_in   || dcache_cached_rreq_r   ) && !(servicing_dcache_cached_read_r   && read_ack);
assign dcache_uncached_rreq_c   = ( dcache_uncached_rreq_in || dcache_uncached_rreq_r ) && !(servicing_dcache_uncached_read_r && read_ack);

assign dcache_read_qword_c      = ( i_dcache_qword       || dcache_read_qword_r ) && !(servicing_dcache_cached_read_r && read_ack);

assign icache_read_req_c        = ( icache_read_req_in   || icache_read_req_r   ) && !(servicing_icache_r && read_ack);
assign icache_read_qword_c      = ( i_icache_qword       || icache_read_qword_r ) && !(servicing_icache_r && read_ack);
assign icache_read_addr_c       = i_icache_req ?  i_icache_address : icache_read_addr_r;

assign dcache_req_c             = dcache_cached_rreq_c || dcache_cached_wreq_c || dcache_uncached_rreq_c || dcache_uncached_wreq_c;
assign write_req_c              = dcache_cached_wreq_c || dcache_uncached_wreq_c;

assign start_access             = !wait_write_ack && (dcache_req_c || icache_read_req_c);

// For writes the byte enable is always 4'hf
assign byte_enable              = write_req_c ? i_dcache_byte_enable : 4'hf;
                                    

assign dcache_cached_wready     = (dcache_cached_wreq_c && wishbone_st == WB_IDLE);
assign dcache_uncached_wready   = (dcache_uncached_wreq_c && wishbone_st == WB_IDLE);
assign dcache_cached_wreq_c     = dcache_cached_wreq_in   || dcache_cached_wreq_r;
assign dcache_uncached_wreq_c   = dcache_uncached_wreq_in || dcache_uncached_wreq_r;


// ======================================
// Register Accesses
// ======================================

assign extra_write =  wishbone_st == WB_IDLE && !i_wb_ack && ((dcache_cached_wreq_c && dcache_cached_wready)||
                                                              (dcache_uncached_wreq_c && dcache_uncached_wready));

//shz always @( posedge i_clk or negedge quick_n_reset)
always @( posedge i_clk)
    if ( !quick_n_reset)
	o_wb_dat <= 'd0;
    else if ( wishbone_st == WB_WAIT_ACK && i_wb_ack && extra_write_r )
        o_wb_dat <= extra_write_data_r;
    else if ( start_access )
        o_wb_dat <= i_dcache_write_data;


//shz always @( posedge i_clk or negedge quick_n_reset )
always @( posedge i_clk )
    if ( !quick_n_reset)
    begin
	dcache_cached_rreq_r   <= 'd0;
	dcache_cached_wreq_r   <= 'd0;
	dcache_uncached_rreq_r <= 'd0;
	dcache_uncached_wreq_r <= 'd0;
	icache_read_req_r  <= 'd0;
	icache_read_qword_r  <= 'd0;
	icache_read_addr_r  <= 'd0;
	dcache_read_qword_r  <= 'd0;
    end
    else
    begin
    icache_read_req_r   <= icache_read_req_in  || icache_read_req_c;
    icache_read_qword_r <= i_icache_qword      || icache_read_qword_c;
    if ( i_icache_req ) icache_read_addr_r  <= i_icache_address;
        
    dcache_read_qword_r    <= i_dcache_qword      || dcache_read_qword_c;
    dcache_cached_wreq_r   <= dcache_cached_wreq_c   && (wishbone_st != WB_IDLE || (o_wb_stb && !i_wb_ack));
    dcache_uncached_wreq_r <= dcache_uncached_wreq_c && (wishbone_st != WB_IDLE || (o_wb_stb && !i_wb_ack));
    
    
    // A buffer to hold a second write while on eis in progress
    if ( extra_write )
        begin
        extra_write_data_r      <= i_dcache_write_data;
        extra_write_address_r   <= i_dcache_address;
        extra_write_be_r        <= i_dcache_byte_enable;
        end


    // The flag can be set during any state but only cleared during WB_IDLE or WB_WAIT_ACK
    if ( dcache_cached_rreq_r )
        begin
        if ( wishbone_st == WB_IDLE || wishbone_st == WB_WAIT_ACK )
            dcache_cached_rreq_r <= dcache_cached_rreq_c && !o_dcache_cached_ready;
        end    
    else    
        dcache_cached_rreq_r <= dcache_cached_rreq_c && !o_dcache_cached_ready;
    if ( dcache_uncached_rreq_r )
        begin
        if ( wishbone_st == WB_IDLE || wishbone_st == WB_WAIT_ACK )
            dcache_uncached_rreq_r <= dcache_uncached_rreq_c && !o_dcache_uncached_ready;
        end    
    else    
        dcache_uncached_rreq_r <= dcache_uncached_rreq_c && !o_dcache_uncached_ready;
    end
    
assign wait_write_ack = o_wb_stb && o_wb_we && !i_wb_ack;


//shz always @( posedge i_clk or negedge quick_n_reset)
always @( posedge i_clk)
    if ( !quick_n_reset)
	begin
		o_wb_adr <= 'd0;
		o_wb_sel <= 'd0;
		o_wb_we  <= 'd0;
		o_wb_cyc <= 'd0;
		o_wb_stb <= 'd0;
		servicing_dcache_cached_read_r <= 'd0;
		servicing_dcache_uncached_read_r <= 'd0;
		servicing_icache_r <= 'd0;
		extra_write_r <= 'd0;
		exclusive_access <= 'd0;
		wishbone_st <= WB_IDLE;
	end
    else
    case ( wishbone_st )
        WB_IDLE :
            begin 
            extra_write_r <= extra_write;
            
            if ( start_access )
                begin
                o_wb_stb            <= 1'd1; 
                o_wb_cyc            <= 1'd1; 
                o_wb_sel            <= byte_enable;
                end
            else if ( !wait_write_ack )
                begin
                o_wb_stb            <= 1'd0;
                
                // Hold cyc high after an exclusive access
                // to hold ownership of the wishbone bus
                o_wb_cyc            <= exclusive_access;
                end

            if ( wait_write_ack )
                begin
                // still waiting for last (write) access to complete
                wishbone_st                      <= WB_WAIT_ACK;
                servicing_dcache_cached_read_r   <= dcache_cached_rreq_c;
                servicing_dcache_uncached_read_r <= dcache_uncached_rreq_c;
                end 
            // dcache accesses have priority over icache     
            else if ( dcache_cached_rreq_c || dcache_uncached_rreq_c )
                begin
                if ( dcache_cached_rreq_c )
                    servicing_dcache_cached_read_r <= 1'd1;
                else if ( dcache_uncached_rreq_c )
                    servicing_dcache_uncached_read_r <= 1'd1;
                
                if ( dcache_read_qword_c )
                    wishbone_st         <= WB_BURST1;
                else
                    wishbone_st         <= WB_WAIT_ACK;
                exclusive_access    <= i_exclusive;
                end                    
           // The core does not currently issue exclusive write requests
           // but there's no reason why this might not be added some
           // time in the future so allow for it here
            else if ( write_req_c )
                begin
                exclusive_access            <= i_exclusive;
                end
            // do a burst of 4 read to fill a cache line                   
            else if ( icache_read_req_c && icache_read_qword_c )
                begin
                wishbone_st                 <= WB_BURST1;
                exclusive_access            <= 1'd0;
                servicing_icache_r          <= 1'd1;
                end                    
            // single word read request from fetch stage                   
            else if ( icache_read_req_c )
                begin
                wishbone_st                 <= WB_WAIT_ACK;
                exclusive_access            <= 1'd0;
                servicing_icache_r          <= 1'd1;
                end                    

                            
            if ( start_access )
                begin
                if ( dcache_req_c )
                    begin
                    o_wb_we              <= write_req_c;
                    // only update these on new wb access to make debug easier
                    o_wb_adr[31:2]       <= i_dcache_address[31:2];
                    o_wb_adr[1:0]        <= byte_enable == 4'b0001 ? 2'd0 :
                                            byte_enable == 4'b0010 ? 2'd1 :
                                            byte_enable == 4'b0100 ? 2'd2 :
                                            byte_enable == 4'b1000 ? 2'd3 :
                                           
                                            byte_enable == 4'b0011 ? 2'd0 :
                                            byte_enable == 4'b1100 ? 2'd2 :
                                           
                                                                     2'd0 ;
                    end                                                 
                else 
                    begin
                    o_wb_we              <= 1'd0;
                    o_wb_adr[31:0]       <= {icache_read_addr_c[31:2], 2'd0};
                    end                                                
                end
            end
                    

        // Read burst, wait for first ack
        WB_BURST1:  
            if ( i_wb_ack )
                begin
                // burst of 4 that wraps
                o_wb_adr[3:2]   <= o_wb_adr[3:2] + 1'd1;
                wishbone_st     <= WB_BURST2;
                end
            
            
        // Read burst, wait for second ack
        WB_BURST2:  
            if ( i_wb_ack )
                begin
                // burst of 4 that wraps
                o_wb_adr[3:2]   <= o_wb_adr[3:2] + 1'd1;
                wishbone_st     <= WB_BURST3;
                end
            
            
        // Read burst, wait for third ack
        WB_BURST3:  
            if ( i_wb_ack )
                begin
                // burst of 4 that wraps
                o_wb_adr[3:2]   <= o_wb_adr[3:2] + 1'd1;
                wishbone_st     <= WB_WAIT_ACK;
                end


        // Wait for the wishbone ack to be asserted
        WB_WAIT_ACK:   
            if ( i_wb_ack )
                // Another write that was acked and needs to be sent before returning to IDLE ?
                if ( extra_write_r )
                    begin
                    extra_write_r                       <= 'd0;
                    o_wb_stb                            <= 1'd1; 
                    o_wb_cyc                            <= exclusive_access; 
                    o_wb_sel                            <= extra_write_be_r;
                    o_wb_we                             <= 1'd1;
                    o_wb_adr[31:0]                      <= extra_write_address_r;
                    end
                else    
                    begin
                    wishbone_st                         <= WB_IDLE;
                    o_wb_stb                            <= 1'd0; 
                    o_wb_cyc                            <= exclusive_access; 
                    o_wb_we                             <= 1'd0;
                    servicing_dcache_cached_read_r      <= 1'd0;
                    servicing_dcache_uncached_read_r    <= 1'd0;
                    servicing_icache_r                  <= 1'd0;
                    end
                         
            
    endcase

// ========================================================
// Debug Wishbone bus - not synthesizable
// ========================================================
//synopsys translate_off
wire    [(14*8)-1:0]   xWB_STATE;


assign xWB_STATE  = wishbone_st == WB_IDLE       ? """"WB_IDLE""""       :
                    wishbone_st == WB_BURST1     ? """"WB_BURST1""""     :
                    wishbone_st == WB_BURST2     ? """"WB_BURST2""""     :
                    wishbone_st == WB_BURST3     ? """"WB_BURST3""""     :
                    wishbone_st == WB_WAIT_ACK   ? """"WB_WAIT_ACK""""   :
                                                   """"UNKNOWN""""       ;

//synopsys translate_on
    
endmodule
","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_IDLE) |-> ##1 (wishbone_st == WB_IDLE) | (wishbone_st == WB_BURST1) | (wishbone_st == WB_WAIT_ACK)"",
    ""Signals"": [
      ""wishbone_st"",
      ""WB_IDLE"",
      ""WB_BURST1"",
      ""WB_WAIT_ACK""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the current state of the Wishbone bus finite state machine"",
      ""WB_IDLE"": ""the idle state of the Wishbone bus interface"",
      ""WB_BURST1"": ""the first state of a burst transfer (read burst) on the Wishbone bus"",
      ""WB_WAIT_ACK"": ""the state where the bus is waiting for an acknowledgment""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""##1"",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equality check"",
      ""|->"": ""non-overlapped implication operator (if antecedent holds then consequent must follow)"",
      ""##1"": ""implies that the consequent is expected one clock cycle later"",
      ""|"": ""logical OR operator""
    },
    ""Assertion Explaination"": ""If the finite state machine is in the idle state at the current clock cycle, then one clock cycle later it must be either in the idle state, the first burst state, or the waiting-for-acknowledgment state.""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_BURST1) & i_wb_ack |-> ##1 (wishbone_st == WB_BURST2)"",
    ""Signals"": [
      ""wishbone_st"",
      ""WB_BURST1"",
      ""i_wb_ack"",
      ""WB_BURST2""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the current state of the Wishbone bus finite state machine"",
      ""WB_BURST1"": ""the first state of a burst read transfer"",
      ""i_wb_ack"": ""the input signal that acknowledges a Wishbone bus transfer"",
      ""WB_BURST2"": ""the second state in the sequence of a burst read transfer""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equality check"",
      ""&"": ""logical AND operator used to combine conditions"",
      ""|->"": ""non-overlapped implication operator"",
      ""##1"": ""indicates that the outcome must occur one clock cycle later""
    },
    ""Assertion Explaination"": ""If the finite state machine is in the first burst state and the acknowledgment signal is asserted at the current clock cycle, then one clock cycle later it must transition to the second burst state.""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_BURST2) & i_wb_ack |-> ##1 (wishbone_st == WB_BURST3)"",
    ""Signals"": [
      ""wishbone_st"",
      ""WB_BURST2"",
      ""i_wb_ack"",
      ""WB_BURST3""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the current state of the Wishbone bus finite state machine"",
      ""WB_BURST2"": ""the second state of a burst read transfer"",
      ""i_wb_ack"": ""the input acknowledgment signal from the Wishbone bus"",
      ""WB_BURST3"": ""the third state in the burst read sequence""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equality check"",
      ""&"": ""logical AND operator"",
      ""|->"": ""non-overlapped implication operator"",
      ""##1"": ""ensures that the consequent becomes valid in the next clock cycle""
    },
    ""Assertion Explaination"": ""If the state machine is in the second burst state and the acknowledgment is received at the current clock cycle, then one clock cycle later it must enter the third burst state.""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_BURST3) & i_wb_ack |-> ##1 (wishbone_st == WB_WAIT_ACK)"",
    ""Signals"": [
      ""wishbone_st"",
      ""WB_BURST3"",
      ""i_wb_ack"",
      ""WB_WAIT_ACK""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the current state of the Wishbone bus finite state machine"",
      ""WB_BURST3"": ""the third state of a burst read transfer"",
      ""i_wb_ack"": ""the input signal indicating the acknowledgment of the bus transfer"",
      ""WB_WAIT_ACK"": ""the state where the bus is waiting for further acknowledgment""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equality check"",
      ""&"": ""logical AND operator to combine conditions"",
      ""|->"": ""non-overlapped implication operator"",
      ""##1"": ""indicates that the consequent must hold one clock cycle later""
    },
    ""Assertion Explaination"": ""If the state machine is in the third burst state and the acknowledgment is asserted at the current clock cycle, then one clock cycle later it must move to the waiting-for-acknowledgment state.""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_WAIT_ACK) & (extra_write_r || !i_wb_ack) |-> ##1 (wishbone_st == WB_WAIT_ACK)"",
    ""Signals"": [
      ""wishbone_st"",
      ""WB_WAIT_ACK"",
      ""extra_write_r"",
      ""i_wb_ack""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the current state of the Wishbone bus finite state machine"",
      ""WB_WAIT_ACK"": ""the state where the bus is waiting for an acknowledgment"",
      ""extra_write_r"": ""a registered flag indicating that an extra write is pending"",
      ""i_wb_ack"": ""the input signal that acknowledges a Wishbone bus transfer""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""||"",
      ""!"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equality check"",
      ""&"": ""logical AND operator"",
      ""||"": ""logical OR operator"",
      ""!"": ""logical NOT operator"",
      ""|->"": ""non-overlapped implication operator"",
      ""##1"": ""ensures that the consequent holds one clock cycle later""
    },
    ""Assertion Explaination"": ""If the state machine is in the waiting-for-acknowledgment state and either there is a pending extra write or the acknowledgment is not asserted at the current clock cycle, then one clock cycle later the machine must remain in the waiting-for-acknowledgment state.""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge i_clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(wishbone_st == WB_WAIT_ACK) & (!extra_write_r && i_wb_ack) |-> ##1 (wishbone_st == WB_IDLE)"",
    ""Signals"": [
      ""wishbone_st"",
      ""WB_WAIT_ACK"",
      ""extra_write_r"",
      ""i_wb_ack"",
      ""WB_IDLE""
    ],
    ""Signal Explanations"": {
      ""wishbone_st"": ""the current state of the Wishbone bus finite state machine"",
      ""WB_WAIT_ACK"": ""the state where the bus is waiting for an acknowledgment"",
      ""extra_write_r"": ""the registered flag indicating a pending extra write"",
      ""i_wb_ack"": ""the input acknowledgment signal from the Wishbone bus"",
      ""WB_IDLE"": ""the idle state of the Wishbone bus""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""!"",
      ""&&"",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equality check"",
      ""&"": ""logical AND operator used to combine multiple conditions"",
      ""!"": ""logical NOT operator"",
      ""&&"": ""logical AND operator combining the negated extra write flag and acknowledgment condition"",
      ""|->"": ""non-overlapped implication operator"",
      ""##1"": ""indicates that the consequent must hold in the next clock cycle""
    },
    ""Assertion Explaination"": ""If the state machine is in the waiting-for-acknowledgment state and there is no pending extra write while the acknowledgment is asserted at the current clock cycle, then one clock cycle later the machine must transition to the idle state.""
  }
}","{
""Assertion 1"": ""assert property (wishbone_st == WB_IDLE |-> (wishbone_st == WB_IDLE || wishbone_st == WB_BURST1 || wishbone_st == WB_WAIT_ACK));"",
""Assertion 2"": ""assert property (wishbone_st == WB_BURST1 && i_wb_ack |-> (wishbone_st == WB_BURST2));"",
""Assertion 3"": ""assert property (wishbone_st == WB_BURST2 && i_wb_ack ||-> (wishbone_st == WB_BURST3));"",
""Assertion 4"": ""assert property (wishbone_st == WB_BURST3 |-> (wishbone_st == WB_WAIT_ACK));"",
""Assertion 5"": ""assert property (wishbone_st == WB_WAIT_ACK && (extra_write_r || !i_wb_ack) |-> (wishbone_st == WB_WAIT_ACK));"",
""Assertion 6"": ""assert property (wishbone_st == WB_WAIT_ACK && i_wb_ack && !extra_write_r |-> (wishbone_st == WB_IDLE));""
}"
second_largest,"module second_largest #(parameter
  DATA_WIDTH = 32
) (
  input clk,
  input resetn,
  input [DATA_WIDTH-1:0] din,
  output logic [DATA_WIDTH-1:0] dout
);

reg  [DATA_WIDTH-1:0] max_q;
wire [DATA_WIDTH-1:0] max_next;
reg  [DATA_WIDTH-1:0] max2_q; // second largest
wire [DATA_WIDTH-1:0] max2_next;

wire new_max;

assign new_max   = ( max_q < din);
assign max_next  = new_max ? din : max_q;
assign max2_next = new_max ? max_q : max2_q; 

always @(posedge clk)
begin
	if(~resetn) begin
		max_q  <= {DATA_WIDTH{1'b0}}; 
		max2_q <= {DATA_WIDTH{1'b0}}; 
	end
	else begin
		max_q  <= max_next;
		max2_q <= max2_next;
	end
end

// output 
assign dout = max2_q;

`ifdef FORMAL

initial begin
	// assumption
	// max_q and max2_q are not equal on init unless 0
	a_init : assume property ( (max_q == 0 & max2_q == 0) | ( max2_q < max_q));
end

always @(posedge clk)
begin
	if (~resetn) begin
		
		// assertions
		sva_max_greater_max2: assert( (max_q == 0) | ( max_q > max2_q )); 

		// cover
		c_max_zero : cover ( max_q == 0 );
		c_change : cover ( din != dout );
		c_max_greater : cover ( max_q > max2_q );	
		c_max_update : cover ( new_max );
	end
	c_reset : cover ( resetn );
end
`endif // FORMAL 
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": """",
    ""disable condition"": """",
    ""logical expression"": ""(max_q == 0 & max2_q == 0) | ( max2_q < max_q)"",
    ""Signals"": [""max_q"", ""max2_q""],
    ""Signal Explanations"": {
      ""max_q"": ""a register that holds the largest value encountered since reset"",
      ""max2_q"": ""a register that holds the second largest value encountered""
    },
    ""Logical Operators"": [""=="", ""&"", ""|"", ""<""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality"",
      ""&"": ""logical AND"",
      ""|"": ""logical OR"",
      ""<"": ""less than comparison""
    },
    ""Assertion Explaination"": ""Either both the stored largest and second largest values are zero or the second largest value is less than the largest value, ensuring that when nonzero the ordering of values is maintained.""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""at posedge clk"",
    ""disable condition"": """",
    ""logical expression"": ""(max_q == 0) | ( max_q > max2_q )"",
    ""Signals"": [""max_q"", ""max2_q""],
    ""Signal Explanations"": {
      ""max_q"": ""a register that holds the largest value encountered since reset"",
      ""max2_q"": ""a register that holds the second largest value encountered""
    },
    ""Logical Operators"": [""=="", ""|"", "">""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality"",
      ""|"": ""logical OR"",
      "">"": ""greater than comparison""
    },
    ""Assertion Explaination"": ""At each clock edge, the stored largest value is either zero or strictly greater than the stored second largest value, thereby ensuring the proper order is maintained during operation.""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~resetn)"",
    ""logical expression"": ""(max_q == 0) | (max_q > max2_q)"",
    ""Signals"": [""max_q"", ""max2_q""],
    ""Signal Explanations"": {
      ""max_q"": ""a register that holds the largest value encountered since reset"",
      ""max2_q"": ""a register that holds the second largest value encountered""
    },
    ""Logical Operators"": [""=="", ""|"", "">""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality"",
      ""|"": ""logical OR"",
      "">"": ""greater than comparison""
    },
    ""Assertion Explaination"": ""On every positive clock edge, except when the reset is active, the property requires that the stored largest value is either zero or strictly greater than the stored second largest value, thus enforcing the expected value ordering.""
  }
}","{
""Assertion 1"": ""assert property ( (max_q == 0 && max2_q == 0) || (max2_q < max_q) );"",
""Assertion 2"": ""assert property ( (max_q == 0) || (max_q > max2_q) );"",
""Assertion 3"": ""assert property ( (max_q == 0) || (max_q > max2_q) );""
}"
reversing_bits,"module reversing_bits #(
	parameter DATA_WIDTH=3
) 
(
  input clk,
  input rst,
  input  [DATA_WIDTH-1:0]       din,
  output logic [DATA_WIDTH-1:0] dout
);

genvar i;
generate;
	for (i=0; i<DATA_WIDTH; i++) begin
		assign dout[i] = din[DATA_WIDTH-i-1];
	end
endgenerate

endmodule","{
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (~rst)"",
""logical expression"": ""dout[0] == din[DATA_WIDTH-1]"",
""Signals"": [""dout[0]"", ""din[DATA_WIDTH-1]""],
""Signal Explanations"": {
          ""dout[0]"": ""the lowest-order bit of the output vector that holds the reversed order of the input bits"",
          ""din[DATA_WIDTH-1]"": ""the highest-order bit of the input vector""
},
""Logical Operators"": [""==""],
""Logical Operators Explanation"": {
          ""=="": ""equal""
},
""Assertion Explaination"": ""the lowest-order bit of the reversed output is equal to the highest-order bit of the original input""
}
}","{
""Assertion 1"": ""assert property (dout[0] == din[DATA_WIDTH-1]);""
}"
or1200_ctrl,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Instruction decode                                 ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Majority of instruction decoding is performed here.         ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_ctrl.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_ctrl
  (
   // Clock and reset
   clk, rst,
   
   // Internal i/f
   except_flushpipe, extend_flush, if_flushpipe, id_flushpipe, ex_flushpipe, 
   wb_flushpipe,
   id_freeze, ex_freeze, wb_freeze, if_insn, id_insn, ex_insn, abort_mvspr, 
   id_branch_op, ex_branch_op, ex_branch_taken, pc_we, 
   rf_addra, rf_addrb, rf_rda, rf_rdb, alu_op, alu_op2, mac_op,
   comp_op, rf_addrw, rfwb_op, fpu_op,
   wb_insn, id_simm, ex_simm, id_branch_addrtarget, ex_branch_addrtarget, sel_a,
   sel_b, id_lsu_op,
   cust5_op, cust5_limm, id_pc, ex_pc, du_hwbkpt, 
   multicycle, wait_on, wbforw_valid, sig_syscall, sig_trap,
   force_dslot_fetch, no_more_dslot, id_void, ex_void, ex_spr_read, 
   ex_spr_write, du_flush_pipe,
   id_mac_op, id_macrc_op, ex_macrc_op, rfe, except_illegal, dc_no_writethrough
   );

//
// I/O
//
input					clk;
input					rst;
input					id_freeze;
input					ex_freeze /* verilator public */;
input					wb_freeze /* verilator public */;
output					if_flushpipe;
output					id_flushpipe;
output					ex_flushpipe;
output					wb_flushpipe;
input					extend_flush;
input					except_flushpipe;
input                           abort_mvspr ;
input	[31:0]			if_insn;
output	[31:0]			id_insn;
output	[31:0]			ex_insn /* verilator public */;
output	[`OR1200_BRANCHOP_WIDTH-1:0]		ex_branch_op;
output	[`OR1200_BRANCHOP_WIDTH-1:0]		id_branch_op;
input						ex_branch_taken;
output	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addrw;
output	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addra;
output	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addrb;
output					rf_rda;
output					rf_rdb;
output	[`OR1200_ALUOP_WIDTH-1:0]		alu_op;
output [`OR1200_ALUOP2_WIDTH-1:0] 		alu_op2;
output	[`OR1200_MACOP_WIDTH-1:0]		mac_op;
output	[`OR1200_RFWBOP_WIDTH-1:0]		rfwb_op;
output  [`OR1200_FPUOP_WIDTH-1:0] 		fpu_op;      
input					pc_we;
output	[31:0]				wb_insn;
output	[31:2]				id_branch_addrtarget;
output	[31:2]				ex_branch_addrtarget;
output	[`OR1200_SEL_WIDTH-1:0]		sel_a;
output	[`OR1200_SEL_WIDTH-1:0]		sel_b;
output	[`OR1200_LSUOP_WIDTH-1:0]		id_lsu_op;
output	[`OR1200_COMPOP_WIDTH-1:0]		comp_op;
output	[`OR1200_MULTICYCLE_WIDTH-1:0]		multicycle;
output  [`OR1200_WAIT_ON_WIDTH-1:0] 		wait_on;   
output	[4:0]				cust5_op;
output	[5:0]				cust5_limm;
input   [31:0]                          id_pc;
input   [31:0]                          ex_pc;
output	[31:0]				id_simm;
output	[31:0]				ex_simm;
input					wbforw_valid;
input					du_hwbkpt;
output					sig_syscall;
output					sig_trap;
output					force_dslot_fetch;
output					no_more_dslot;
output					id_void;
output					ex_void;
output					ex_spr_read;
output					ex_spr_write;
output	[`OR1200_MACOP_WIDTH-1:0]	id_mac_op;
output					id_macrc_op;
output					ex_macrc_op;
output					rfe;
output					except_illegal;
output  				dc_no_writethrough;
input					du_flush_pipe;

//
// Internal wires and regs
//
reg	[`OR1200_BRANCHOP_WIDTH-1:0]		id_branch_op;
reg	[`OR1200_BRANCHOP_WIDTH-1:0]		ex_branch_op;
reg	[`OR1200_ALUOP_WIDTH-1:0]		alu_op;
reg [`OR1200_ALUOP2_WIDTH-1:0]      		alu_op2;
wire					if_maci_op;
`ifdef OR1200_MAC_IMPLEMENTED
reg	[`OR1200_MACOP_WIDTH-1:0]		ex_mac_op;
reg	[`OR1200_MACOP_WIDTH-1:0]		id_mac_op;
wire	[`OR1200_MACOP_WIDTH-1:0]		mac_op;
reg					ex_macrc_op;
`else
wire	[`OR1200_MACOP_WIDTH-1:0]		mac_op;
wire					ex_macrc_op;
`endif
reg	[31:0]				id_insn /* verilator public */;
reg	[31:0]				ex_insn /* verilator public */;
reg	[31:0]				wb_insn /* verilator public */;
reg	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	rf_addrw;
reg	[`OR1200_REGFILE_ADDR_WIDTH-1:0]	wb_rfaddrw;
reg	[`OR1200_RFWBOP_WIDTH-1:0]		rfwb_op;
reg	[`OR1200_SEL_WIDTH-1:0]		sel_a;
reg	[`OR1200_SEL_WIDTH-1:0]		sel_b;
reg					sel_imm;
reg	[`OR1200_LSUOP_WIDTH-1:0]		id_lsu_op;
reg	[`OR1200_COMPOP_WIDTH-1:0]		comp_op;
reg	[`OR1200_MULTICYCLE_WIDTH-1:0]		multicycle;
reg     [`OR1200_WAIT_ON_WIDTH-1:0] 		wait_on;      
reg 	[31:0]				id_simm;
reg 	[31:0]				ex_simm;
reg					sig_syscall;
reg					sig_trap;
reg					except_illegal;
wire					id_void;
wire					ex_void;
wire                                    wb_void;
reg                                     ex_delayslot_dsi;
reg                                     ex_delayslot_nop;
reg					spr_read;
reg					spr_write;
reg     [31:2]				ex_branch_addrtarget;
`ifdef OR1200_DC_NOSTACKWRITETHROUGH
reg 					dc_no_writethrough;
`endif
   
//
// Register file read addresses
//
assign rf_addra = if_insn[20:16];
assign rf_addrb = if_insn[15:11];
assign rf_rda = if_insn[31] || if_maci_op;
assign rf_rdb = if_insn[30];

//
// Force fetch of delay slot instruction when jump/branch is preceeded by 
// load/store instructions
//
assign force_dslot_fetch = 1'b0;
assign no_more_dslot = (|ex_branch_op & !id_void & ex_branch_taken) | 
		       (ex_branch_op == `OR1200_BRANCHOP_RFE);

assign id_void = (id_insn[31:26] == `OR1200_OR32_NOP) & id_insn[16];
assign ex_void = (ex_insn[31:26] == `OR1200_OR32_NOP) & ex_insn[16];
assign wb_void = (wb_insn[31:26] == `OR1200_OR32_NOP) & wb_insn[16];

assign ex_spr_write = spr_write && !abort_mvspr;
assign ex_spr_read = spr_read && !abort_mvspr;

//
// ex_delayslot_dsi: delay slot insn is in EX stage
// ex_delayslot_nop: (filler) nop insn is in EX stage (before nops 
//                   jump/branch was executed)
//
//  ex_delayslot_dsi & !ex_delayslot_nop - DS insn in EX stage
//  !ex_delayslot_dsi & ex_delayslot_nop - NOP insn in EX stage, 
//       next different is DS insn, previous different was Jump/Branch
//  !ex_delayslot_dsi & !ex_delayslot_nop - normal insn in EX stage
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
        if (rst == `OR1200_RST_VALUE) begin
		ex_delayslot_nop <=  1'b0;
		ex_delayslot_dsi <=  1'b0;
	end
	else if (!ex_freeze & !ex_delayslot_dsi & ex_delayslot_nop) begin
		ex_delayslot_nop <=  id_void;
		ex_delayslot_dsi <=  !id_void;
	end
	else if (!ex_freeze & ex_delayslot_dsi & !ex_delayslot_nop) begin
		ex_delayslot_nop <=  1'b0;
		ex_delayslot_dsi <=  1'b0;
	end
	else if (!ex_freeze) begin
		ex_delayslot_nop <=  id_void && ex_branch_taken && 
				     (ex_branch_op != `OR1200_BRANCHOP_NOP) && 
				     (ex_branch_op != `OR1200_BRANCHOP_RFE);
	        ex_delayslot_dsi <=  !id_void && ex_branch_taken && 
				     (ex_branch_op != `OR1200_BRANCHOP_NOP) && 
				     (ex_branch_op != `OR1200_BRANCHOP_RFE);
	end
end

//
// Flush pipeline
//
assign if_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign id_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign ex_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign wb_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;

//
// EX Sign/Zero extension of immediates
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_simm <=  32'h0000_0000;
	else if (!ex_freeze) begin
		ex_simm <=  id_simm;
	end
end

//
// ID Sign/Zero extension of immediate
//
always @(id_insn) begin
	case (id_insn[31:26])     // synopsys parallel_case

	// l.addi
	`OR1200_OR32_ADDI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.addic
	`OR1200_OR32_ADDIC:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.lxx (load instructions)
	`OR1200_OR32_LWZ, `OR1200_OR32_LWS,
   `OR1200_OR32_LBZ, `OR1200_OR32_LBS,
	`OR1200_OR32_LHZ, `OR1200_OR32_LHS:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.muli
	`ifdef OR1200_MULT_IMPLEMENTED
	`OR1200_OR32_MULI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};
	`endif

	// l.maci
	`ifdef OR1200_MAC_IMPLEMENTED
	`OR1200_OR32_MACI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};
	`endif

	// l.mtspr
	`OR1200_OR32_MTSPR:
		id_simm = {16'b0, id_insn[25:21], id_insn[10:0]};

	// l.sxx (store instructions)
	`OR1200_OR32_SW, `OR1200_OR32_SH, `OR1200_OR32_SB:
		id_simm = {{16{id_insn[25]}}, id_insn[25:21], id_insn[10:0]};

	// l.xori
	`OR1200_OR32_XORI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.sfxxi (SFXX with immediate)
	`OR1200_OR32_SFXXI:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// Instructions with no or zero extended immediate
	default:
		id_simm = {{16'b0}, id_insn[15:0]};

	endcase
end

//
// ID Sign extension of branch offset
//
assign id_branch_addrtarget = {{4{id_insn[25]}}, id_insn[25:0]} + id_pc[31:2];

//
// EX Sign extension of branch offset
//

// pipeline ID and EX branch target address 
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_branch_addrtarget <=  0;
	else if (!ex_freeze) 
		ex_branch_addrtarget <=  id_branch_addrtarget;
end
// not pipelined
//assign ex_branch_addrtarget = {{4{ex_insn[25]}}, ex_insn[25:0]} + ex_pc[31:2];

//
// l.maci in IF stage
//
`ifdef OR1200_MAC_IMPLEMENTED
assign if_maci_op = (if_insn[31:26] == `OR1200_OR32_MACI);
`else
assign if_maci_op = 1'b0;
`endif

//
// l.macrc in ID stage
//
`ifdef OR1200_MAC_IMPLEMENTED
assign id_macrc_op = (id_insn[31:26] == `OR1200_OR32_MACRC) & id_insn[16];
`else
assign id_macrc_op = 1'b0;
`endif

//
// l.macrc in EX stage
//
`ifdef OR1200_MAC_IMPLEMENTED
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_macrc_op <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_macrc_op <=  1'b0;
	else if (!ex_freeze)
		ex_macrc_op <=  id_macrc_op;
end
`else
assign ex_macrc_op = 1'b0;
`endif

//
// cust5_op, cust5_limm (L immediate)
//
assign cust5_op = ex_insn[4:0];
assign cust5_limm = ex_insn[10:5];

//
//
//
assign rfe = (id_branch_op == `OR1200_BRANCHOP_RFE) | 
	     (ex_branch_op == `OR1200_BRANCHOP_RFE);

   
`ifdef verilator
   // Function to access wb_insn (for Verilator). Have to hide this from
   // simulator, since functions with no inputs are not allowed in IEEE
   // 1364-2001.
   function [31:0] get_wb_insn;
      // verilator public
      get_wb_insn = wb_insn;
   endfunction // get_wb_insn

   // Function to access id_insn (for Verilator). Have to hide this from
   // simulator, since functions with no inputs are not allowed in IEEE
   // 1364-2001.
   function [31:0] get_id_insn;
      // verilator public
      get_id_insn = id_insn;
   endfunction // get_id_insn

   // Function to access ex_insn (for Verilator). Have to hide this from
   // simulator, since functions with no inputs are not allowed in IEEE
   // 1364-2001.
   function [31:0] get_ex_insn;
      // verilator public
      get_ex_insn = ex_insn;
   endfunction // get_ex_insn
   
`endif

   
//
// Generation of sel_a
//
always @(rf_addrw or id_insn or rfwb_op or wbforw_valid or wb_rfaddrw)
	if ((id_insn[20:16] == rf_addrw) && rfwb_op[0])
		sel_a = `OR1200_SEL_EX_FORW;
	else if ((id_insn[20:16] == wb_rfaddrw) && wbforw_valid)
		sel_a = `OR1200_SEL_WB_FORW;
	else
		sel_a = `OR1200_SEL_RF;

//
// Generation of sel_b
//
always @(rf_addrw or sel_imm or id_insn or rfwb_op or wbforw_valid or 
	 wb_rfaddrw)
	if (sel_imm)
		sel_b = `OR1200_SEL_IMM;
	else if ((id_insn[15:11] == rf_addrw) && rfwb_op[0])
		sel_b = `OR1200_SEL_EX_FORW;
	else if ((id_insn[15:11] == wb_rfaddrw) && wbforw_valid)
		sel_b = `OR1200_SEL_WB_FORW;
	else
		sel_b = `OR1200_SEL_RF;

//
// Decode of multicycle
//
always @(id_insn) begin
  case (id_insn[31:26])		// synopsys parallel_case
    // l.rfe
    `OR1200_OR32_RFE,
    // l.mfspr
    `OR1200_OR32_MFSPR:
      multicycle = `OR1200_TWO_CYCLES;	// to read from ITLB/DTLB (sync RAMs)
    // Single cycle instructions
    default: begin
      multicycle = `OR1200_ONE_CYCLE;
    end    
  endcase
end // always @ (id_insn)

//
// Encode wait_on signal
//    
always @(id_insn) begin
   case (id_insn[31:26])		// synopsys parallel_case
     `OR1200_OR32_ALU: 
       wait_on =  ( 1'b0
`ifdef OR1200_DIV_IMPLEMENTED
                     | (id_insn[4:0] == `OR1200_ALUOP_DIV)
		     | (id_insn[4:0] == `OR1200_ALUOP_DIVU)
`endif
`ifdef OR1200_MULT_IMPLEMENTED
		     | (id_insn[4:0] == `OR1200_ALUOP_MUL)
		     | (id_insn[4:0] == `OR1200_ALUOP_MULU)
`endif
		    ) ? `OR1200_WAIT_ON_MULTMAC : `OR1200_WAIT_ON_NOTHING;
`ifdef OR1200_MULT_IMPLEMENTED
`ifdef OR1200_MAC_IMPLEMENTED
     `OR1200_OR32_MACMSB,
     `OR1200_OR32_MACI,
`endif
     `OR1200_OR32_MULI:       
	 wait_on = `OR1200_WAIT_ON_MULTMAC;
`endif
`ifdef OR1200_MAC_IMPLEMENTED
     `OR1200_OR32_MACRC:
         wait_on = id_insn[16] ? `OR1200_WAIT_ON_MULTMAC : 
		                 `OR1200_WAIT_ON_NOTHING;
`endif		   
`ifdef OR1200_FPU_IMPLEMENTED
       `OR1200_OR32_FLOAT: begin
	 wait_on = id_insn[`OR1200_FPUOP_DOUBLE_BIT] ? 0 : `OR1200_WAIT_ON_FPU;
       end
`endif
`ifndef OR1200_DC_WRITEHROUGH
     // l.mtspr
     `OR1200_OR32_MTSPR: begin
	wait_on = `OR1200_WAIT_ON_MTSPR;
     end
`endif
     default: begin
	wait_on = `OR1200_WAIT_ON_NOTHING;
     end
   endcase // case (id_insn[31:26])
end // always @ (id_insn)
   
   
   
   
//
// Register file write address
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		rf_addrw <=  5'd0;
	else if (!ex_freeze & id_freeze)
		rf_addrw <=  5'd00;
	else if (!ex_freeze)
		case (id_insn[31:26])	// synopsys parallel_case
			`OR1200_OR32_JAL, `OR1200_OR32_JALR:
				rf_addrw <=  5'd09;	// link register r9
			default:
				rf_addrw <=  id_insn[25:21];
		endcase
end

//
// rf_addrw in wb stage (used in forwarding logic)
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		wb_rfaddrw <=  5'd0;
	else if (!wb_freeze)
		wb_rfaddrw <=  rf_addrw;
end

//
// Instruction latch in id_insn
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		id_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};
        else if (id_flushpipe)
                id_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};        // NOP -> id_insn[16] must be 1
	else if (!id_freeze) begin
		id_insn <=  if_insn;
`ifdef OR1200_VERBOSE
// synopsys translate_off
		$display(""%t: id_insn <= %h"", $time, if_insn);
// synopsys translate_on
`endif
	end
end

//
// Instruction latch in ex_insn
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};	// NOP -> ex_insn[16] must be 1
	else if (!ex_freeze) begin
		ex_insn <=  id_insn;
`ifdef OR1200_VERBOSE
// synopsys translate_off
		$display(""%t: ex_insn <= %h"", $time, id_insn);
// synopsys translate_on
`endif
	end
end
   
//
// Instruction latch in wb_insn
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		wb_insn <=  {`OR1200_OR32_NOP, 26'h041_0000};
	// wb_insn should not be changed by exceptions due to correct 
	// recording of display_arch_state in the or1200_monitor! 
	// wb_insn changed by exception is not used elsewhere! 
	else if (!wb_freeze) begin
		wb_insn <=  ex_insn;
	end
end

//
// Decode of sel_imm
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		sel_imm <=  1'b0;
	else if (!id_freeze) begin
	  case (if_insn[31:26])		// synopsys parallel_case

	    // j.jalr
	    `OR1200_OR32_JALR:
	      sel_imm <=  1'b0;
	    
	    // l.jr
	    `OR1200_OR32_JR:
	      sel_imm <=  1'b0;
	    
	    // l.rfe
	    `OR1200_OR32_RFE:
	      sel_imm <=  1'b0;
	    
	    // l.mfspr
	    `OR1200_OR32_MFSPR:
	      sel_imm <=  1'b0;
	    
	    // l.mtspr
	    `OR1200_OR32_MTSPR:
	      sel_imm <=  1'b0;
	    
	    // l.sys, l.brk and all three sync insns
	    `OR1200_OR32_XSYNC:
	      sel_imm <=  1'b0;
	    
	    // l.mac/l.msb
`ifdef OR1200_MAC_IMPLEMENTED
	    `OR1200_OR32_MACMSB:
	      sel_imm <=  1'b0;
`endif

	    // l.sw
	    `OR1200_OR32_SW:
	      sel_imm <=  1'b0;
	    
	    // l.sb
	    `OR1200_OR32_SB:
	      sel_imm <=  1'b0;
	    
	    // l.sh
	    `OR1200_OR32_SH:
	      sel_imm <=  1'b0;
	    
	    // ALU instructions except the one with immediate
	    `OR1200_OR32_ALU:
	      sel_imm <=  1'b0;
	    
	    // SFXX instructions
	    `OR1200_OR32_SFXX:
	      sel_imm <=  1'b0;

`ifdef OR1200_IMPL_ALU_CUST5
	    // l.cust5 instructions
	    `OR1200_OR32_CUST5:
	      sel_imm <=  1'b0;
`endif
`ifdef OR1200_FPU_IMPLEMENTED
	    // FPU instructions
	    `OR1200_OR32_FLOAT:
	      sel_imm <=  1'b0;
`endif
	    // l.nop
	    `OR1200_OR32_NOP:
	      sel_imm <=  1'b0;

	    // All instructions with immediates
	    default: begin
	      sel_imm <=  1'b1;
	    end
	    
	  endcase
	  
	end
end

//
// Decode of except_illegal
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		except_illegal <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		except_illegal <=  1'b0;
	else if (!ex_freeze) begin
		case (id_insn[31:26])		// synopsys parallel_case

		`OR1200_OR32_J,
		`OR1200_OR32_JAL,
		`OR1200_OR32_JALR,
		`OR1200_OR32_JR,
		`OR1200_OR32_BNF,
		`OR1200_OR32_BF,
		`OR1200_OR32_RFE,
		`OR1200_OR32_MOVHI,
		`OR1200_OR32_MFSPR,
		`OR1200_OR32_XSYNC,
`ifdef OR1200_MAC_IMPLEMENTED
		`OR1200_OR32_MACI,
`endif
		`OR1200_OR32_LWZ,
		`OR1200_OR32_LWS,
		`OR1200_OR32_LBZ,
		`OR1200_OR32_LBS,
		`OR1200_OR32_LHZ,
		`OR1200_OR32_LHS,
		`OR1200_OR32_ADDI,
		`OR1200_OR32_ADDIC,
		`OR1200_OR32_ANDI,
		`OR1200_OR32_ORI,
		`OR1200_OR32_XORI,
`ifdef OR1200_MULT_IMPLEMENTED
		`OR1200_OR32_MULI,
`endif
`ifdef OR1200_IMPL_ALU_ROTATE		  
		`OR1200_OR32_SH_ROTI,
`endif
		`OR1200_OR32_SFXXI,
		`OR1200_OR32_MTSPR,
`ifdef OR1200_MAC_IMPLEMENTED
		`OR1200_OR32_MACMSB,
`endif
		`OR1200_OR32_SW,
		`OR1200_OR32_SB,
		`OR1200_OR32_SH,
		`OR1200_OR32_SFXX,
`ifdef OR1200_IMPL_ALU_CUST5
		`OR1200_OR32_CUST5,
`endif
	`OR1200_OR32_NOP:
		except_illegal <=  1'b0;
`ifdef OR1200_FPU_IMPLEMENTED
	    `OR1200_OR32_FLOAT:
                // Check it's not a double precision instruction
                except_illegal <=  id_insn[`OR1200_FPUOP_DOUBLE_BIT];
`endif	      

	`OR1200_OR32_ALU:
		except_illegal <=  1'b0 

`ifdef OR1200_MULT_IMPLEMENTED
`ifdef OR1200_DIV_IMPLEMENTED
`else 
		| (id_insn[4:0] == `OR1200_ALUOP_DIV)
		| (id_insn[4:0] == `OR1200_ALUOP_DIVU)
`endif
`else
		| (id_insn[4:0] == `OR1200_ALUOP_DIV)
		| (id_insn[4:0] == `OR1200_ALUOP_DIVU)
		| (id_insn[4:0] == `OR1200_ALUOP_MUL)
`endif

`ifdef OR1200_IMPL_ADDC
`else
		| (id_insn[4:0] == `OR1200_ALUOP_ADDC)
`endif

`ifdef OR1200_IMPL_ALU_FFL1
`else
		| (id_insn[4:0] == `OR1200_ALUOP_FFL1)
`endif

`ifdef OR1200_IMPL_ALU_ROTATE
`else
		| ((id_insn[4:0] == `OR1200_ALUOP_SHROT) &
		   (id_insn[9:6] == `OR1200_SHROTOP_ROR))
`endif

`ifdef OR1200_IMPL_SUB
`else
		| (id_insn[4:0] == `OR1200_ALUOP_SUB)
`endif
`ifdef OR1200_IMPL_ALU_EXT
`else
		| (id_insn[4:0] == `OR1200_ALUOP_EXTHB)
		| (id_insn[4:0] == `OR1200_ALUOP_EXTW)
`endif
		;

		// Illegal and OR1200 unsupported instructions
	default:
		except_illegal <=  1'b1;

	endcase
	end // if (!ex_freeze)
end
   

//
// Decode of alu_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		alu_op <=  `OR1200_ALUOP_NOP;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		alu_op <=  `OR1200_ALUOP_NOP;
	else if (!ex_freeze) begin
	  case (id_insn[31:26])		// synopsys parallel_case
	    
	    // l.movhi
	    `OR1200_OR32_MOVHI:
	      alu_op <=  `OR1200_ALUOP_MOVHI;
	    
	    // l.addi
	    `OR1200_OR32_ADDI:
	      alu_op <=  `OR1200_ALUOP_ADD;
	    
	    // l.addic
	    `OR1200_OR32_ADDIC:
	      alu_op <=  `OR1200_ALUOP_ADDC;
	    
	    // l.andi
	    `OR1200_OR32_ANDI:
	      alu_op <=  `OR1200_ALUOP_AND;
	    
	    // l.ori
	    `OR1200_OR32_ORI:
	      alu_op <=  `OR1200_ALUOP_OR;
	    
	    // l.xori
	    `OR1200_OR32_XORI:
	      alu_op <=  `OR1200_ALUOP_XOR;
	    
	    // l.muli
`ifdef OR1200_MULT_IMPLEMENTED
	    `OR1200_OR32_MULI:
	      alu_op <=  `OR1200_ALUOP_MUL;
`endif
`ifdef OR1200_IMPL_ALU_ROTATE	    
	    // Shift and rotate insns with immediate
	    `OR1200_OR32_SH_ROTI:
	      alu_op <=  `OR1200_ALUOP_SHROT;
`endif  
	    // SFXX insns with immediate
	    `OR1200_OR32_SFXXI:
	      alu_op <=  `OR1200_ALUOP_COMP;
	    
	    // ALU instructions except the one with immediate
	    `OR1200_OR32_ALU:
	      alu_op <=  {1'b0,id_insn[3:0]};
	    
	    // SFXX instructions
	    `OR1200_OR32_SFXX:
	      alu_op <=  `OR1200_ALUOP_COMP;
`ifdef OR1200_IMPL_ALU_CUST5	    
	    // l.cust5
	    `OR1200_OR32_CUST5:
	      alu_op <=  `OR1200_ALUOP_CUST5;
`endif	    
	    // Default
	    default: begin
	      alu_op <=  `OR1200_ALUOP_NOP;
	    end
	      
	  endcase
	  
	end
end


//
// Decode of second ALU operation field [9:6]
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		alu_op2 <=  0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
	        alu_op2 <= 0;
   	else if (!ex_freeze) begin
		alu_op2 <=  id_insn[`OR1200_ALUOP2_POS];
	end
end

//
// Decode of spr_read, spr_write
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		spr_read <=  1'b0;
		spr_write <=  1'b0;
	end
	else if (!ex_freeze & id_freeze | ex_flushpipe) begin
		spr_read <=  1'b0;
		spr_write <=  1'b0;
	end
	else if (!ex_freeze) begin
		case (id_insn[31:26])     // synopsys parallel_case

		// l.mfspr
		`OR1200_OR32_MFSPR: begin
			spr_read <=  1'b1;
			spr_write <=  1'b0;
		end

		// l.mtspr
		`OR1200_OR32_MTSPR: begin
			spr_read <=  1'b0;
			spr_write <=  1'b1;
		end

		// Default
		default: begin
			spr_read <=  1'b0;
			spr_write <=  1'b0;
		end

		endcase
	end
end

//
// Decode of mac_op
//
`ifdef OR1200_MAC_IMPLEMENTED
always @(id_insn) begin
	case (id_insn[31:26])		// synopsys parallel_case

	// l.maci
	`OR1200_OR32_MACI:
		id_mac_op =  `OR1200_MACOP_MAC;

	// l.mac, l.msb
	`OR1200_OR32_MACMSB:
		id_mac_op =  id_insn[2:0];

	// Illegal and OR1200 unsupported instructions
	default:
		id_mac_op =  `OR1200_MACOP_NOP;

	endcase
end

always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		ex_mac_op <=  `OR1200_MACOP_NOP;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_mac_op <=  `OR1200_MACOP_NOP;
	else if (!ex_freeze)
		ex_mac_op <=  id_mac_op;
end

assign mac_op = abort_mvspr ? `OR1200_MACOP_NOP : ex_mac_op;
`else
assign id_mac_op = `OR1200_MACOP_NOP;
assign mac_op = `OR1200_MACOP_NOP;
`endif


//
// Decode of rfwb_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		rfwb_op <=  `OR1200_RFWBOP_NOP;
	else  if (!ex_freeze & id_freeze | ex_flushpipe)
		rfwb_op <=  `OR1200_RFWBOP_NOP;
	else  if (!ex_freeze) begin
		case (id_insn[31:26])		// synopsys parallel_case

		// j.jal
		`OR1200_OR32_JAL:
			rfwb_op <=  {`OR1200_RFWBOP_LR, 1'b1};
		  
		// j.jalr
		`OR1200_OR32_JALR:
			rfwb_op <=  {`OR1200_RFWBOP_LR, 1'b1};
		  
		// l.movhi
		`OR1200_OR32_MOVHI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.mfspr
		`OR1200_OR32_MFSPR:
			rfwb_op <=  {`OR1200_RFWBOP_SPRS, 1'b1};
		  
		// l.lwz
		`OR1200_OR32_LWZ:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};

		// l.lws
		`OR1200_OR32_LWS:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};

		// l.lbz
		`OR1200_OR32_LBZ:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.lbs
		`OR1200_OR32_LBS:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.lhz
		`OR1200_OR32_LHZ:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.lhs
		`OR1200_OR32_LHS:
			rfwb_op <=  {`OR1200_RFWBOP_LSU, 1'b1};
		  
		// l.addi
		`OR1200_OR32_ADDI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.addic
		`OR1200_OR32_ADDIC:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.andi
		`OR1200_OR32_ANDI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.ori
		`OR1200_OR32_ORI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.xori
		`OR1200_OR32_XORI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
		  
		// l.muli
`ifdef OR1200_MULT_IMPLEMENTED
		`OR1200_OR32_MULI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
`endif
		  
		// Shift and rotate insns with immediate
`ifdef OR1200_IMPL_ALU_ROTATE
		`OR1200_OR32_SH_ROTI:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
`endif
		// ALU instructions except the one with immediate
		`OR1200_OR32_ALU:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};

`ifdef OR1200_ALU_IMPL_CUST5
		// l.cust5 instructions
		`OR1200_OR32_CUST5:
			rfwb_op <=  {`OR1200_RFWBOP_ALU, 1'b1};
`endif
`ifdef OR1200_FPU_IMPLEMENTED
		  // FPU instructions, lf.XXX.s, except sfxx
		  `OR1200_OR32_FLOAT:
		    rfwb_op <=  {`OR1200_RFWBOP_FPU,!id_insn[3]};
`endif
		// Instructions w/o register-file write-back
		default: 
			rfwb_op <=  `OR1200_RFWBOP_NOP;


		endcase
	end
end

//
// Decode of id_branch_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		id_branch_op <=  `OR1200_BRANCHOP_NOP;
	else if (id_flushpipe)
		id_branch_op <=  `OR1200_BRANCHOP_NOP;
	else if (!id_freeze) begin
		case (if_insn[31:26])		// synopsys parallel_case

		// l.j
		`OR1200_OR32_J:
			id_branch_op <=  `OR1200_BRANCHOP_J;
		  
		// j.jal
		`OR1200_OR32_JAL:
			id_branch_op <=  `OR1200_BRANCHOP_J;
		  
		// j.jalr
		`OR1200_OR32_JALR:
			id_branch_op <=  `OR1200_BRANCHOP_JR;
		  
		// l.jr
		`OR1200_OR32_JR:
			id_branch_op <=  `OR1200_BRANCHOP_JR;
		  
		// l.bnf
		`OR1200_OR32_BNF:
			id_branch_op <=  `OR1200_BRANCHOP_BNF;
		  
		// l.bf
		`OR1200_OR32_BF:
			id_branch_op <=  `OR1200_BRANCHOP_BF;
		  
		// l.rfe
		`OR1200_OR32_RFE:
			id_branch_op <=  `OR1200_BRANCHOP_RFE;
		  
		// Non branch instructions
		default:
			id_branch_op <=  `OR1200_BRANCHOP_NOP;

		endcase
	end
end

//
// Generation of ex_branch_op
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		ex_branch_op <=  `OR1200_BRANCHOP_NOP;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_branch_op <=  `OR1200_BRANCHOP_NOP;		
	else if (!ex_freeze)
		ex_branch_op <=  id_branch_op;

//
// Decode of id_lsu_op
//
always @(id_insn) begin
	case (id_insn[31:26])		// synopsys parallel_case

	// l.lwz
	`OR1200_OR32_LWZ:
		id_lsu_op =  `OR1200_LSUOP_LWZ;

	// l.lws
	`OR1200_OR32_LWS:
		id_lsu_op =  `OR1200_LSUOP_LWS;

	// l.lbz
	`OR1200_OR32_LBZ:
		id_lsu_op =  `OR1200_LSUOP_LBZ;

	// l.lbs
	`OR1200_OR32_LBS:
		id_lsu_op =  `OR1200_LSUOP_LBS;

	// l.lhz
	`OR1200_OR32_LHZ:
		id_lsu_op =  `OR1200_LSUOP_LHZ;

	// l.lhs
	`OR1200_OR32_LHS:
		id_lsu_op =  `OR1200_LSUOP_LHS;

	// l.sw
	`OR1200_OR32_SW:
		id_lsu_op =  `OR1200_LSUOP_SW;

	// l.sb
	`OR1200_OR32_SB:
		id_lsu_op =  `OR1200_LSUOP_SB;

	// l.sh
	`OR1200_OR32_SH:
		id_lsu_op =  `OR1200_LSUOP_SH;

	// Non load/store instructions
	default:
		id_lsu_op =  `OR1200_LSUOP_NOP;

	endcase
end

//
// Decode of comp_op
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		comp_op <=  4'd0;
	end else if (!ex_freeze & id_freeze | ex_flushpipe)
		comp_op <=  4'd0;
	else if (!ex_freeze)
		comp_op <=  id_insn[24:21];
end

`ifdef OR1200_FPU_IMPLEMENTED
//
// Decode of FPU ops
//
   assign fpu_op = {(id_insn[31:26] == `OR1200_OR32_FLOAT), 
		    id_insn[`OR1200_FPUOP_WIDTH-2:0]};
`else
   assign fpu_op = {`OR1200_FPUOP_WIDTH{1'b0}};
`endif

   
//
// Decode of l.sys
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		sig_syscall <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		sig_syscall <=  1'b0;
	else if (!ex_freeze) begin
`ifdef OR1200_VERBOSE
// synopsys translate_off
		if (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b000})
			$display(""Generating sig_syscall"");
// synopsys translate_on
`endif
		sig_syscall <=  (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b000});
	end
end

//
// Decode of l.trap
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE)
		sig_trap <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		sig_trap <=  1'b0;
	else if (!ex_freeze) begin
`ifdef OR1200_VERBOSE
// synopsys translate_off
		if (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b010})
			$display(""Generating sig_trap"");
// synopsys translate_on
`endif
		sig_trap <=  (id_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b010})
			| du_hwbkpt;
	end
end

// Decode destination register address for data cache to check if store ops
// are being done from the stack register (r1) or frame pointer register (r2)
`ifdef OR1200_DC_NOSTACKWRITETHROUGH   
always @(posedge clk or `OR1200_RST_EVENT rst) begin
   if (rst == `OR1200_RST_VALUE)
     dc_no_writethrough <= 0;
   else if (!ex_freeze)
     dc_no_writethrough <= (id_insn[20:16] == 5'd1) | (id_insn[20:16] == 5'd2);
end
`else
   
   assign dc_no_writethrough = 0;
  
`endif      

   
endmodule","{
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!ex_freeze & ex_delayslot_dsi & !ex_delayslot_nop) |-> ##1 (ex_delayslot_nop == 0 && ex_delayslot_dsi == 0)"",
    ""Signals"": [
      ""ex_freeze"",
      ""ex_delayslot_dsi"",
      ""ex_delayslot_nop""
    ],
    ""Signal Explanations"": {
      ""ex_freeze"": ""a signal indicating whether the execution stage is frozen"",
      ""ex_delayslot_dsi"": ""a flag that signifies a delay slot instruction is present in the execution stage"",
      ""ex_delayslot_nop"": ""a flag that indicates a filler no‐operation instruction is present in the execution stage""
    },
    ""Logical Operators"": [
      ""!"",
      ""&"",
      ""|->"",
      ""##1"",
      ""=="",
      ""&&""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is deactivated (0)"",
      ""&"": ""logical AND, combining conditions"",
      ""|->"": ""non-overlapping implication, meaning if the left condition holds then the right condition must hold in the specified future cycle"",
      ""##1"": ""a delay of one clock cycle"",
      ""=="": ""equality comparison"",
      ""&&"": ""logical AND, combining boolean expressions""
    },
    ""Assertion Explaination"": ""if the execution stage is not frozen and a delay slot instruction is active while a filler nop is not active, then one clock cycle later both the filler nop flag and the delay slot instruction flag are deactivated""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!ex_freeze & id_freeze | ex_flushpipe) |-> ##1 (ex_macrc_op == 0)"",
    ""Signals"": [
      ""ex_freeze"",
      ""id_freeze"",
      ""ex_flushpipe"",
      ""ex_macrc_op""
    ],
    ""Signal Explanations"": {
      ""ex_freeze"": ""a signal indicating whether the execution stage is frozen"",
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""ex_flushpipe"": ""a signal that flushes the pipeline in the execution stage"",
      ""ex_macrc_op"": ""a signal representing the MAC read configuration operation in the execution stage""
    },
    ""Logical Operators"": [
      ""!"",
      ""&"",
      ""|"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is deactivated"",
      ""&"": ""logical AND, combining conditions"",
      ""|"": ""logical OR, meaning at least one of the conditions must be true"",
      ""|->"": ""non-overlapping implication, meaning if the left-hand condition holds then the right-hand condition must hold after the specified delay"",
      ""##1"": ""a delay of one clock cycle"",
      ""=="": ""equality comparison""
    },
    ""Assertion Explaination"": ""if the execution stage is not frozen and the decode stage is frozen or the execution flush signal is active, then one clock cycle later the MAC read configuration operation signal is deactivated""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(id_flushpipe) |-> ##1 (id_insn == {`OR1200_OR32_NOP, 26'h041_0000})"",
    ""Signals"": [
      ""id_flushpipe"",
      ""id_insn""
    ],
    ""Signal Explanations"": {
      ""id_flushpipe"": ""a signal that flushes the instruction decode pipeline"",
      ""id_insn"": ""the instruction latched in the decode stage, which should represent a no‐operation when flushed""
    },
    ""Logical Operators"": [
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication, meaning if the left-hand condition is true then the right-hand condition must become true in the next cycle"",
      ""##1"": ""a delay of one clock cycle"",
      ""=="": ""equality comparison""
    },
    ""Assertion Explaination"": ""if the decode pipeline flush signal is active, then one clock cycle later the instruction in the decode stage is set to the no‐operation instruction""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!ex_freeze & id_freeze | ex_flushpipe) |-> ##1 (ex_insn == {`OR1200_OR32_NOP, 26'h041_0000})"",
    ""Signals"": [
      ""ex_freeze"",
      ""id_freeze"",
      ""ex_flushpipe"",
      ""ex_insn""
    ],
    ""Signal Explanations"": {
      ""ex_freeze"": ""a signal indicating whether the execution stage is frozen"",
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""ex_flushpipe"": ""a signal that flushes the execution stage pipeline"",
      ""ex_insn"": ""the instruction latched in the execution stage, expected to be a no‐operation when flushed""
    },
    ""Logical Operators"": [
      ""!"",
      ""&"",
      ""|"",
      ""|->"",
      ""##1"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is deactivated"",
      ""&"": ""logical AND, combining conditions"",
      ""|"": ""logical OR, indicating that if any of the grouped conditions are true"",
      ""|->"": ""non-overlapping implication, enforcing that when the left-hand condition holds, the right-hand condition follows after the delay"",
      ""##1"": ""a delay of one clock cycle"",
      ""=="": ""equality comparison""
    },
    ""Assertion Explaination"": ""if the execution stage is not frozen and the decode stage is frozen or the execution flush signal is active, then one clock cycle later the instruction in the execution stage is set to the no‐operation instruction""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_JALR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the instruction fetched in the instruction fetch stage"",
      ""sel_imm"": ""a signal that selects whether an immediate operand is used""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, indicating the signal is not active"",
      ""&&"": ""logical AND, requiring both conditions to be true"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, meaning if the left condition holds then the right condition must hold after the delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode in the instruction fetch stage matches the jump-and-link register instruction, then one clock cycle later the signal for selecting an immediate operand is deactivated""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_JR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the fetched instruction in the instruction fetch stage"",
      ""sel_imm"": ""a signal determining whether an immediate operand is selected""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is inactive"",
      ""&&"": ""logical AND, combining the conditions"",
      ""=="": ""equality check"",
      ""|->"": ""non-overlapping implication, meaning when the condition on the left holds, the condition on the right must hold after the delay"",
      ""##1"": ""a one clock cycle delay""
    },
    ""Assertion Explaination"": ""if the decode stage is not frozen and the opcode from the instruction fetch stage matches the jump register instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_RFE) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the instruction fetched in the instruction fetch stage"",
      ""sel_imm"": ""a signal that selects the use of an immediate operand""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, signifying a signal is inactive"",
      ""&&"": ""logical AND, requiring both conditions to be met"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, enforcing that if the left condition holds then the right condition must follow after the delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode in the instruction fetch stage equals the return-from-exception instruction, then one clock cycle later the signal for selecting an immediate operand is deactivated""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_MFSPR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field extracted from the fetched instruction in the instruction fetch stage"",
      ""sel_imm"": ""a control signal that determines whether an immediate operand is used""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, indicating a signal is not active"",
      ""&&"": ""logical AND, combining multiple conditions"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, meaning if the left condition holds then the right must hold after the delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode from the instruction fetch stage matches the move from special-purpose register instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_MTSPR) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the fetched instruction in the instruction fetch stage"",
      ""sel_imm"": ""a control signal for selecting an immediate operand""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is inactive"",
      ""&&"": ""logical AND, combining the condition checks"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, meaning if the left-hand condition is met then the right-hand condition must follow after a delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is not frozen and the opcode from the instruction fetch stage equals the move to special-purpose register instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_XSYNC) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the instruction fetched in the instruction fetch stage"",
      ""sel_imm"": ""a control signal for selecting the immediate operand""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, indicating that the signal is inactive"",
      ""&&"": ""logical AND, requiring both conditions to be true"",
      ""=="": ""equality check"",
      ""|->"": ""non-overlapping implication, ensuring that if the left condition holds then the right condition must hold after the delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode from the instruction fetch stage corresponds to the system synchronization instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_SW) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the fetched instruction in the instruction fetch stage"",
      ""sel_imm"": ""a control signal that determines whether an immediate operand is used""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is not active"",
      ""&&"": ""logical AND, combining conditions together"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, which specifies that if the left condition is true then the right condition must be true after a delay"",
      ""##1"": ""a one clock cycle delay""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode from the instruction fetch stage equals the store word instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_SB) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the fetched instruction in the instruction fetch stage"",
      ""sel_imm"": ""a control signal for selecting an immediate operand""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, indicating that the signal is inactive"",
      ""&&"": ""logical AND, which combines the conditions"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, meaning that if the left-hand condition is satisfied then the right-hand condition will hold after the specified delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode from the instruction fetch stage equals the store byte instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_ALU) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the instruction fetched in the instruction fetch stage"",
      ""sel_imm"": ""a control signal that selects whether to use an immediate operand""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, meaning the signal is inactive"",
      ""&&"": ""logical AND, requiring both conditions to be true"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, which enforces that if the left condition is met then the right condition must follow after the delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode from the instruction fetch stage equals an ALU operation instruction, then one clock cycle later the immediate selection signal is deactivated""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!id_freeze && if_insn[31:26] == `OR1200_OR32_SFXX) |-> ##1 (sel_imm ==  1'b0)"",
    ""Signals"": [
      ""id_freeze"",
      ""if_insn[31:26]"",
      ""sel_imm""
    ],
    ""Signal Explanations"": {
      ""id_freeze"": ""a signal indicating whether the instruction decode stage is frozen"",
      ""if_insn[31:26]"": ""the opcode field from the fetched instruction in the instruction fetch stage"",
      ""sel_imm"": ""a signal that determines whether an immediate operand is selected""
    },
    ""Logical Operators"": [
      ""!"",
      ""&&"",
      ""=="",
      ""|->"",
      ""##1""
    ],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation, indicating the signal is inactive"",
      ""&&"": ""logical AND, combining the required conditions"",
      ""=="": ""equality comparison"",
      ""|->"": ""non-overlapping implication, meaning that if the left-hand condition holds then the right-hand condition will hold after the delay"",
      ""##1"": ""a delay of one clock cycle""
    },
    ""Assertion Explaination"": ""if the decode stage is active and the opcode from the instruction fetch stage corresponds to a special function instruction, then one clock cycle later the immediate selection signal is deactivated""
  }
}","{
""Assertion 1"": ""assert property ( (ex_delayslot_dsi && !ex_delayslot_nop && !ex_freeze) |-> ##1 (!ex_delayslot_nop && !ex_delayslot_dsi) );"",
""Assertion 2"": ""assert property (ex_freeze == 1'b0 && id_freeze == 1'b1 || ex_flushpipe == 1'b1 |->                   (ex_macrc_op == 1'b0));"",
""Assertion 3"": ""assert property ((if_flushpipe | id_flushpipe | ex_flushpipe | wb_flushpipe | du_flush_pipe | except_flushpipe) ->                   id_insn == {`OR1200_OR32_NOP, 26'h041_0000}[31:0] after 1);"",
""Assertion 4"": ""assert property (ex_freeze == 1'b0 && id_freeze == 1'b1 || ex_flushpipe == 1'b1 |=> #1 (ex_insn == {`OR1200_OR32_NOP, 26'h041_0000}));"",
""Assertion 5"": ""assert property (id_freeze == 0 && (if_insn[31:26] == `OR1200_OR32_JALR) |-> (!sel_imm));"",
""Assertion 6"": ""assert property (id_freeze == 1'b0 && (if_insn[31:26] == `OR1200_OR32_JR) |-> !sel_imm);"",
""Assertion 7"": ""assert property (id_freeze && (if_insn[31:26] == `OR1200_OR32_RFE) |-> !sel_imm);"",
""Assertion 8"": ""assert property (id_freeze == 1'b0 && (if_insn[31:26] == `OR1200_OR32_MFSPR |-> sel_imm == 1'b0));"",
""Assertion 9"": ""assert property (id_freeze == 1'b0 && (if_insn[31:26] == `OR1200_OR32_MTSPR) |-> (sel_imm == 1'b0));"",
""Assertion 10"": ""assert property (id_freeze && (if_insn[31:23] == {`OR1200_OR32_XSYNC, 3'b000}) |-> !sel_imm);"",
""Assertion 11"": ""assert property (id_freeze == 0 && (if_insn[31:26] == `OR1200_OR32_SW) |-> sel_imm == 0);"",
""Assertion 12"": ""assert property (id_freeze == 1'b0 && (if_insn[31:26] == `OR1200_OR32_SB) |-> (sel_imm == 1'b0));"",
""Assertion 13"": ""assert property (id_freeze == 1'b0 && if_insn[31:26] == `OR1200_OR32_ALU -> (sel_imm == 1'b1 ##1 sel_imm == 1'b0));"",
""Assertion 14"": ""assert property (id_freeze && ((if_insn[31:26] == `OR1200_OR32_SFXX) || (if_insn[31:26] == `OR1200_OR32_SFXXI)) |-> !sel_imm);""
}"
