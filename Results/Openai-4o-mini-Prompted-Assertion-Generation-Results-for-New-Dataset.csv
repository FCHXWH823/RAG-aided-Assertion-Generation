Master Module,Code,golden_assertions,llm_assertions
APB_FSM_Controller,"
// AHB to APG Bridge | Maven Silicon
//
//
//
// APB FSM Controller
// Date:08-06-2022
//
// By-Prajwal Kumar Sahu

module APB_FSM_Controller( Hclk,Hresetn,valid,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata,Hwrite,Haddr,Hwdata,Hwritereg,tempselx, 
			   Pwrite,Penable,Pselx,Paddr,Pwdata,Hreadyout);

input Hclk,Hresetn,valid,Hwrite,Hwritereg;
input [31:0] Hwdata,Haddr,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata;
input [2:0] tempselx;
output reg Pwrite,Penable;
output reg Hreadyout;  
output reg [2:0] Pselx;
output reg [31:0] Paddr,Pwdata;

//////////////////////////////////////////////////////PARAMETERS

parameter ST_IDLE=3'b000;
parameter ST_WWAIT=3'b001;
parameter ST_READ= 3'b010;
parameter ST_WRITE=3'b011;
parameter ST_WRITEP=3'b100;
parameter ST_RENABLE=3'b101;
parameter ST_WENABLE=3'b110;
parameter ST_WENABLEP=3'b111;


//////////////////////////////////////////////////// PRESENT STATE LOGIC

reg [2:0] PRESENT_STATE,NEXT_STATE;

always @(posedge Hclk)
 begin:PRESENT_STATE_LOGIC
  if (~Hresetn)
    PRESENT_STATE<=ST_IDLE;
  else
    PRESENT_STATE<=NEXT_STATE;
 end


/////////////////////////////////////////////////////// NEXT STATE LOGIC

always @(PRESENT_STATE,valid,Hwrite,Hwritereg)
 begin:NEXT_STATE_LOGIC
  case (PRESENT_STATE)
    
 	ST_IDLE:begin
		 if (~valid)
		  NEXT_STATE=ST_IDLE;
		 else if (valid && Hwrite)
		  NEXT_STATE=ST_WWAIT;
		 else 
		  NEXT_STATE=ST_READ;
		end    

	ST_WWAIT:begin
		 if (~valid)
		  NEXT_STATE=ST_WRITE;
		 else
		  NEXT_STATE=ST_WRITEP;
		end

	ST_READ: begin
		   NEXT_STATE=ST_RENABLE;
		 end

	ST_WRITE:begin
		  if (~valid)
		   NEXT_STATE=ST_WENABLE;
		  else
		   NEXT_STATE=ST_WENABLEP;
		 end

	ST_WRITEP:begin
		   NEXT_STATE=ST_WENABLEP;
		  end

	ST_RENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLEP:begin
		      if (~valid && Hwritereg)
		       NEXT_STATE=ST_WRITE;
		      else if (valid && Hwritereg)
		       NEXT_STATE=ST_WRITEP;
		      else
		       NEXT_STATE=ST_READ;
		    end

	default: begin
		   NEXT_STATE=ST_IDLE;
		  end
  endcase
 end


////////////////////////////////////////////////////////OUTPUT LOGIC:COMBINATIONAL

reg Penable_temp,Hreadyout_temp,Pwrite_temp;
reg [2:0] Pselx_temp;
reg [31:0] Paddr_temp, Pwdata_temp;

always @(*)
 begin:OUTPUT_COMBINATIONAL_LOGIC
   case(PRESENT_STATE)
    
	ST_IDLE: begin
			  if (valid && ~Hwrite) 
			   begin:IDLE_TO_READ
			        Paddr_temp=Haddr;
				Pwrite_temp=Hwrite;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Hreadyout_temp=0;
			   end
			  
			  else if (valid && Hwrite)
			   begin:IDLE_TO_WWAIT
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;			   
			   end
			   
			  else
                            begin:IDLE_TO_IDLE
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;	
			   end
		     end    

	ST_WWAIT:begin
	          if (~valid) 
			   begin:WAIT_TO_WRITE
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Pwdata_temp=Hwdata;
				Hreadyout_temp=0;
			   end
			  
			  else 
			   begin:WAIT_TO_WRITEP
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Pwdata_temp=Hwdata;
				Penable_temp=0;
				Hreadyout_temp=0;		   
			   end
			   
		     end  

	ST_READ: begin:READ_TO_RENABLE
			  Penable_temp=1;
			  Hreadyout_temp=1;
		     end

	ST_WRITE:begin
              if (~valid) 
			   begin:WRITE_TO_WENABLE
				Penable_temp=1;
				Hreadyout_temp=1;
			   end
			  
			  else 
			   begin:WRITE_TO_WENABLEP ///DOUBT
				Penable_temp=1;
				Hreadyout_temp=1;		   
			   end
		     end

	ST_WRITEP:begin:WRITEP_TO_WENABLEP
               Penable_temp=1;
			   Hreadyout_temp=1;
		      end

	ST_RENABLE:begin
	            if (valid && ~Hwrite) 
				 begin:RENABLE_TO_READ
					Paddr_temp=Haddr;
					Pwrite_temp=Hwrite;
					Pselx_temp=tempselx;
					Penable_temp=0;
					Hreadyout_temp=0;
				 end
			  
			  else if (valid && Hwrite)
			    begin:RENABLE_TO_WWAIT
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;			   
			    end
			   
			  else
                begin:RENABLE_TO_IDLE
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;	
			    end

		       end

	ST_WENABLEP:begin
                 if (~valid && Hwritereg) 
			      begin:WENABLEP_TO_WRITEP
			       Paddr_temp=Haddr2;
				   Pwrite_temp=Hwrite;
				   Pselx_temp=tempselx;
				   Penable_temp=0;
				   Pwdata_temp=Hwdata;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLEP_TO_WRITE_OR_READ /////DOUBT
			      Paddr_temp=Haddr2;
				  Pwrite_temp=Hwrite;
				  Pselx_temp=tempselx;
				  Pwdata_temp=Hwdata;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end
		        end

	ST_WENABLE :begin
	             if (~valid && Hwritereg) 
			      begin:WENABLE_TO_IDLE
				   Pselx_temp=0;
				   Penable_temp=0;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLE_TO_WAIT_OR_READ /////DOUBT
				  Pselx_temp=0;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end

		        end

 endcase
end


////////////////////////////////////////////////////////OUTPUT LOGIC:SEQUENTIAL

always @(posedge Hclk)
 begin
  
  if (~Hresetn)
   begin
    Paddr<=0;
	Pwrite<=0;
	Pselx<=0;
	Pwdata<=0;
	Penable<=0;
	Hreadyout<=0;
   end
  
  else
   begin
        Paddr<=Paddr_temp;
	Pwrite<=Pwrite_temp;
	Pselx<=Pselx_temp;
	Pwdata<=Pwdata_temp;
	Penable<=Penable_temp;
	Hreadyout<=Hreadyout_temp;
   end
 end
 ///////////////////////


endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""1 |-> ##2 PRESENT_STATE == $past(NEXT_STATE)"",
    ""Signals"": [""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""|->"", ""##2"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##2"": ""a delay operator meaning that the condition on the right is evaluated 2 clock cycles later"",
      ""=="": ""equal"",
      ""$past"": ""the value from previous clock cycle(s)""
    },
    ""Assertion Explaination"": ""Property to verify that after 2 clock cycles the current state of the FSM equals the previous value of the next state of the FSM""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""(PRESENT_STATE == ST_IDLE && valid && Hwrite) |-> (NEXT_STATE == ST_WWAIT)"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_IDLE that when the current state of the FSM equals ST_IDLE, transaction is valid, and a write operation is active, then the next state of the FSM equals ST_WWAIT wait from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_IDLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_IDLE that when the current state of the FSM equals ST_IDLE, transaction is valid, and the write operation is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_IDLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_IDLE that when the current state of the FSM equals ST_IDLE and transaction is not valid, then the next state of the FSM equals ST_IDLE from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WWAIT && !valid |-> NEXT_STATE == ST_WRITE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WWAIT that when the current state of the FSM equals ST_WWAIT and transaction is not valid, then the next state of the FSM equals ST_WRITE from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WWAIT && valid |-> NEXT_STATE == ST_WRITEP"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WWAIT that when the current state of the FSM equals ST_WWAIT and transaction is valid, then the next state of the FSM equals ST_WRITEP from the currect clock cycle""

  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE"",
    ""Signals"": [""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_READ that when the current state of the FSM equals ST_READ, then the next state of the FSM equals ST_RENABLE from the current clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITE && !valid |-> NEXT_STATE == ST_WENABLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WRITE that when the current state of the FSM equals ST_WRITE and transaction is not valid, then the next state of the FSM equals ST_WENABLE from the current clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITE && valid |-> NEXT_STATE == ST_WENABLEP"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WRITE that when the current state of the FSM equals ST_WRITE and transaction is valid, then the next state of the FSM equals ST_WENABLEP from the current clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP"",
    ""Signals"": [""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WRITEP that when the current state of the FSM equals ST_WRITEP, then the next state of the FSM equals ST_WENABLEP from the current clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_RENABLE that when the current state of the FSM equals ST_RENABLE and transaction is not valid, then the next state of the FSM equals ST_IDLE from the current clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_RENABLE that when the current state of the FSM equals ST_RENABLE, and transaction is valid, and a write operation is active, then the next state of the FSM equals ST_WWAIT from the current clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_RENABLE that when the current state of the FSM equals ST_RENABLE, and transaction is valid, and the write operation is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLE that when the current state of the FSM equals ST_WENABLE and transaction is not valid, then the next state of the FSM equals ST_IDLE from the current clock cycle""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLE that when the current state of the FSM equals ST_WENABLE, and transaction is valid, and a write operation is active, then the next state of the FSM equals ST_WWAIT from the current clock cycle""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLE that when the current state of the FSM equals ST_WENABLE, transaction is valid, and the write operation is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  },
  ""Assertion 17"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && !valid && Hwritereg |-> NEXT_STATE == ST_WRITE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwritereg"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwritereg"": ""a control signal for write register operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLEP that when the current state of the FSM equals ST_WENABLEP, and transaction is not valid, and the write register control is active, then the next state of the FSM equals ST_WRITE from the current clock cycle""
  },
  ""Assertion 18"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && valid && Hwritereg |-> NEXT_STATE == ST_WRITEP"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwritereg"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwritereg"": ""a control signal for write register operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLEP that when the current state of the FSM equals ST_WENABLEP, and transaction is valid, and the write register control is active, then the next state of the FSM equals ST_WRITEP from the current clock cycle""
  },
  ""Assertion 19"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && !Hwritereg |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""Hwritereg"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""Hwritereg"": ""a control signal for write register operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLEP that when the current state of the FSM equals ST_WENABLEP and the write register control is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (PRESENT_STATE == $past(NEXT_STATE, 2));"",
""Assertion 2"": ""assert property ((PRESENT_STATE == ST_IDLE) && valid && Hwrite |=> NEXT_STATE == ST_WWAIT);"",
""Assertion 3"": ""assert property (PRESENT_STATE == ST_IDLE && valid && ~Hwrite |-> NEXT_STATE == ST_READ);"",
""Assertion 4"": ""assert property ((PRESENT_STATE == ST_IDLE) && (~valid) |-> (NEXT_STATE == ST_IDLE));"",
""Assertion 5"": ""assert property (PRESENT_STATE == ST_WWAIT && ~valid |-> NEXT_STATE == ST_WRITE);"",
""Assertion 6"": ""assert property ((PRESENT_STATE == ST_WWAIT) && valid |-> (NEXT_STATE == ST_WRITEP));"",
""Assertion 7"": ""assert property (PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE);"",
""Assertion 8"": ""assert property (PRESENT_STATE == ST_WRITE && ~valid |-> NEXT_STATE == ST_WENABLE);"",
""Assertion 9"": ""assert property (PRESENT_STATE == ST_WRITE && valid && NEXT_STATE == ST_WENABLEP);"",
""Assertion 10"": ""assert property (PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP);"",
""Assertion 11"": ""assert property (PRESENT_STATE == ST_RENABLE && ~valid |-> NEXT_STATE == ST_IDLE);"",
""Assertion 12"": ""assert property ((PRESENT_STATE == ST_RENABLE) && valid && Hwrite |-> (NEXT_STATE == ST_WWAIT));"",
""Assertion 13"": ""assert property (PRESENT_STATE == ST_RENABLE && valid && ~Hwrite |-> NEXT_STATE == ST_READ);"",
""Assertion 14"": ""assert property (PRESENT_STATE == ST_WENABLE && ~valid && Hwritereg |-> NEXT_STATE == ST_IDLE);"",
""Assertion 15"": ""assert property (PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT);"",
""Assertion 16"": ""assert property (PRESENT_STATE == ST_WENABLE && valid && ~Hwrite |-> NEXT_STATE == ST_READ);"",
""Assertion 17"": ""assert property (PRESENT_STATE == ST_WENABLEP && ~valid && Hwritereg |-> NEXT_STATE == ST_WRITE);"",
""Assertion 18"": ""assert property ((PRESENT_STATE == ST_WENABLEP) && valid && Hwritereg && (NEXT_STATE == ST_WRITEP));"",
""Assertion 19"": ""assert property (PRESENT_STATE == ST_WENABLEP && ~Hwritereg |=> NEXT_STATE == ST_READ);""
}"
