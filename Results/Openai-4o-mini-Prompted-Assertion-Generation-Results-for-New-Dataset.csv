Master Module,Code,golden_assertions,llm_assertions
Ripple_Carry_Adder,"module full_adder 
(
    input a,
    input b,
    input cin,
    output sum,
    output cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (a & cin) | (b & cin);
endmodule

module Ripple_Carry_Adder #(
	parameter DATA_WIDTH=8
)
(
    input [DATA_WIDTH-1:0] a,
    input [DATA_WIDTH-1:0] b,
    input clk,
    input rst,
    output logic [DATA_WIDTH-0:0] sum,
    output logic [DATA_WIDTH-1:0] cout_int
);

logic [DATA_WIDTH:0] carry;
assign carry[0] = 1'b0;

genvar x;
generate
	for( x = 0; x < DATA_WIDTH; x++ ) begin
		// instanciate adder module
		full_adder m_adder(
			.a( a[x] ),
			.b( b[x] ),
			.cin( carry[x]),
			.sum( sum[x] ),
			.cout( carry[x+1] )
		);
	end
endgenerate
// output
assign sum[DATA_WIDTH] = carry[DATA_WIDTH];
assign cout_int        = carry[DATA_WIDTH-1:0];

logic [DATA_WIDTH:0] res;
assign res = a + b;
endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst)"",
    ""logical expression"": ""res == sum"",
    ""Signals"": [""res"", ""sum""],
    ""Signal Explanations"": {
      ""res"": ""result of addition of a and b"",
      ""sum"": ""computed sum output from the ripple-carry adder""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""the result of addition of a and b is equal to the computed sum output from the ripple-carry adder""
  }
}","{
""Assertion 1"": ""assert property ((a + b) == sum);""
}"
or1200_operandmuxes,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's register file read operands mux                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Mux for two register file read operands.                    ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_operandmuxes.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_operandmuxes(
	// Clock and rst
	clk, rst,

	// Internal i/f
	id_freeze, ex_freeze, rf_dataa, rf_datab, ex_forw, wb_forw,
	simm, sel_a, sel_b, operand_a, operand_b, muxed_a, muxed_b
);

parameter width = `OR1200_OPERAND_WIDTH;

//
// I/O
//
input				clk;
input				rst;
input				id_freeze;
input				ex_freeze;
input	[width-1:0]		rf_dataa;
input	[width-1:0]		rf_datab;
input	[width-1:0]		ex_forw;
input	[width-1:0]		wb_forw;
input	[width-1:0]		simm;
input	[`OR1200_SEL_WIDTH-1:0]	sel_a;
input	[`OR1200_SEL_WIDTH-1:0]	sel_b;
output	[width-1:0]		operand_a;
output	[width-1:0]		operand_b;
output	[width-1:0]		muxed_a;
output	[width-1:0]		muxed_b;

//
// Internal wires and regs
//
reg	[width-1:0]		operand_a;
reg	[width-1:0]		operand_b;
reg	[width-1:0]		muxed_a;
reg	[width-1:0]		muxed_b;
reg				saved_a;
reg				saved_b;

//
// Operand A register
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		operand_a <=  32'd0;
		saved_a <=  1'b0;
	end else if (!ex_freeze && id_freeze && !saved_a) begin
		operand_a <=  muxed_a;
		saved_a <=  1'b1;
	end else if (!ex_freeze && !saved_a) begin
		operand_a <=  muxed_a;
	end else if (!ex_freeze && !id_freeze)
		saved_a <=  1'b0;
end

//
// Operand B register
//
always @(posedge clk or `OR1200_RST_EVENT rst) begin
	if (rst == `OR1200_RST_VALUE) begin
		operand_b <=  32'd0;
		saved_b <=  1'b0;
	end else if (!ex_freeze && id_freeze && !saved_b) begin
		operand_b <=  muxed_b;
		saved_b <=  1'b1;
	end else if (!ex_freeze && !saved_b) begin
		operand_b <=  muxed_b;
	end else if (!ex_freeze && !id_freeze)
		saved_b <=  1'b0;
end

//
// Forwarding logic for operand A register
//
always @(ex_forw or wb_forw or rf_dataa or sel_a) begin
`ifdef OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES
	casez (sel_a)	// synopsys parallel_case infer_mux
`else
	casez (sel_a)	// synopsys parallel_case
`endif
		`OR1200_SEL_EX_FORW:
			muxed_a = ex_forw;
		`OR1200_SEL_WB_FORW:
			muxed_a = wb_forw;
		default:
			muxed_a = rf_dataa;
	endcase
end

//
// Forwarding logic for operand B register
//
always @(simm or ex_forw or wb_forw or rf_datab or sel_b) begin
`ifdef OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES
	casez (sel_b)	// synopsys parallel_case infer_mux
`else
	casez (sel_b)	// synopsys parallel_case
`endif
		`OR1200_SEL_IMM:
			muxed_b = simm;
		`OR1200_SEL_EX_FORW:
			muxed_b = ex_forw;
		`OR1200_SEL_WB_FORW:
			muxed_b = wb_forw;
		default:
			muxed_b = rf_datab;
	endcase
end


endmodule","{
  ""leaf_sv_files"": [""or1200_defines""],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_a == 2'd2 && $stable(ex_forw) && $stable(sel_a)) |-> muxed_a == ex_forw"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_a"", ""ex_forw"", ""muxed_a""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_a"": ""selection signal for operand A multiplexer"",
      ""ex_forw"": ""execution forwarding data for operand A"",
      ""muxed_a"": ""operand A multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand A indicates the constant value corresponding to 2'd2, and both the execution forwarding data for operand A and the selection signal for operand A remain stable, then the operand A multiplexer output equals the execution forwarding data for operand A from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_a == 2'd3 && $stable(wb_forw) && $stable(sel_a)) |-> muxed_a == wb_forw"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_a"", ""wb_forw"", ""muxed_a""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_a"": ""selection signal for operand A multiplexer"",
      ""wb_forw"": ""write-back forwarding data for operand A"",
      ""muxed_a"": ""operand A multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand A indicates the constant value corresponding to 2'd3, and both the write-back forwarding data for operand A and the selection signal for operand A remain stable, then the operand A multiplexer output equals the write-back forwarding data for operand A from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && !(sel_a == 2'd2 || sel_a == 2'd3) && $stable(rf_dataa) && $stable(sel_a) && !$isunknown(operand_a)) |-> muxed_a == rf_dataa"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_a"", ""rf_dataa"", ""operand_a"", ""muxed_a""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_a"": ""selection signal for operand A multiplexer"",
      ""rf_dataa"": ""register file data for operand A"",
      ""operand_a"": ""stored operand A value"",
      ""muxed_a"": ""operand A multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""||"", ""!"", ""$isunknown"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0) or inverts the condition"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""||"": ""logical OR"",
      ""$isunknown"": ""checks if a signal has an unknown (X or Z) value"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand A does not indicate the constant values corresponding to 2'd2 or 2'd3, the register file data for operand A and the selection signal for operand A remain stable, and the stored operand A value is known, then the operand A multiplexer output equals the register file data for operand A from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_b == 2'd1 && $stable(simm) && $stable(sel_b)) |-> muxed_b == simm"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""simm"", ""muxed_b""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_b"": ""selection signal for operand B multiplexer"",
      ""simm"": ""signed immediate value"",
      ""muxed_b"": ""operand B multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay if the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand B indicates the constant value corresponding to 2'd1, and both the signed immediate value and the selection signal for operand B remain stable, then the operand B multiplexer output equals the signed immediate value from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_b == 2'd2 && $stable(ex_forw) && $stable(sel_b)) |-> muxed_b == ex_forw"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""ex_forw"", ""muxed_b""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_b"": ""selection signal for operand B multiplexer"",
      ""ex_forw"": ""execution forwarding data for operand B"",
      ""muxed_b"": ""operand B multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand B indicates the constant value corresponding to 2'd2, and both the execution forwarding data for operand B and the selection signal for operand B remain stable, then the operand B multiplexer output equals the execution forwarding data for operand B from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && sel_b == 2'd3 && $stable(wb_forw) && $stable(sel_b)) |-> muxed_b == wb_forw"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""wb_forw"", ""muxed_b""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_b"": ""selection signal for operand B multiplexer"",
      ""wb_forw"": ""write-back forwarding data for operand B"",
      ""muxed_b"": ""operand B multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0)"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand B indicates the constant value corresponding to 2'd3, and both the write-back forwarding data for operand B and the selection signal for operand B remain stable, then the operand B multiplexer output equals the write-back forwarding data for operand B from the current clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(rst)"",
    ""logical expression"": ""$rose(!ex_freeze && !id_freeze) ##1 (!ex_freeze && !id_freeze && !(sel_b == 2'd1 || sel_b == 2'd2 || sel_b == 2'd3) && $stable(rf_datab) && $stable(sel_b)) |-> muxed_b == rf_datab"",
    ""Signals"": [""ex_freeze"", ""id_freeze"", ""sel_b"", ""rf_datab"", ""muxed_b""],
    ""Signal Explanations"": {
      ""ex_freeze"": ""execution stage freeze signal"",
      ""id_freeze"": ""instruction decode stage freeze signal"",
      ""sel_b"": ""selection signal for operand B multiplexer"",
      ""rf_datab"": ""register file data for operand B"",
      ""muxed_b"": ""operand B multiplexer output""
    },
    ""Logical Operators"": [""$rose"", ""!"", ""&&"", ""##1"", ""=="", ""$stable"", ""||"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects that the condition transitions from false to true (rising edge)"",
      ""!"": ""the value of a signal is reset (0) or inverts the condition"",
      ""&&"": ""logical AND"",
      ""##1"": ""delay operator that postpones evaluation by one clock cycle"",
      ""=="": ""equal"",
      ""$stable"": ""ensures that the signal value remains unchanged during the evaluation cycle"",
      ""||"": ""logical OR"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when a rising edge is detected on the condition that the execution stage freeze signal is not active and the instruction decode stage freeze signal is not active, and after a one clock cycle delay the execution stage freeze signal remains not active, the instruction decode stage freeze signal remains not active, the selection signal for operand B does not indicate the constant values corresponding to 2'd1, 2'd2, or 2'd3, and both the register file data for operand B and the selection signal for operand B remain stable, then the operand B multiplexer output equals the register file data for operand B from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (     ((!ex_freeze && !id_freeze)      ##1      (!ex_freeze && !id_freeze        && sel_a == 2'd2        && $stable(ex_forw)        && $stable(sel_a))     ) |-> (muxed_a == ex_forw)   );"",
""Assertion 2"": ""assert property (   (!ex_freeze && !id_freeze)   |-> ##1 (        !ex_freeze     && !id_freeze     && sel_a    == 2'd3     && $stable(wb_forw)     && $stable(sel_a)     && muxed_a  == wb_forw   ) );"",
""Assertion 3"": ""assert property (@(posedge clk)       (!ex_freeze && !id_freeze)     |-> ##1 (           !ex_freeze        && !id_freeze        && sel_a != 2'd2        && sel_a != 2'd3        && $stable(rf_dataa)        && $stable(sel_a)        && $stable(operand_a)      )   );"",
""Assertion 4"": ""assert property (   // when execution and decode stage are not frozen   (!ex_freeze && !id_freeze)   // after one clock cycle, if still not frozen, sel_b indicates immediate and simm/sel_b are stable   ##1 (!ex_freeze && !id_freeze        && sel_b == `OR1200_SEL_IMM        && $stable(simm)        && $stable(sel_b))   // then muxed_b must equal the immediate   |-> (muxed_b == simm) ) @(posedge clk);"",
""Assertion 5"": ""assert property (     ($rose(!ex_freeze && !id_freeze) ##1      (!ex_freeze && !id_freeze       && sel_b == 2'd2       && $stable(ex_forw)       && $stable(sel_b)      )     )   |-> (operand_b == ex_forw) );"",
""Assertion 6"": ""assert property (@(posedge clk)                      (!ex_freeze && !id_freeze)                    ##1                      (!ex_freeze && !id_freeze                       && sel_b == 2’d3                       && $stable(sel_b)                       && $stable(wb_forw))                    |-> (operand_b == wb_forw)                   );"",
""Assertion 7"": ""assert property (     ( (!ex_freeze && !id_freeze)       ##1 ( !ex_freeze && !id_freeze             && sel_b != 2’d1 && sel_b != 2’d2 && sel_b != 2’d3             && $stable(rf_datab) && $stable(sel_b)           )     )     |-> (operand_b == rf_datab)   ) @(posedge clk);""
}"
gray,"module gray #(parameter CBITS = 8) (input clk, input rst, output reg [CBITS-1:0] gray_cnt, output reg sig);
  reg [CBITS-1:0] cnt;
  always@(posedge clk, posedge rst) begin
    if (rst) begin
      cnt = 0;
    end
    else begin
      cnt = cnt + 1;
      gray_cnt = (cnt) ^ ((cnt) >> 1);
      if(gray_cnt == 0)
        sig = 1;
      else
        sig = 0;
    end
  end
  // F G (rst = F) -> G F (sig = T)
endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""s_eventually (rst || sig == 1)"",
    ""Signals"": [""rst"", ""sig""],
    ""Signal Explanations"": {
      ""rst"": ""reset signal"",
      ""sig"": ""signal that indicates when the computed Gray code counter equals 0""
    },
    ""Logical Operators"": [""s_eventually"", ""||"", ""==""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
      ""||"": ""or"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""eventually, the reset signal equals 1 or the signal that indicates when the Gray code counter equals 0 equals 1""
  }
}","{
""Assertion 1"": ""assert property (s_eventually(rst == 1 || sig == 1));""
}"
Flip_Flop_Array,"module Flip_Flop_Array #(
	parameter DATA_W = 8,
	parameter ADDR_W = 3,
	parameter DATA_N = 8 // getting non constant error when using $pow(2,ADDR_W)
)
(
    input clk,
    input resetn,

    input [DATA_W-1:0] din,
    input [ADDR_W-1:0] addr,
    input              wr,
    input              rd,

    output logic [DATA_W-1:0] dout,
    output logic              error
);

// register file
reg   [DATA_W-1:0] data_q[DATA_N-1:0];
reg   [DATA_N-1:0] data_v_q;
logic [DATA_W-1:0] data_rd[DATA_N-1:0];
logic [DATA_N-1:0] data_v_next;
logic [DATA_N-1:0] rd_en;
logic [DATA_N-1:0] wr_en;
logic [DATA_N-1:0] addr_v;
logic rd_v;
always @(posedge clk)
begin
	if ( ~resetn ) begin
		data_v_q <= {DATA_N{1'b0}};
	end else begin
		data_v_q <= data_v_next;
	end
end

genvar x;
generate
	for( x=0; x < DATA_N; x++) begin
		assign addr_v[x] = addr == x;
		assign wr_en[x]  = wr & addr_v[x];	
		assign rd_en[x]  = rd & addr_v[x];

		assign data_v_next[x] = wr_en[x];
		assign data_rd[x] = {DATA_W{rd_en[x]}} & data_q[x];
 
		always @(posedge clk) begin
			if ( wr_en[x] ) begin
				data_q[x] <= din;
			end
		end	
	end
endgenerate
// read valid
assign rd_v  = data_v_q & rd_en;

assign error = ( rd & ~|rd_v) |  wr & rd ;

always_comb begin
	for( int i=0; i < DATA_N; i++ ) begin
		if ( 1 << i == rd_v ) dout = data_rd[i];
	end
	dout = {DATA_W{1'b0}};
end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""~(rd & wr) | (rd & wr & error)"",
    ""Signals"": [
      ""rd"",
      ""wr"",
      ""error""
    ],
    ""Signal Explanations"": {
      ""rd"": ""read operation signal of the verilog module"",
      ""wr"": ""write operation signal of the verilog module"",
      ""error"": ""error flag output of the verilog module""
    },
    ""Logical Operators"": [
      ""~"",
      ""&"",
      ""|""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical negation operator meaning that the condition is inverted"",
      ""&"": ""logical and operator meaning that the conditions on both sides must hold"",
      ""|"": ""logical or operator meaning that at least one of the conditions must hold""
    },
    ""Assertion Explaination"": ""if read operation signal and write operation signal are both active, then error signal should be active from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""~(~data_v_q & rd_en) | (~data_v_q & rd_en & (dout == '0))"",
    ""Signals"": [
      ""data_v_q"",
      ""rd_en"",
      ""dout""
    ],
    ""Signal Explanations"": {
      ""data_v_q"": ""vector of valid bits for each entry in the flip-flop array"",
      ""rd_en"": ""read enable vector where each bit corresponds to whether the address is selected for reading"",
      ""dout"": ""data output signal of the verilog module""
    },
    ""Logical Operators"": [
      ""~"",
      ""&"",
      ""|"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical negation operator meaning that the condition is inverted"",
      ""&"": ""logical and operator meaning that the conditions on both sides must hold"",
      ""|"": ""logical or operator meaning that at least one of the conditions must hold"",
      ""=="": ""equality comparison operator meaning that the two values are equal""
    },
    ""Assertion Explaination"": ""if the condition where data valid indicator is not active and read enable is active holds, then data output must equal zero from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""$onehot0(rd_v)"",
    ""Signals"": [
      ""rd_v""
    ],
    ""Signal Explanations"": {
      ""rd_v"": ""read valid signal computed as the and of the valid bits of the flip-flop array and the read enable vector""
    },
    ""Logical Operators"": [
      ""$onehot0""
    ],
    ""Logical Operators Explanation"": {
      ""$onehot0"": ""a function that checks that the vector has either no bits set or exactly one bit set""
    },
    ""Assertion Explaination"": ""the read valid signal must have at most one bit active""
  }
}","{
""Assertion 1"": ""assert property ((rd && wr) |-> error);"",
""Assertion 2"": ""assert property ((~data_v_q & rd_en) |-> (dout == {DATA_W{1'b0}}));"",
""Assertion 3"": ""assert property ($onehot0(rd_v));""
}"
PSGBusArb,"`timescale 1ns / 1ps
//=============================================================================
//	(C) 2007,2012  Robert Finch
//  robfinch<remove>@opencores.org
//	All rights reserved.
//
//	PSGBusArb.v
//
// This source file is free software: you can redistribute it and/or modify 
// it under the terms of the GNU Lesser General Public License as published 
// by the Free Software Foundation, either version 3 of the License, or     
// (at your option) any later version.                                      
//                                                                          
// This source file is distributed in the hope that it will be useful,      
// but WITHOUT ANY WARRANTY; without even the implied warranty of           
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
// GNU General Public License for more details.                             
//                                                                          
// You should have received a copy of the GNU General Public License        
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
//
//		Arbitrates access to the system bus among up to eight
//	wave table channels for the PSG. This arbitrator is part
//	of a tree that ends up looking like a single arbitration
//	request to the system.
//
//	Spartan3
//	19 LUTs / 11 slices
//=============================================================================

module PSGBusArb(rst, clk, ce, ack,
	req0, req1, req2, req3, req4, req5, req6, req7,
	sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7, seln);
input rst;		// reset
input clk;		// clock (eg 100MHz)
input ce;		// clock enable (eg 25MHz)
input ack;		// bus transfer completed
input req0;		// requester 0 wants the bus
input req1;		// requester 1 wants the bus
input req2;		// ...
input req3;
input req4;
input req5;
input req6;
input req7;
output sel0;	// requester 0 granted the bus
reg sel0;
output sel1;
reg sel1;
output sel2;
reg sel2;
output sel3;
reg sel3;
output sel4;
reg sel4;
output sel5;
reg sel5;
output sel6;
reg sel6;
output sel7;
reg sel7;
output [2:0] seln;	// who has the bus
reg [2:0] seln;

always @(posedge clk) begin
	if (rst) begin
		sel0 <= 1'b0;
		sel1 <= 1'b0;
		sel2 <= 1'b0;
		sel3 <= 1'b0;
		sel4 <= 1'b0;
		sel5 <= 1'b0;
		sel6 <= 1'b0;
		sel7 <= 1'b0;
		seln <= 3'd0;
	end
	else begin
		if (ce&ack) begin
			if (req0) begin
				sel0 <= 1'b1;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd0;
			end
			else if (req1) begin
				sel1 <= 1'b1;
				sel0 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd1;
			end
			else if (req2) begin
				sel2 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd2;
			end
			else if (req3) begin
				sel3 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd3;
			end
			else if (req4) begin
				sel4 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd4;
			end
			else if (req5) begin
				sel5 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd5;
			end
			else if (req6) begin
				sel6 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd6;
			end
			else if (req7) begin
				sel7 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				seln <= 3'd7;
			end
			// otherwise, hold onto last owner
			else begin
				sel0 <= sel0;
				sel1 <= sel1;
				sel2 <= sel2;
				sel3 <= sel3;
				sel4 <= sel4;
				sel5 <= sel5;
				sel6 <= sel6;
				sel7 <= sel7;
				seln <= seln;
			end
		end
	end
end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req0 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req0""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""req0"": ""bus request signal for requester 0""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus request signal for requester 0 is equal to 1, then selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req1 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req1""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""req1"": ""bus request signal for requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus request signal for requester 1 is equal to 1, then selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 1 & ack == 0) |=> (sel7 == 1)"",
    ""Signals"": [""sel7"", ""ack""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 1 and bus transfer completed signal is equal to 0, then selection signal for requester 7 is equal to 1 from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 1 & ce == 0) |=> (sel7 == 1)"",
    ""Signals"": [""sel7"", ""ce""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 1 and clock enable signal is equal to 0, then selection signal for requester 7 is equal to 1 from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & ack == 0) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""ack""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus transfer completed signal is equal to 0, then selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req2 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req2""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""req2"": ""bus request signal for requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus request signal for requester 2 is equal to 1, then selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req3 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req3""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""req3"": ""bus request signal for requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus request signal for requester 3 is equal to 1, then selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req5 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req5""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""req5"": ""bus request signal for requester 5""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus request signal for requester 5 is equal to 1, then in the next clock cycle selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel7 == 0 & req6 == 1) |=> (sel7 == 0)"",
    ""Signals"": [""sel7"", ""req6""],
    ""Signal Explanations"": {
      ""sel7"": ""selection signal for requester 7"",
      ""req6"": ""bus request signal for requester 6""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 7 is equal to 0 and bus request signal for requester 6 is equal to 1, then selection signal for requester 7 is equal to 0 from the next clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req0 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req0""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""req0"": ""bus request signal for requester 0""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus request signal for requester 0 is equal to 1, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req1 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req1""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""req1"": ""bus request signal for requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus request signal for requester 1 is equal to 1, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 1 & ce == 0) |=> (sel5 == 1)"",
    ""Signals"": [""sel5"", ""ce""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 1 and clock enable signal is equal to 0, then selection signal for requester 5 is equal to 1 from the next clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 1 & ack == 0) |=> (sel5 == 1)"",
    ""Signals"": [""sel5"", ""ack""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 1 and bus transfer completed signal is equal to 0, then selection signal for requester 5 is equal to 1 from the next clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & ack == 0) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""ack""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus transfer completed signal is equal to 0, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & ce == 0) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""ce""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and clock enable signal is equal to 0, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req2 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req2""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""req2"": ""bus request signal for requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus request signal for requester 2 is equal to 1, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 17"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req3 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req3""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""req3"": ""bus request signal for requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus request signal for requester 3 is equal to 1, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 18"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req4 == 1) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req4""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""req4"": ""bus request signal for requester 4""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus request signal for requester 4 is equal to 1, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 19"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel5 == 0 & req5 == 0) |=> (sel5 == 0)"",
    ""Signals"": [""sel5"", ""req5""],
    ""Signal Explanations"": {
      ""sel5"": ""selection signal for requester 5"",
      ""req5"": ""bus request signal for requester 5""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 5 is equal to 0 and bus request signal for requester 5 is equal to 0, then selection signal for requester 5 is equal to 0 from the next clock cycle""
  },
  ""Assertion 20"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req1 == 1) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req1""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""req1"": ""bus request signal for requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 0 and bus request signal for requester 1 is equal to 1, then selection signal for requester 4 is equal to 0 from the next clock cycle""
  },
  ""Assertion 21"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 1 & ack == 0) |=> (sel4 == 1)"",
    ""Signals"": [""sel4"", ""ack""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 1 and bus transfer completed signal is equal to 0, then selection signal for requester 4 is equal to 1 from the next clock cycle""
  },
  ""Assertion 22"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & ack == 0) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""ack""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""ack"": ""bus transfer completed signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 0 and bus transfer completed signal is equal to 0, then selection signal for requester 4 is equal to 0 from the next clock cycle""
  },
  ""Assertion 23"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & ce == 0) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""ce""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 0 and clock enable signal is equal to 0, then selection signal for requester 4 is equal to 0 from the next clock cycle""
  },
  ""Assertion 24"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 1 & ce == 0) |=> (sel4 == 1)"",
    ""Signals"": [""sel4"", ""ce""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""ce"": ""clock enable signal""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 1 and clock enable signal is equal to 0, then selection signal for requester 4 is equal to 1 from the next clock cycle""
  },
  ""Assertion 25"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req2 == 1) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req2""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""req2"": ""bus request signal for requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 0 and bus request signal for requester 2 is equal to 1, then signal for requester 4 is equal to 0 from the next clock cycle""
  },
  ""Assertion 26"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req3 == 1) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req3""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""req3"": ""bus request signal for requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 0 and bus request signal for requester 3 is equal to 1, then selection signal for requester 4 is equal to 0 from the next clock cycle""
  },
  ""Assertion 27"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sel4 == 0 & req4 == 0) |=> (sel4 == 0)"",
    ""Signals"": [""sel4"", ""req4""],
    ""Signal Explanations"": {
      ""sel4"": ""selection signal for requester 4"",
      ""req4"": ""bus request signal for requester 4""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical AND"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when selection signal for requester 4 is equal to 0 and bus request signal for requester 4 is equal to 0, then selection signal for requester 4 is equal to 0 from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((sel7 == 0 && req0 == 1) |=> sel7 == 0) @(posedge clk);"",
""Assertion 2"": ""assert property ((sel7 == 1'b0 && req1 == 1'b1) |=> (sel7 == 1'b0));"",
""Assertion 3"": ""assert property ((sel7 == 1 && ack == 0) |-> ##1 (sel7 == 1));"",
""Assertion 4"": ""assert property ((sel7 == 1 && ce == 0) |=> (sel7 == 1));"",
""Assertion 5"": ""assert property ((sel7 == 1'b0 && ack == 1'b0) |-> ##1 (sel7 == 1'b0));"",
""Assertion 6"": ""assert property ((sel7 == 0 && req2 == 1) |-> (sel7 == 0)) @(posedge clk);"",
""Assertion 7"": ""assert property ((sel7 == 1’b0 && req3 == 1’b1) |-> ##1 (sel7 == 1’b0));"",
""Assertion 8"": ""assert property ((sel7 == 1'b0 && req5 == 1'b1) |=> (sel7 == 1'b0));"",
""Assertion 9"": ""assert property (@(posedge clk)                     ( (sel7 == 1'b0 && req6 == 1'b1)                       |=>                       (sel7 == 1'b0)                     )                  );"",
""Assertion 10"": ""assert property ((sel5 == 1'b0 && req0 == 1'b1) |=> (sel5 == 1'b0)) @(posedge clk);"",
""Assertion 11"": ""assert property ((sel5 == 0 && req1 == 1) |=> (sel5 == 0)) @(posedge clk);"",
""Assertion 12"": ""assert property ((sel5 == 1'b1 && ce == 1'b0) |-> ##1 (sel5 == 1'b1));"",
""Assertion 13"": ""assert property ( ((sel5 == 1) && (ack == 0)) |-> (sel5 == 1) );"",
""Assertion 14"": ""assert property ((sel5 == 1'b0 && ack == 1'b0) |-> (sel5 == 1'b0));"",
""Assertion 15"": ""assert property ((sel5 == 1'b0 && ce == 1'b0) |-> ##1 (sel5 == 1'b0));"",
""Assertion 16"": ""assert property ((sel5 == 1'b0 && req2 == 1'b1) |=> (sel5 == 1'b0));"",
""Assertion 17"": ""assert property ((sel5 == 1'b0 && req3 == 1'b1) |-> ##1 (sel5 == 1'b0));"",
""Assertion 18"": ""assert property ((sel5 == 1’b0 && req4 == 1’b1) |=> (sel5 == 1’b0)) @(posedge clk);"",
""Assertion 19"": ""assert property ((sel5 == 1’b0 && req5 == 1’b0) |=> (sel5 == 1’b0));"",
""Assertion 20"": ""assert property ((sel4 == 1'b0 && req1 == 1'b1) |=> (sel4 == 1'b0));"",
""Assertion 21"": ""assert property ((sel4 == 1 && ack == 0) |-> ##1 (sel4 == 1));"",
""Assertion 22"": ""assert property ((sel4 == 1ʼb0 && ack == 1ʼb0) |=> (sel4 == 1ʼb0));"",
""Assertion 23"": ""assert property ((sel4 == 1'b0 && ce == 1'b0) |=> (sel4 == 1'b0));"",
""Assertion 24"": ""assert property ((sel4 == 1 && ce == 0) |-> ##1 (sel4 == 1));"",
""Assertion 25"": ""assert property ((sel4 == 1’b0 && req2 == 1’b1) |=> (sel4 == 1’b0));"",
""Assertion 26"": ""assert property ((sel4 == 1'b0 && req3 == 1'b1) |-> ##1 (sel4 == 1'b0));"",
""Assertion 27"": ""assert property ((!sel4 && !req4) |-> ##1 (!sel4));""
}"
apb,"//////////////////////////////////////////////////////////////////
////
////
//// 	APB module to I2C Core
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// apbi2c_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Ronal Dario Celaya
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////

`timescale 1ns/1ps //timescale 

module apb(
			//standard ARM
	    		input PCLK,
			input PRESETn,
			input PSELx,
			input PWRITE,
			input PENABLE,
			input [31:0] PADDR,
			input [31:0] PWDATA,

			//internal pin
			input [31:0] READ_DATA_ON_RX,
			input ERROR,
			input TX_EMPTY,
			input RX_EMPTY,
			
			//external pin
			output [31:0] PRDATA,

			//internal pin 
			output reg [13:0] INTERNAL_I2C_REGISTER_CONFIG,
			output reg [13:0] INTERNAL_I2C_REGISTER_TIMEOUT,
			output [31:0] WRITE_DATA_ON_TX,
			output  WR_ENA,
			output  RD_ENA,
			
			//outside port 
			output PREADY,
			output PSLVERR,

			//interruption
			output INT_RX,
			output INT_TX
	   

	  );

//ENABLE WRITE ON TX FIFO
assign WR_ENA = (PWRITE == 1'b1 & PENABLE == 1'b1 & PADDR == 32'd0 & PSELx == 1'b1)?  1'b1:1'b0;

//ENABLE READ ON RX FIFO
assign RD_ENA = (PWRITE == 1'b0 & PENABLE == 1'b1  & PADDR == 32'd4 & PSELx == 1'b1)?  1'b1:1'b0;

//WRITE ON I2C MODULE
assign PREADY = ((WR_ENA == 1'b1 | RD_ENA == 1'b1 | PADDR == 32'd8 | PADDR == 32'd12) &  (PENABLE == 1'b1 & PSELx == 1'b1))? 1'b1:1'b0;

//INPUT TO WRITE ON TX FIFO
assign WRITE_DATA_ON_TX = (PADDR == 32'd0)? PWDATA:PWDATA;

//OUTPUT DATA FROM RX TO PRDATA
assign PRDATA = (PADDR == 32'd4)? READ_DATA_ON_RX:READ_DATA_ON_RX;

//ERROR FROM I2C CORE
assign PSLVERR = ERROR; 

//INTERRUPTION FROM I2C
assign INT_TX = TX_EMPTY;

//INTERRUPTION FROM I2C
assign INT_RX = RX_EMPTY;

//This is sequential logic used only to register configuration
always@(posedge PCLK)
begin

	if(!PRESETn)
	begin
		INTERNAL_I2C_REGISTER_CONFIG <= 14'd0;
		INTERNAL_I2C_REGISTER_TIMEOUT <= 14'd0;
	end
	else
	begin

		// Set configuration to i2c
		if(PADDR == 32'd8 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1)
		begin
			INTERNAL_I2C_REGISTER_CONFIG <= PWDATA[13:0];
		end
		else if(PADDR == 32'd12 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1)
		begin
			INTERNAL_I2C_REGISTER_TIMEOUT <= PWDATA[13:0];
		end
		else
		begin
			INTERNAL_I2C_REGISTER_CONFIG <= INTERNAL_I2C_REGISTER_CONFIG;
		end
		
	end

end 


endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(ERROR == 0) |-> (PSLVERR == 0)"",
    ""Signals"": [
      ""ERROR"",
      ""PSLVERR""
    ],
    ""Signal Explanations"": {
      ""ERROR"": ""error indicator from the I2C core"",
      ""PSLVERR"": ""error signal output to the APB interface""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""When error indicator from the I2C core equals 0, then error signal output to the APB interface equals 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(ERROR == 1) |-> (PSLVERR == 1)"",
    ""Signals"": [
      ""ERROR"",
      ""PSLVERR""
    ],
    ""Signal Explanations"": {
      ""ERROR"": ""error indicator from the I2C core"",
      ""PSLVERR"": ""error signal output to the APB interface""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""When error indicator from the I2C core equals 1, then error signal output to the APB interface equals 1 from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(TX_EMPTY == 1) |-> (INT_TX == 1)"",
    ""Signals"": [
      ""TX_EMPTY"",
      ""INT_TX""
    ],
    ""Signal Explanations"": {
      ""TX_EMPTY"": ""transmit FIFO empty indicator"",
      ""INT_TX"": ""transmit interrupt signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""When transmit FIFO empty indicator equals 1, then transmit interrupt signal equals 1 from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(TX_EMPTY == 0) |-> (INT_TX == 0)"",
    ""Signals"": [
      ""TX_EMPTY"",
      ""INT_TX""
    ],
    ""Signal Explanations"": {
      ""TX_EMPTY"": ""transmit FIFO empty indicator"",
      ""INT_TX"": ""transmit interrupt signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""When transmit FIFO empty indicator equals 0, then transmit interrupt signal equals 0 from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(RX_EMPTY == 0) |-> (INT_RX == 0)"",
    ""Signals"": [
      ""RX_EMPTY"",
      ""INT_RX""
    ],
    ""Signal Explanations"": {
      ""RX_EMPTY"": ""receive FIFO empty indicator"",
      ""INT_RX"": ""receive interrupt signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""When receive FIFO empty indicator equals 0, then receive interrupt signal equals 0 from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(RX_EMPTY == 1) |-> (INT_RX == 1)"",
    ""Signals"": [
      ""RX_EMPTY"",
      ""INT_RX""
    ],
    ""Signal Explanations"": {
      ""RX_EMPTY"": ""receive FIFO empty indicator"",
      ""INT_RX"": ""receive interrupt signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""When receive FIFO empty indicator equals 1, then receive interrupt signal equals 1 from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((ERROR == 1'b0) |-> (PSLVERR == 1'b0));"",
""Assertion 2"": ""assert property ((ERROR == 1) |-> (PSLVERR == 1));"",
""Assertion 3"": ""assert property (TX_EMPTY == 1 |-> INT_TX == 1) @(posedge PCLK);"",
""Assertion 4"": ""assert property (TX_EMPTY == 0 |-> INT_TX == 0) @(posedge PCLK);"",
""Assertion 5"": ""assert property (!RX_EMPTY |-> !INT_RX) @(posedge PCLK);"",
""Assertion 6"": ""assert property (RX_EMPTY == 1 |-> INT_RX == 1);""
}"
host_interface,"//////////////////////////////////////////////////////////////////
////
////
//// 	CRCAHB CORE BLOCK
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// crcahb IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): -  Julio Cesar 
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////
module host_interface
(
	//OUTPUTS
	output [31:0] HRDATA,
	output HREADYOUT,
	output HRESP,
	output [31:0] bus_wr,
	output [ 1:0] crc_poly_size,
	output [ 1:0] bus_size,
	output [ 1:0] rev_in_type,
	output rev_out_type,
	output crc_init_en,
	output crc_idr_en,
	output crc_poly_en,
	output buffer_write_en,
	output reset_chain,
	//INPUTS
	input [31:0] HWDATA,
	input [31:0] HADDR,
	input [ 2:0] HSIZE,
	input [ 1:0] HTRANS,
	input HWRITE,
	input HSElx,
	input HREADY,
	input HRESETn,
	input HCLK,
	input [31:0] crc_poly_out,
	input [31:0] crc_out,
	input [31:0] crc_init_out,
	input [ 7:0] crc_idr_out,
	input buffer_full,
	input reset_pending,
	input read_wait
);

//Reset Values
localparam RESET_CRC_CR = 6'h00;

//CRC Register Map
localparam CRC_DR   = 3'h0;
localparam CRC_IDR  = 3'h1;
localparam CRC_CR   = 3'h2;
localparam CRC_INIT = 3'h4;
localparam CRC_POL  = 3'h5;

//Transfer Type Encoding
localparam IDLE    = 2'b00;
localparam BUSY    = 2'b01;
localparam NON_SEQ = 2'b10;
localparam SEQ     = 2'b11;

//HRESP Encoding
localparam OK    = 1'b0;
localparam ERROR = 1'b1;

//Pipeline flops
reg [2:0] haddr_pp;
reg [2:0] hsize_pp;
reg [1:0] htrans_pp;
reg hwrite_pp;
reg hselx_pp;

//Flops
reg [4:0] crc_cr_ff;

//Internal Signals
wire [31:0] crc_cr_rd;
wire crc_dr_sel;
wire crc_init_sel;
wire crc_idr_sel;
wire crc_poly_sel;
wire crc_cr_sel;
wire ahb_enable;
wire write_en;
wire read_en;
wire crc_cr_en;
wire sample_bus;
wire buffer_read_en;

//Pipeline Registers for Address Phase of AHB Protocol
always @(posedge HCLK)
	begin
		if(!HRESETn)
			begin
				hselx_pp <= 1'b0;
			end
		else
			if(sample_bus)
				begin
					haddr_pp  <= HADDR[4:2];
					hsize_pp  <= HSIZE;
					htrans_pp <= HTRANS;
					hwrite_pp <= HWRITE;
					hselx_pp  <= HSElx;
				end
	end

//Enable Signals
assign ahb_enable = (htrans_pp == NON_SEQ);
assign write_en = hselx_pp &&  hwrite_pp && ahb_enable;
assign read_en  = hselx_pp && !hwrite_pp && ahb_enable;

//Registers decoding
assign crc_dr_sel   = (haddr_pp == CRC_DR  );
assign crc_init_sel = (haddr_pp == CRC_INIT);
assign crc_idr_sel  = (haddr_pp == CRC_IDR );
assign crc_poly_sel = (haddr_pp == CRC_POL );
assign crc_cr_sel   = (haddr_pp == CRC_CR  );

//Write Esnables Signals for Registers
assign buffer_write_en = crc_dr_sel   && write_en;
assign crc_init_en     = crc_init_sel && write_en;
assign crc_idr_en      = crc_idr_sel  && write_en;
assign crc_poly_en     = crc_poly_sel && write_en;
assign crc_cr_en       = crc_cr_sel   && write_en;

//Indicates reading operation request to crc_dr register
assign buffer_read_en = crc_dr_sel && read_en;

//Bus Size is the output of HSIZE pipeline register
assign bus_size = hsize_pp;

//The Write Bus is not pipelined
assign bus_wr = HWDATA;

//HREADY Signal outputed to Master
assign HREADYOUT = !((buffer_write_en && buffer_full   ) ||
                     (buffer_read_en  && read_wait     ) ||
                     (crc_init_en     && reset_pending ) );

//Signal to control sampling of bus
assign sample_bus = HREADYOUT && HREADY;

//HRESP Signal outputed to Master
//This implementation never signalize bus error to master
assign HRESP = OK;

//CRC_CR Data Read
assign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0};

//Mux to HRDATA
assign HRDATA = ({32{crc_dr_sel  }} & crc_out             ) |
                ({32{crc_init_sel}} & crc_init_out        ) |
                ({32{crc_idr_sel }} & {24'h0, crc_idr_out}) |
                ({32{crc_poly_sel}} & crc_poly_out        ) |
                ({32{crc_cr_sel  }} & crc_cr_rd           ) ;

//Control Register
always @(posedge HCLK)
	begin
		if(!HRESETn)
			crc_cr_ff <= RESET_CRC_CR;
		else
			if(crc_cr_en)
				crc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]};
	end

//Configuration Signals
assign reset_chain   = (crc_cr_en && HWDATA[0]);
assign crc_poly_size = crc_cr_ff[1:0];
assign rev_in_type   = crc_cr_ff[3:2];
assign rev_out_type  = crc_cr_ff[4];

endmodule","{
""leaf_sv_files"": [],
""Assertion 1"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(sample_bus == 1) |-> (HREADYOUT == 1)"",
  ""Signals"": [""sample_bus"", ""HREADYOUT""],
  ""Signal Explanations"": {
    ""sample_bus"": ""signal to control sampling of bus"",
    ""HREADYOUT"": ""HREADY signal outputed to Master""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when signal to control sampling of bus equals 1, then HREADY signal outputed to Master equals 1 from the current clock cycle""
},
""Assertion 2"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(buffer_read_en == 1 & read_wait == 1) |-> (HREADYOUT == 0)"",
  ""Signals"": [""buffer_read_en"", ""read_wait"", ""HREADYOUT""],
  ""Signal Explanations"": {
    ""buffer_read_en"": ""indicates reading operation request to CRC_DR register"",
    ""read_wait"": ""input signal indicating if a read operation should wait"",
    ""HREADYOUT"": ""HREADY signal outputed to Master""
  },
  ""Logical Operators"": [""=="", ""&"", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""&"": ""logical and"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when reading operation request to CRC_DR register equals 1 and read_wait equals 1, then HREADY signal outputed to Master equals 0 from the current clock cycle""
},
""Assertion 3"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(ahb_enable == 0) |-> (HREADYOUT == 1)"",
  ""Signals"": [""ahb_enable"", ""HREADYOUT""],
  ""Signal Explanations"": {
    ""ahb_enable"": ""signal indicating AHB enable (active when htrans_pp equals NON_SEQ)"",
    ""HREADYOUT"": ""HREADY signal outputed to Master""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when AHB enable signal equals 0, then HREADY signal outputed to Master equals 1 from the current clock cycle""
},
""Assertion 4"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(write_en == 0) |-> (crc_idr_en == 0)"",
  ""Signals"": [""write_en"", ""crc_idr_en""],
  ""Signal Explanations"": {
    ""write_en"": ""write enable signal (derived from hselx_pp, hwrite_pp and ahb_enable)"",
    ""crc_idr_en"": ""write enable signal for CRC_IDR register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when write enable signal equals 0, then write enable for CRC_IDR register equals 0 from the current clock cycle""
},
""Assertion 5"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(write_en == 1 & crc_idr_sel == 1) |-> (crc_idr_en == 1)"",
  ""Signals"": [""write_en"", ""crc_idr_sel"", ""crc_idr_en""],
  ""Signal Explanations"": {
    ""write_en"": ""write enable signal (derived from hselx_pp, hwrite_pp and ahb_enable)"",
    ""crc_idr_sel"": ""signal indicating selection (decoding) for CRC_IDR register"",
    ""crc_idr_en"": ""write enable signal for CRC_IDR register""
  },
  ""Logical Operators"": [""=="", ""&"", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""&"": ""logical and"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when write enable signal equals 1 and CRC_IDR selection equals 1, then write enable for CRC_IDR register equals 1 from the current clock cycle""
},
""Assertion 6"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(crc_idr_sel == 0) |-> (crc_idr_en == 0)"",
  ""Signals"": [""crc_idr_sel"", ""crc_idr_en""],
  ""Signal Explanations"": {
    ""crc_idr_sel"": ""signal indicating selection (decoding) for CRC_IDR register"",
    ""crc_idr_en"": ""write enable signal for CRC_IDR register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when CRC_IDR selection equals 0, then write enable for CRC_IDR register equals 0 from the current clock cycle""
},
""Assertion 7"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(hselx_pp == 0) |-> (crc_idr_en == 0)"",
  ""Signals"": [""hselx_pp"", ""crc_idr_en""],
  ""Signal Explanations"": {
    ""hselx_pp"": ""pipeline register capturing the HSElx input signal"",
    ""crc_idr_en"": ""write enable signal for CRC_IDR register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when pipeline HSElx signal equals 0, then write enable for CRC_IDR register equals 0 from the current clock cycle""
},
""Assertion 8"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(hwrite_pp == 0) |-> (crc_idr_en == 0)"",
  ""Signals"": [""hwrite_pp"", ""crc_idr_en""],
  ""Signal Explanations"": {
    ""hwrite_pp"": ""pipeline register capturing the HWRITE input signal"",
    ""crc_idr_en"": ""write enable signal for CRC_IDR register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when pipeline HWRITE signal equals 0, then write enable for CRC_IDR register equals 0 from the current clock cycle""
},
""Assertion 9"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(write_en == 0) |-> (crc_poly_en == 0)"",
  ""Signals"": [""write_en"", ""crc_poly_en""],
  ""Signal Explanations"": {
    ""write_en"": ""write enable signal (derived from hselx_pp, hwrite_pp and ahb_enable)"",
    ""crc_poly_en"": ""write enable signal for CRC_POL register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when write enable signal equals 0, then write enable for CRC_POL register equals 0 from the current clock cycle""
},
""Assertion 10"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(hselx_pp == 0) |-> (crc_poly_en == 0)"",
  ""Signals"": [""hselx_pp"", ""crc_poly_en""],
  ""Signal Explanations"": {
    ""hselx_pp"": ""pipeline register capturing the HSElx input signal"",
    ""crc_poly_en"": ""write enable signal for CRC_POL register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when pipeline HSElx signal equals 0, then write enable for CRC_POL register equals 0 from the current clock cycle""
},
""Assertion 11"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(hwrite_pp == 0) |-> (crc_poly_en == 0)"",
  ""Signals"": [""hwrite_pp"", ""crc_poly_en""],
  ""Signal Explanations"": {
    ""hwrite_pp"": ""pipeline register capturing the HWRITE input signal"",
    ""crc_poly_en"": ""write enable signal for CRC_POL register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when pipeline HWRITE signal equals 0, then write enable for CRC_POL register equals 0 from the current clock cycle""
},
""Assertion 12"": {
  ""clock signal condition"": ""@(posedge HCLK)"",
  ""disable condition"": """",
  ""logical expression"": ""(haddr_pp[1] == 1) |-> (crc_poly_en == 0)"",
  ""Signals"": [""haddr_pp[1]"", ""crc_poly_en""],
  ""Signal Explanations"": {
    ""haddr_pp[1]"": ""bit 1 of the pipeline register capturing the HADDR input signal"",
    ""crc_poly_en"": ""write enable signal for CRC_POL register""
  },
  ""Logical Operators"": [""=="", ""|->"", ""==""],
  ""Logical Operators Explanation"": {
    ""=="": ""equal"",
    ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
  },
  ""Assertion Explaination"": ""when the second bit of the pipeline HADDR signal equals 1, then write enable for CRC_POL register equals 0 from the current clock cycle""
}
}","{
""Assertion 1"": ""assert property ((sample_bus == 1'b1) |-> (HREADYOUT == 1'b1));"",
""Assertion 2"": ""assert property ((buffer_read_en && read_wait) |-> (HREADYOUT == 1'b0));"",
""Assertion 3"": ""assert property (!htrans_pp |-> HREADYOUT);"",
""Assertion 4"": ""assert property (!write_en |-> !crc_idr_en);"",
""Assertion 5"": ""assert property ((write_en == 1'b1 && crc_idr_sel == 1'b1) |-> (crc_idr_en == 1'b1));"",
""Assertion 6"": ""assert property ((crc_idr_sel == 1'b0) |-> (crc_idr_en == 1'b0));"",
""Assertion 7"": ""assert property ((hselx_pp == 1'b0) |-> (crc_idr_en == 1'b0));"",
""Assertion 8"": ""assert property (hwrite_pp == 1'b0 |-> crc_idr_en == 1'b0);"",
""Assertion 9"": ""assert property ((write_en == 1'b0) |-> (crc_poly_en == 1'b0)) @(posedge HCLK);"",
""Assertion 10"": ""assert property (hselx_pp == 1'b0 |-> crc_poly_en == 1'b0);"",
""Assertion 11"": ""assert property (hwrite_pp == 1'b0 |-> crc_poly_en == 1'b0);"",
""Assertion 12"": ""assert property (haddr_pp[1] == 1'b1 |-> crc_poly_en == 1'b0);""
}"
control_unit,"//////////////////////////////////////////////////////////////////
////
////
//// 	AES CORE BLOCK
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// aes128_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Julio Cesar 
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////
module control_unit
(
	output reg [ 2:0] sbox_sel,
	output reg [ 1:0] rk_sel,
	output reg [ 1:0] key_out_sel,
	output reg [ 1:0] col_sel,
	output reg [ 3:0] key_en,
	output reg [ 3:0] col_en,
	output     [ 3:0] round,
	output reg bypass_rk,
	output reg bypass_key_en,
	output reg key_sel,
	output reg iv_cnt_en,
	output reg iv_cnt_sel,
	output reg key_derivation_en,
	output end_comp,
	output key_init,
	output key_gen,
	output mode_ctr,
	output mode_cbc,
	output last_round,
  output encrypt_decrypt,	
	input [1:0] operation_mode,
	input [1:0] aes_mode,
	input start,
	input disable_core,
	input clk,
	input rst_n
);
//`include ""include/host_interface.vh""
//`include ""include/control_unit_params.vh""

//=====================================================================================
// Memory Mapped Registers Address
//=====================================================================================
localparam AES_CR    = 4'd00;
localparam AES_SR    = 4'd01;
localparam AES_DINR  = 4'd02;
localparam AES_DOUTR = 4'd03;
localparam AES_KEYR0 = 4'd04;
localparam AES_KEYR1 = 4'd05;
localparam AES_KEYR2 = 4'd06;
localparam AES_KEYR3 = 4'd07;
localparam AES_IVR0  = 4'd08;
localparam AES_IVR1  = 4'd09;
localparam AES_IVR2  = 4'd10;
localparam AES_IVR3  = 4'd11;

//=============================================================================
// Operation Modes
//=============================================================================
localparam ENCRYPTION     = 2'b00;
localparam KEY_DERIVATION = 2'b01;
localparam DECRYPTION     = 2'b10;
localparam DECRYP_W_DERIV = 2'b11;

//=============================================================================
// AES Modes
//=============================================================================
localparam ECB = 2'b00;
localparam CBC = 2'b01;
localparam CTR = 2'b10;

//=============================================================================
// SBOX SEL
//=============================================================================
localparam COL_0 = 3'b000;
localparam COL_1 = 3'b001;
localparam COL_2 = 3'b010;
localparam COL_3 = 3'b011;
localparam G_FUNCTION = 3'b100;

//=============================================================================
// RK_SEL
//=============================================================================
localparam COL        = 2'b00;
localparam MIXCOL_IN  = 2'b01;
localparam MIXCOL_OUT = 2'b10;

//=============================================================================
// KEY_OUT_SEL
//=============================================================================
localparam KEY_0 = 2'b00;
localparam KEY_1 = 2'b01;
localparam KEY_2 = 2'b10;
localparam KEY_3 = 2'b11;

//=============================================================================
// COL_SEL
//=============================================================================
localparam SHIFT_ROWS = 2'b00;
localparam ADD_RK_OUT = 2'b01;
localparam INPUT      = 2'b10;

//=============================================================================
// KEY_SEL
//=============================================================================
localparam KEY_HOST = 1'b0;
localparam KEY_OUT  = 1'b1;

//=============================================================================
// KEY_EN
//=============================================================================
localparam KEY_DIS  = 4'b0000;
localparam EN_KEY_0 = 4'b0001;
localparam EN_KEY_1 = 4'b0010;
localparam EN_KEY_2 = 4'b0100;
localparam EN_KEY_3 = 4'b1000;
localparam KEY_ALL  = 4'b1111;

//=============================================================================
// COL_EN
//=============================================================================
localparam COL_DIS  = 4'b0000;
localparam EN_COL_0 = 4'b0001;
localparam EN_COL_1 = 4'b0010;
localparam EN_COL_2 = 4'b0100;
localparam EN_COL_3 = 4'b1000;
localparam COL_ALL  = 4'b1111;

//=============================================================================
// IV_CNT_SEL
//=============================================================================
localparam IV_CNT = 1'b1;
localparam IV_BUS = 1'b0;

//=============================================================================
// ENABLES
//=============================================================================
localparam ENABLE = 1'b1;
localparam DISABLE = 1'b0;

localparam NUMBER_ROUND      = 4'd10;
localparam NUMBER_ROUND_INC  = 4'd11;
localparam INITIAL_ROUND     = 4'd00;

//=============================================================================
// FSM STATES
//=============================================================================
localparam IDLE        = 4'd00;
localparam ROUND0_COL0 = 4'd01;
localparam ROUND0_COL1 = 4'd02;
localparam ROUND0_COL2 = 4'd03;
localparam ROUND0_COL3 = 4'd04;
localparam ROUND_KEY0  = 4'd05;
localparam ROUND_COL0  = 4'd06;
localparam ROUND_COL1  = 4'd07;
localparam ROUND_COL2  = 4'd08;
localparam ROUND_COL3  = 4'd09;
localparam READY       = 4'd10;
localparam GEN_KEY0    = 4'd11;
localparam GEN_KEY1    = 4'd12;
localparam GEN_KEY2    = 4'd13;
localparam GEN_KEY3    = 4'd14;
localparam NOP         = 4'd15;

reg [3:0] state, next_state;
reg [3:0] rd_count;

reg rd_count_en;
//reg end_aes_pp1, end_aes_pp2;
wire op_key_derivation;
wire first_round;
wire [1:0] op_mode;
wire enc_dec;

// State Flops Definition
always @(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			state <= IDLE;
		else
			if(disable_core)
				state <= IDLE;
			else
				state <= next_state;
	end

assign encrypt_decrypt = (op_mode == ENCRYPTION || op_mode == KEY_DERIVATION || state == GEN_KEY0   
			  ||   state == GEN_KEY1       ||state == GEN_KEY2   ||   state == GEN_KEY3       );

assign enc_dec = encrypt_decrypt | mode_ctr;
assign key_gen = (state == ROUND_KEY0);

assign op_key_derivation = (op_mode == KEY_DERIVATION);

assign mode_ctr = (aes_mode == CTR);
assign mode_cbc = (aes_mode == CBC);

assign key_init = start;

assign op_mode = (mode_ctr) ? ENCRYPTION : operation_mode;

// Next State Logic
always @(*)
	begin
		next_state = state;
		case(state)
			IDLE:
				begin
					if(!start)
						next_state = IDLE;
					else
						case(op_mode)
							ENCRYPTION    : next_state = ROUND0_COL0;
							DECRYPTION    : next_state = ROUND0_COL3;
							KEY_DERIVATION: next_state = GEN_KEY0;
							DECRYP_W_DERIV: next_state = GEN_KEY0;
							default       : next_state = IDLE;
						endcase
				end
			ROUND0_COL0:
				begin
					next_state = (enc_dec) ? ROUND0_COL1 : ROUND_KEY0; 
				end
			ROUND0_COL1:
				begin
					next_state = (enc_dec) ? ROUND0_COL2 : ROUND0_COL0;
				end
			ROUND0_COL2:
				begin
					next_state = (enc_dec) ? ROUND0_COL3 : ROUND0_COL1;
				end
			ROUND0_COL3:
				begin
					next_state = (enc_dec) ? ROUND_KEY0 : ROUND0_COL2;
				end
			ROUND_KEY0 :
				begin
					if(!first_round)
						begin
							next_state = (last_round) ? READY : NOP;
						end
					else
						begin
							next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;
						end
				end
			NOP        :
				begin
					next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;
				end
			ROUND_COL0 :
				begin
					next_state = (enc_dec) ? ROUND_COL1 : ROUND_KEY0;
				end
			ROUND_COL1 :
				begin
					next_state = (enc_dec) ? ROUND_COL2 : ROUND_COL0;
				end
			ROUND_COL2 :
				begin
					next_state = (enc_dec) ? ROUND_COL3 : ROUND_COL1;
				end
			ROUND_COL3 :
				begin
					if(last_round && enc_dec)
						next_state = READY;
					else
					next_state = (enc_dec) ? ROUND_KEY0 : ROUND_COL2;
				end
			GEN_KEY0   :
				begin
					next_state = GEN_KEY1;
				end
			GEN_KEY1   :
				begin
					next_state = GEN_KEY2;
				end
			GEN_KEY2   :
				begin
					next_state = GEN_KEY3;
				end
			GEN_KEY3   :
				begin
					if(last_round)
						next_state = (op_key_derivation) ? READY : ROUND0_COL3;
					else
						next_state = GEN_KEY0;
				end
			READY      :
				begin
					next_state = IDLE;
				end
		endcase
	end
 
       
// Output Logic
assign end_comp = (state == READY)?ENABLE:DISABLE;

/*
always @(posedge clk, negedge rst_n)
begin
		if(!rst_n)
		begin
			end_aes_pp1 <= 1'b0;
			end_aes_pp2 <= 1'b0; 
			end_comp <= 1'b0;
		end
		else
			if(state == READY)
			begin
				end_aes_pp1 <= ENABLE;
				//end_aes_pp2 <= end_aes_pp1;
				end_comp <= end_aes_pp1 ;
			end
			else
			begin
				end_aes_pp1 <= DISABLE;
				//end_aes_pp2 <= end_aes_pp1;
				end_comp <= end_aes_pp1 ;
			end

end
*/
always @(*)
	begin
		sbox_sel = COL_0;
		rk_sel = COL;
		bypass_rk = DISABLE;
		key_out_sel = KEY_0;
		col_sel = INPUT;
		key_sel = KEY_HOST;
		key_en = KEY_DIS;
		col_en = COL_DIS;
		rd_count_en = DISABLE;
		iv_cnt_en = DISABLE;
		iv_cnt_sel = IV_BUS;
		bypass_key_en = DISABLE;
		key_derivation_en = DISABLE;
		//end_comp = DISABLE;
		case(state)
			ROUND0_COL0:
				begin
					sbox_sel = COL_0;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_0;
					col_sel = (enc_dec) ? ADD_RK_OUT : SHIFT_ROWS;
					col_en =  (enc_dec) ? EN_COL_0 : COL_ALL;
				end
			ROUND0_COL1:
				begin
					sbox_sel = COL_1;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_1;
					col_sel = ADD_RK_OUT;
					col_en = EN_COL_1;
					if(!enc_dec)
						begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_1;
						end
				end
			ROUND0_COL2:
				begin
					sbox_sel = COL_2;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_2;
					col_sel = ADD_RK_OUT;
					col_en = EN_COL_2;
					if(!enc_dec)
						begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_2;
						end
				end
			ROUND0_COL3:
				begin
					sbox_sel = COL_3;
					rk_sel   = COL;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_3;
					col_sel = (enc_dec) ? SHIFT_ROWS : ADD_RK_OUT;
					col_en =  (enc_dec) ? COL_ALL : EN_COL_3;
					bypass_rk = ENABLE;
					if(!enc_dec)
					begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_3;
					end
				end
			ROUND_KEY0:
				begin
					sbox_sel = G_FUNCTION;
					key_sel = KEY_OUT;
					key_en = EN_KEY_0;
					rd_count_en = ENABLE;
				end
			ROUND_COL0:
				begin
					sbox_sel = COL_0;
					rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_0;
					key_sel = KEY_OUT;

					if(enc_dec)
						key_en = EN_KEY_1;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						begin
							if(!enc_dec)
								col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;
							else
								col_sel = ADD_RK_OUT;
						end
					if(enc_dec)
						col_en = EN_COL_0;
					else
						col_en = (last_round) ? EN_COL_0 : COL_ALL;
				end
			ROUND_COL1:
				begin
					sbox_sel = COL_1;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_1;
					key_sel = KEY_OUT;
					if(enc_dec)
						key_en = EN_KEY_2;
					else
						key_en = EN_KEY_1;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						col_sel = ADD_RK_OUT;
					col_en = EN_COL_1;
				end
			ROUND_COL2:
				begin
					sbox_sel = COL_2;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_2;
					key_sel = KEY_OUT;
					if(enc_dec)
						key_en = EN_KEY_3;
					else
						key_en = EN_KEY_2;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						col_sel = ADD_RK_OUT;
					col_en = EN_COL_2;
				end
			ROUND_COL3:
				begin
					sbox_sel = COL_3;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_3;
					key_sel = KEY_OUT;
					if(!enc_dec)
						key_en = EN_KEY_3;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						begin
							if(enc_dec)
								col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;
							else
								col_sel = ADD_RK_OUT;
						end
					if(enc_dec)
						col_en = (last_round) ? EN_COL_3 : COL_ALL;
					else
						col_en = EN_COL_3;
					if(mode_ctr && last_round)
						begin
							iv_cnt_en = ENABLE;
							iv_cnt_sel = IV_CNT;
						end
				end
			GEN_KEY0:
				begin
					sbox_sel = G_FUNCTION;
					rd_count_en = ENABLE;
				end
			GEN_KEY1:
				begin
					key_en = EN_KEY_1 | EN_KEY_0; //Enable key 0 AND key 1
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			GEN_KEY2:
				begin
					key_en = EN_KEY_2;
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			GEN_KEY3:
				begin
					key_en = EN_KEY_3;
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			READY:
				begin
					//end_comp = ENABLE;
					if(op_mode == KEY_DERIVATION)
						key_derivation_en = ENABLE;
				end
		endcase
	end

// Round Counter
always @(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			rd_count <= INITIAL_ROUND;
		else
			if(state == IDLE || (state == GEN_KEY3 && last_round))
				rd_count <= INITIAL_ROUND;
			else 
				if(rd_count_en)
					rd_count <= rd_count + 1'b1;
	end

assign round = rd_count;
assign first_round = (rd_count == INITIAL_ROUND);
assign last_round  = (rd_count == NUMBER_ROUND || rd_count == NUMBER_ROUND_INC);

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(aes_mode[0] == 1) |-> (mode_ctr == 0)"",
    ""Signals"": [""aes_mode[0]"", ""mode_ctr""],
    ""Signal Explanations"": {
      ""aes_mode[0]"": ""the least significant bit of the aes_mode input that specifies the AES operation mode"",
      ""mode_ctr"": ""a signal indicating whether the CTR mode is active""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the least significant bit of the aes_mode input equals 1, then the signal indicating whether the CTR mode is active equals 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(aes_mode[0] == 0) |-> (mode_cbc == 0)"",
    ""Signals"": [""aes_mode[0]"", ""mode_cbc""],
    ""Signal Explanations"": {
      ""aes_mode[0]"": ""the least significant bit of the aes_mode input that specifies the AES operation mode"",
      ""mode_cbc"": ""a signal indicating whether the CBC mode is active""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the least significant bit of the aes_mode input equals 0, then the signal indicating whether the CBC mode is active equals 0 from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(start == 0) |-> (key_init == 0)"",
    ""Signals"": [""start"", ""key_init""],
    ""Signal Explanations"": {
      ""start"": ""the input signal that indicates the beginning of an AES operation"",
      ""key_init"": ""the signal used to initialize the key generation process""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the signal that indicates the beginning of an AES operation equals 0, then the signal used to initialize the key generation process equals 0 from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""(start == 1) |-> (key_init == 1)"",
    ""Signals"": [""start"", ""key_init""],
    ""Signal Explanations"": {
      ""start"": ""the input signal that indicates the beginning of an AES operation"",
      ""key_init"": ""the signal used to initialize the key generation process""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the signal that indicates the beginning of an AES operation equals 1, then the signal used to initialize the key generation process equals 1 from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((aes_mode[0] == 1) |-> (mode_ctr == 0));"",
""Assertion 2"": ""assert property ((aes_mode[0] == 1'b0) |-> (mode_cbc == 1'b0));"",
""Assertion 3"": ""assert property ((!start) |-> (!key_init));"",
""Assertion 4"": ""assert property ((start == 1) |-> (key_init == 1));""
}"
Programmable_Sequence_Detector,"module Programmable_Sequence_Detector 
#(
	parameter SEQ_W = 5
)
(
  input clk,
  input resetn,
  input [SEQ_W-1:0] init,
  input             din,
  input logic      seen
);

reg  [SEQ_W-1:0] seq_q;
wire [SEQ_W-1:0] seq_next;

assign seq_next = { seq_q[SEQ_W-2:0] , din } ;

always @(posedge clk) 
begin
	if ( ~resetn ) begin
		seq_q <= '0;
	end else begin
		seq_q <= seq_next;
	end
end

assign seen = seq_q == init;

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff(~resetn)"",
    ""logical expression"": ""seen == (seq_q == init)"",
    ""Signals"": [""seen"", ""seq_q"", ""init""],
    ""Signal Explanations"": {
      ""seen"": ""output signal indicating whether the current sequence equals the initialization sequence"",
      ""seq_q"": ""register storing the current sequence bits"",
      ""init"": ""initialization sequence to be detected""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""the output is asserted whenever a specified target sequence is detected on the input""
  }
}","{
""Assertion 1"": ""assert property (seq_q |-> seen) @(posedge clk);""
}"
PWM,"module PWM #(parameter CBITS = 10) 
(input clk, input rst, input [3:0] sw, output reg pulse);
  
  wire [CBITS-1:0] pulse_wide;
  assign pulse_wide = {1'b0, sw[3:1], 6'd0};     // (CBTIS-4)

  reg [CBITS-1:0] cntR;

  always @(posedge clk) begin
    cntR <= cntR + 1;
    
    if (cntR < pulse_wide)
      pulse = 1'b1;
    else
      pulse = 1'b0;
  end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""1 |-> s_eventually(~pulse)"",
    ""Signals"": [""pulse""],
    ""Signal Explanations"": {
      ""pulse"": ""output signal of the verilog module representing the pulse""
    },
    ""Logical Operators"": [""|->"", ""s_eventually"", ""~""],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
      ""~"": ""the inversion (logical NOT) of the value of the signal""
    },
    ""Assertion Explaination"": ""eventually, the inversion of the output signal becomes true""
  }
}","{
""Assertion 1"": ""assert property (s_eventually(!pulse));""
}"
module_i2c,"//////////////////////////////////////////////////////////////////
////
////
//// 	TOP I2C BLOCK to I2C Core
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// apbi2c_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Ronal Dario Celaya ,rcelaya.dario@gmail.com
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////


`timescale 1ns/1ps //timescale 

module module_i2c#(
			//THIS IS USED ONLY LIKE PARAMETER TO BEM CONFIGURABLE
			parameter integer DWIDTH = 32,
			parameter integer AWIDTH = 14
		)
		(
		//I2C INTERFACE WITH ANOTHER BLOCKS
		 input PCLK,
		 input PRESETn,
		 
		//INTERFACE WITH FIFO TRANSMISSION
		 input fifo_tx_f_full,
		 input fifo_tx_f_empty,
		 input [DWIDTH-1:0] fifo_tx_data_out,

		//INTERFACE WITH FIFO RECEIVER
		 input fifo_rx_f_full,
		 input fifo_rx_f_empty,
		 output reg fifo_rx_wr_en,
		 output reg [DWIDTH-1:0] fifo_rx_data_in, 

		//INTERFACE WITH REGISTER CONFIGURATION
		 input [AWIDTH-1:0] DATA_CONFIG_REG,
 		 input [AWIDTH-1:0] TIMEOUT_TX,
		
		//INTERFACE TO APB AND READ FOR FIFO   
		 output reg fifo_tx_rd_en,
		 output   TX_EMPTY,
		 output   RX_EMPTY,
		 output ERROR,
		 output ENABLE_SDA,
		 output ENABLE_SCL,

		//I2C BI DIRETIONAL PORTS
		inout SDA,
		inout SCL
		 

		 );

//THIS IS USED TO GENERATE INTERRUPTIONS
assign TX_EMPTY = (fifo_tx_f_empty == 1'b1)? 1'b1:1'b0;
assign RX_EMPTY = (fifo_rx_f_empty == 1'b1)? 1'b1:1'b0;

	//THIS COUNT IS USED TO CONTROL DATA ACCROSS FSM	
	reg [1:0] count_tx;
	reg [1:0] count_rx;
	//CONTROL CLOCK AND COUNTER
	reg [11:0] count_send_data;
	reg [11:0] count_receive_data;
	reg [11:0] count_timeout;
	reg BR_CLK_O;
	reg SDA_OUT;

	reg BR_CLK_O_RX;
	reg SDA_OUT_RX;

	//RESPONSE USED TO HOLD SIGNAL TO ACK OR NACK
	reg RESPONSE;

//    PARAMETERS USED TO STATE MACHINE

localparam [5:0] IDLE = 6'd0, //IDLE

	   START = 6'd1,//START BIT

	     CONTROLIN_1 = 6'd2, //START BYTE
	     CONTROLIN_2 = 6'd3,
	     CONTROLIN_3 = 6'd4,
             CONTROLIN_4 = 6'd5,
	     CONTROLIN_5 = 6'd6,
	     CONTROLIN_6 = 6'd7,
             CONTROLIN_7 = 6'd8,
             CONTROLIN_8 = 6'd9, //END FIRST BYTE

	     RESPONSE_CIN =6'd10, //RESPONSE

	     ADDRESS_1 = 6'd11,//START BYTE
	     ADDRESS_2 = 6'd12,
	     ADDRESS_3 = 6'd13,
             ADDRESS_4 = 6'd14,
	     ADDRESS_5 = 6'd15,
	     ADDRESS_6 = 6'd16,
             ADDRESS_7 = 6'd17,
             ADDRESS_8 = 6'd18,//END FIRST BYTE

	     RESPONSE_ADDRESS =6'd19, //RESPONSE

	     DATA0_1 = 6'd20,//START BYTE
	     DATA0_2 = 6'd21,
	     DATA0_3 = 6'd22,
             DATA0_4 = 6'd23,
	     DATA0_5 = 6'd24,
	     DATA0_6 = 6'd25,
             DATA0_7 = 6'd26,
             DATA0_8 = 6'd27,//END FIRST BYTE

	     RESPONSE_DATA0_1 = 6'd28,  //RESPONSE
	   
	     DATA1_1 = 6'd29,//START BYTE
	     DATA1_2 = 6'd30,
	     DATA1_3 = 6'd31,
             DATA1_4 = 6'd32,
	     DATA1_5 = 6'd33,
	     DATA1_6 = 6'd34,
             DATA1_7 = 6'd35,
             DATA1_8 = 6'd36,//END FIRST BYTE

	     RESPONSE_DATA1_1 = 6'd37,//RESPONSE

	     DELAY_BYTES = 6'd38,//USED ONLY IN ACK TO DELAY BETWEEN
	     NACK = 6'd39,//USED ONLY IN ACK TO DELAY BETWEEN BYTES
	     STOP = 6'd40;//USED TO SEND STOP BIT

	//STATE CONTROL 
	reg [5:0] state_tx;
	reg [5:0] next_state_tx;

//ASSIGN REGISTERS TO BIDIRETIONAL PORTS
assign SDA =(DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b0 & state_tx != RESPONSE_CIN & state_tx != RESPONSE_ADDRESS & state_tx != RESPONSE_DATA0_1 & state_tx != RESPONSE_DATA1_1)?SDA_OUT:SDA_OUT_RX;


assign SCL = (DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b0)?BR_CLK_O:BR_CLK_O_RX;

//STANDARD ERROR
assign ERROR = (DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b1)?1'b1:1'b0;


//COMBINATIONAL BLOCK TO   
always@(*)
begin

	//THE FUN START HERE :-)
	//COMBINATIONAL UPDATE STATE BE CAREFUL WITH WHAT YOU MAKE HERE
	next_state_tx=state_tx;

	case(state_tx)//state_   IS MORE SECURE CHANGE ONLY IF YOU KNOW WHAT ARE YOU DOING 
	IDLE:
	begin
		//OBEYING SPEC
		if(DATA_CONFIG_REG[0] == 1'b0 && (fifo_tx_f_full == 1'b1 || fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b0)
		begin
			next_state_tx   = IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && (fifo_tx_f_full == 1'b1 || fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b1)
		begin
			next_state_tx   = IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && ((fifo_tx_f_full == 1'b0 && fifo_tx_f_empty == 1'b0) || fifo_tx_f_full == 1'b1) && DATA_CONFIG_REG[1] == 1'b0 && count_timeout < TIMEOUT_TX)
		begin
			next_state_tx   = START;
		end


	end
	START://THIS IS USED TOO ALL STATE MACHINES THE COUNTER_SEND_DATA
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = START;
		end
		else
		begin
			next_state_tx   = CONTROLIN_1;
		end
		
	end
	CONTROLIN_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = CONTROLIN_1;
		end
		else
		begin
			next_state_tx  =  CONTROLIN_2;
		end

	end
	CONTROLIN_2:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = CONTROLIN_2;
		end
		else
		begin
			next_state_tx   = CONTROLIN_3;
		end

	end
	CONTROLIN_3:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  CONTROLIN_3;
		end
		else
		begin
			next_state_tx   = CONTROLIN_4;
		end		
	end
	CONTROLIN_4:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = CONTROLIN_4;
		end
		else
		begin
			next_state_tx   = CONTROLIN_5;
		end		
	end
	CONTROLIN_5:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_5;
		end
		else
		begin
			next_state_tx = CONTROLIN_6;
		end		
	end
	CONTROLIN_6:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_6;
		end
		else
		begin
			next_state_tx = CONTROLIN_7;
		end		
	end
	CONTROLIN_7:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_7;
		end
		else
		begin
			next_state_tx = CONTROLIN_8;
		end		
	end
	CONTROLIN_8:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = CONTROLIN_8;
		end
		else 
		begin
			next_state_tx  = RESPONSE_CIN;
		end		
	end
	RESPONSE_CIN:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = RESPONSE_CIN;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx = DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx = NACK;
		end	
		
	end

	//NOW SENDING ADDRESS
	ADDRESS_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = ADDRESS_1;
		end
		else
		begin
			next_state_tx  =  ADDRESS_2;
		end	
	end
	ADDRESS_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_2;
		end
		else
		begin
			next_state_tx = ADDRESS_3;
		end	
	end
	ADDRESS_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_3;
		end
		else
		begin
			next_state_tx = ADDRESS_4;
		end	
	end
	ADDRESS_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_4;
		end
		else
		begin
			next_state_tx = ADDRESS_5;
		end	
	end
	ADDRESS_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_5;
		end
		else
		begin
			next_state_tx = ADDRESS_6;
		end	
	end
	ADDRESS_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_6;
		end
		else
		begin
			next_state_tx = ADDRESS_7;
		end	
	end
	ADDRESS_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_7;
		end
		else
		begin
			next_state_tx = ADDRESS_8;
		end	
	end
	ADDRESS_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_8;
		end
		else
		begin
			next_state_tx = RESPONSE_ADDRESS;
		end	
	end
	RESPONSE_ADDRESS:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = RESPONSE_ADDRESS;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx = DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK --> RESTART CONDITION AND BACK TO START BYTE AGAIN
		begin
			next_state_tx = NACK;
		end	
	end
	
	//data in
	DATA0_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_1;
		end
		else
		begin
			next_state_tx = DATA0_2;
		end
	end
	DATA0_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_2;
		end
		else
		begin
			next_state_tx = DATA0_3;
		end
	end
	DATA0_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_3;
		end
		else
		begin
			next_state_tx = DATA0_4;
		end
	end
	DATA0_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_4;
		end
		else
		begin
			next_state_tx = DATA0_5;
		end
	end
	DATA0_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_5;
		end
		else
		begin
			next_state_tx   = DATA0_6;
		end
	end
	DATA0_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_6;
		end
		else
		begin
			next_state_tx  = DATA0_7;
		end
	end
	DATA0_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_7;
		end
		else
		begin
			next_state_tx  = DATA0_8;
		end
	end
	DATA0_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_8;
		end
		else
		begin
			next_state_tx  =  RESPONSE_DATA0_1;
		end
	end
	RESPONSE_DATA0_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx  =   NACK;
		end	
	end

	//second byte
	DATA1_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_1;
		end
		else
		begin
			next_state_tx  = DATA1_2;
		end
	end
	DATA1_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_2;
		end
		else
		begin
			next_state_tx = DATA1_3;
		end
	end
	DATA1_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_3;
		end
		else
		begin
			next_state_tx  =  DATA1_4;
		end
	end
	DATA1_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_4;
		end
		else
		begin
			next_state_tx  = DATA1_5;
		end
	end
	DATA1_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_5;
		end
		else
		begin
			next_state_tx = DATA1_6;
		end
	end
	DATA1_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  DATA1_6;
		end
		else
		begin
			next_state_tx  =  DATA1_7;
		end
	end
	DATA1_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx =  DATA1_7;
		end
		else
		begin
			next_state_tx =  DATA1_8;
		end
	end
	DATA1_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_8;
		end
		else
		begin
			next_state_tx = RESPONSE_DATA1_1;
		end
	end
	RESPONSE_DATA1_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   =  RESPONSE_DATA1_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx   =  DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx   =  NACK;
		end	
	end
	DELAY_BYTES://THIS FORM WORKS 
	begin

		
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx =  DELAY_BYTES;
		end
		else
		begin

			if(count_tx == 2'd0)
			begin
				next_state_tx = ADDRESS_1;
			end
			else if(count_tx   == 2'd1)
			begin
				next_state_tx = DATA0_1;
			end
			else if(count_tx   == 2'd2)
			begin
				next_state_tx = DATA1_1;
			end
			else if(count_tx   == 2'd3)
			begin
				next_state_tx = STOP;
			end
			
		end

	end
	NACK://NOT TESTED YET !!!!
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2]*2'd2)
		begin
			next_state_tx  = NACK;
		end
		else
		begin
			if(count_tx == 2'd0)
			begin
				next_state_tx = CONTROLIN_1;
			end
			else if(count_tx == 2'd1)
			begin
				next_state_tx = ADDRESS_1;
			end
			else if(count_tx  == 2'd2)
			begin
				next_state_tx   = DATA0_1;
			end
			else if(count_tx == 2'd3)
			begin
				next_state_tx = DATA1_1;
			end
		end
	end
	STOP://THIS WORK
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = STOP;
		end
		else
		begin
			next_state_tx = IDLE;
		end
	end
	default:
	begin
		next_state_tx =  IDLE;
	end
	endcase


end



//SEQUENTIAL   
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		//SIGNALS MUST BE RESETED
		count_send_data <= 12'd0;
		state_tx   <= IDLE;	
		SDA_OUT<= 1'b1;
		fifo_tx_rd_en <= 1'b0;
		count_tx   <= 2'd0;
		BR_CLK_O <= 1'b1;
		RESPONSE<= 1'b0;	
	end
	else
	begin
		
		// SEQUENTIAL FUN START
		state_tx  <= next_state_tx;

		case(state_tx)
		IDLE:
		begin

			fifo_tx_rd_en <= 1'b0;
			
 
			if(DATA_CONFIG_REG[0] == 1'b0 && (fifo_tx_f_full == 1'b1 ||fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b0)
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b1;
				BR_CLK_O <= 1'b1;
			end
			else if(DATA_CONFIG_REG[0] == 1'b1 && ((fifo_tx_f_empty == 1'b0 && fifo_tx_f_full == 1'b0 )|| fifo_tx_f_full == 1'b1 ) && DATA_CONFIG_REG[1] == 1'b0)
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=1'b0;			
			end
			else if(DATA_CONFIG_REG[0] == 1'b1 && (fifo_tx_f_full == 1'b1 ||fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b1)
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b1;
				BR_CLK_O <= 1'b1;
			end			

		end
		START:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				BR_CLK_O <= 1'b0;
			end
			else
			begin
				count_send_data <= 12'd0;					
			end	

			if(count_send_data == DATA_CONFIG_REG[13:2]- 12'd1)
			begin
				SDA_OUT<=fifo_tx_data_out[0:0];
				count_tx   <= 2'd0;
			end

		end
		CONTROLIN_1:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[0:0];	

								
				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[1:1];
			end

				
		end
		
		CONTROLIN_2:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[1:1];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[2:2];
			end
				
		end

		CONTROLIN_3:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[2:2];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[3:3];
			end	


				
		end
		CONTROLIN_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[3:3];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[4:4];
			end
				
		end

		CONTROLIN_5:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[4:4];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[5:5];
			end	

		end
		CONTROLIN_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[5:5];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[6:6];
			end	

				
		end

		CONTROLIN_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[6:6];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[7:7];
			end	

				
		end
		CONTROLIN_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[7:7];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b0;
			end

				
		end
		RESPONSE_CIN:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
			end	


		end
		ADDRESS_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[8:8];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[9:9];
			end	
				
		end		
		ADDRESS_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[9:9];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[10:10];
			end	

		end
		ADDRESS_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[10:10];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[11:11];
			end	

		end
		ADDRESS_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[11:11];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[12:12];
			end	
		end
		ADDRESS_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[12:12];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[13:13];
			end	

				
		end
		ADDRESS_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[13:13];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;		
				SDA_OUT<=fifo_tx_data_out[14:14];
			end	
				
		end
		ADDRESS_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[14:14];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[15:15];
			end	

				
		end
		ADDRESS_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[15:15];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_ADDRESS:
		begin
			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
			end

		end
		DATA0_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[16:16];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;				
				SDA_OUT<=fifo_tx_data_out[17:17];
			end	

				
		end
		DATA0_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[17:17];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[18:18];
			end	

				
		end		
		DATA0_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[18:18];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[19:19];
			end	
				
		end
		DATA0_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[19:19];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[20:20];
			end	
				
		end
		DATA0_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[20:20];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[21:21];
			end

		end
		DATA0_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[21:21];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[22:22];
			end
				
		end
		DATA0_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[22:22];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[23:23];
			end	
				
		end
		DATA0_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[23:23];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_DATA0_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
			end

		end
		DATA1_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[24:24];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[25:25];

			end

				
		end
		DATA1_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[25:25];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[26:26];
			end	

		end
		DATA1_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[26:26];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[27:27];
			end	
				
		end
		DATA1_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[27:27];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[28:28];
			end	
				
		end
		DATA1_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[28:28];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[29:29];
			end	
				
		end
		DATA1_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[29:29];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[30:30];
			end	
				
		end
		DATA1_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[30:30];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[31:31];
			end	

				
		end
		DATA1_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[31:31];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_DATA1_1:
		begin
			//fifo_  _rd_en <= 1'b1;

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				fifo_tx_rd_en <= 1'b1;
			end	

		end
		DELAY_BYTES:
		begin
			
			fifo_tx_rd_en <= 1'b0;
		
			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				
				count_send_data <= count_send_data + 12'd1;	
				BR_CLK_O <= 1'b0;
				SDA_OUT<=1'b0;		
			end
			else
			begin


				if(count_tx == 2'd0)
				begin
					count_tx <= count_tx + 2'd1;
					SDA_OUT<=fifo_tx_data_out[8:8];
				end
				else if(count_tx   == 2'd1)
				begin
					count_tx <= count_tx + 2'd1;
					SDA_OUT<=fifo_tx_data_out[16:16];
				end
				else if(count_tx == 2'd2)
				begin
					count_tx <= count_tx + 2'd1;
					SDA_OUT<=fifo_tx_data_out[24:24];
				end
				else if(count_tx == 2'd3)
				begin
					count_tx <= 2'd0;
				end

				count_send_data <= 12'd0;
			
			end

		end
		//THIS BLOCK MUST BE CHECKED WITH CARE
		NACK:// MORE A RESTART 
		begin
			fifo_tx_rd_en <= 1'b0;
		
			if(count_send_data < DATA_CONFIG_REG[13:2]*2'd3)
			begin		
				count_send_data <= count_send_data + 12'd1;
	
				if(count_receive_data < DATA_CONFIG_REG[13:2]/12'd2)
				begin
					SDA_OUT<=1'b0;
				end
				else if(count_send_data > DATA_CONFIG_REG[13:2]/12'd2-12'd1 && count_send_data < DATA_CONFIG_REG[13:2])
				begin
					SDA_OUT<=1'b1;
				end
				else if(count_send_data  == DATA_CONFIG_REG[13:2]*2'd2)
				begin
					SDA_OUT<=1'b0;
				end

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd2)
				begin
					BR_CLK_O <= 1'b1;
				end
				else if(count_send_data > DATA_CONFIG_REG[13:2]/12'd2-12'd1 && count_send_data < DATA_CONFIG_REG[13:2])
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data < DATA_CONFIG_REG[13:2]*2'd2)
				begin
					BR_CLK_O <= 1'b1;
				end
		
			end
			else
			begin
				count_send_data <= 12'd0;

				if(count_tx == 2'd0)
				begin
					count_tx <= 2'd0;
					SDA_OUT<=fifo_tx_data_out[0:0];
				end
				else if(count_tx == 2'd1)
				begin
					count_tx <= 2'd1;
					SDA_OUT<=fifo_tx_data_out[8:8];
				end
				else if(count_tx == 2'd2)
				begin
					count_tx <= 2'd2;
					SDA_OUT<=fifo_tx_data_out[16:16];
				end
				else if(count_tx == 2'd3)
				begin
					count_tx <= 2'd3;
					SDA_OUT<=fifo_tx_data_out[24:24];
				end

			
			end
		end
		STOP:
		begin

			BR_CLK_O <= 1'b1;

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd2-12'd2)
				begin
					SDA_OUT<=1'b0;
				end
				else if(count_send_data > DATA_CONFIG_REG[13:2]/12'd2-12'd1 && count_send_data < DATA_CONFIG_REG[13:2])
				begin
					SDA_OUT<=1'b1;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
			end
		end
		default:
		begin
			fifo_tx_rd_en <= 1'b0;
			count_send_data <= 12'd4095;
		end
		endcase
		
	end


end 


	//STATE CONTROL 
	reg [5:0] state_rx;
	reg [5:0] next_state_rx;

assign ENABLE_SDA = (state_rx ==  RESPONSE_CIN|| 
		     state_rx ==  RESPONSE_ADDRESS|| 
		     state_rx == RESPONSE_DATA0_1|| 
		     state_rx == RESPONSE_DATA1_1)?1'b1:
		    (state_tx ==  RESPONSE_CIN|| 
		     state_tx ==  RESPONSE_ADDRESS|| 
		     state_tx == RESPONSE_DATA0_1|| 
		     state_tx == RESPONSE_DATA1_1)?1'b0:1'b1;


assign ENABLE_SCL = (state_rx ==  RESPONSE_CIN|| 
		     state_rx ==  RESPONSE_ADDRESS|| 
		     state_rx == RESPONSE_DATA0_1|| 
		     state_rx == RESPONSE_DATA1_1)?1'b1:
		    (state_tx ==  RESPONSE_CIN|| 
		     state_tx ==  RESPONSE_ADDRESS|| 
		     state_tx == RESPONSE_DATA0_1|| 
		     state_tx == RESPONSE_DATA1_1)?1'b1:1'b0;


//COMBINATIONAL BLOCK TO RX
always@(*)
begin

	//THE FUN START HERE :-)
	//COMBINATIONAL UPDATE STATE BE CAREFUL WITH WHAT YOU MAKE HERE
	next_state_rx = state_rx;

	case(state_rx)//state_rx IS MORE SECURE CHANGE ONLY IF YOU KNOW WHAT ARE YOU DOING 
	IDLE:
	begin
		//OBEYING SPEC
		if(DATA_CONFIG_REG[0] == 1'b0 && DATA_CONFIG_REG[1] == 1'b0)
		begin
			next_state_rx =   IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && DATA_CONFIG_REG[1] == 1'b1)
		begin
			next_state_rx =   IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b0 && DATA_CONFIG_REG[1] == 1'b1 && SDA_OUT_RX == 1'b0 && BR_CLK_O_RX == 1'b0)
		begin
			next_state_rx =   START;
		end


	end
	START://THIS IS USED TOO ALL STATE MACHINES THE COUNTER_SEND_DATA
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   START;
		end
		else if(fifo_rx_data_in[0] == 1'b0 && fifo_rx_data_in[1] == 1'b0)
		begin
			next_state_rx =   CONTROLIN_1;
		end
		else 
		begin
			next_state_rx =   IDLE;
		end
		
	end
	  CONTROLIN_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_1;
		end
		else
		begin
			next_state_rx =   CONTROLIN_2;
		end

	end
	  CONTROLIN_2:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_2;
		end
		else
		begin
			next_state_rx =   CONTROLIN_3;
		end

	end
	  CONTROLIN_3:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_3;
		end
		else
		begin
			next_state_rx =   CONTROLIN_4;
		end		
	end
	  CONTROLIN_4:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_4;
		end
		else
		begin
			next_state_rx =   CONTROLIN_5;
		end		
	end
	  CONTROLIN_5:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_5;
		end
		else
		begin
			next_state_rx =   CONTROLIN_6;
		end		
	end
	  CONTROLIN_6:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_6;
		end
		else
		begin
			next_state_rx =   CONTROLIN_7;
		end		
	end
	  CONTROLIN_7:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_7;
		end
		else
		begin
			next_state_rx =   CONTROLIN_8;
		end		
	end
	  CONTROLIN_8:
	begin

		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   CONTROLIN_8;
		end
		else 
		begin
			next_state_rx =   RESPONSE_CIN;
		end		
	end
	RESPONSE_CIN:
	begin

		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_CIN;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end
		
	end
	//NOW SENDING ADDRESS
	ADDRESS_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_1;
		end
		else
		begin
			next_state_rx =   ADDRESS_2;
		end	
	end
	ADDRESS_2:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_2;
		end
		else
		begin
			next_state_rx =   ADDRESS_3;
		end	
	end
	ADDRESS_3:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_3;
		end
		else
		begin
			next_state_rx =   ADDRESS_4;
		end	
	end
	ADDRESS_4:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_4;
		end
		else
		begin
			next_state_rx =   ADDRESS_5;
		end	
	end
	ADDRESS_5:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_5;
		end
		else
		begin
			next_state_rx =   ADDRESS_6;
		end	
	end
	ADDRESS_6:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_6;
		end
		else
		begin
			next_state_rx =   ADDRESS_7;
		end	
	end
	ADDRESS_7:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_7;
		end
		else
		begin
			next_state_rx =   ADDRESS_8;
		end	
	end
	ADDRESS_8:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   ADDRESS_8;
		end
		else
		begin
			next_state_rx =   RESPONSE_ADDRESS;
		end	
	end
	RESPONSE_ADDRESS:
	begin
		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_ADDRESS;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end
	end
	//data in
	DATA0_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_1;
		end
		else
		begin
			next_state_rx =   DATA0_2;
		end
	end
	  DATA0_2:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_2;
		end
		else
		begin
			next_state_rx =   DATA0_3;
		end
	end
	  DATA0_3:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_3;
		end
		else
		begin
			next_state_rx =   DATA0_4;
		end
	end
	  DATA0_4:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_4;
		end
		else
		begin
			next_state_rx =   DATA0_5;
		end
	end
	  DATA0_5:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_5;
		end
		else
		begin
			next_state_rx =   DATA0_6;
		end
	end
	  DATA0_6:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_6;
		end
		else
		begin
			next_state_rx =   DATA0_7;
		end
	end
	  DATA0_7:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_7;
		end
		else
		begin
			next_state_rx =   DATA0_8;
		end
	end
	  DATA0_8:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA0_8;
		end
		else
		begin
			next_state_rx =   RESPONSE_DATA0_1;
		end
	end
	RESPONSE_DATA0_1:
	begin

		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end	
	end
	//second byte
	DATA1_1:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_1;
		end
		else
		begin
			next_state_rx =   DATA1_2;
		end
	end
	DATA1_2:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_2;
		end
		else
		begin
			next_state_rx =   DATA1_3;
		end
	end
	DATA1_3:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_3;
		end
		else
		begin
			next_state_rx =   DATA1_4;
		end
	end
	  DATA1_4:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_4;
		end
		else
		begin
			next_state_rx =   DATA1_5;
		end
	end
	  DATA1_5:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_5;
		end
		else
		begin
			next_state_rx =   DATA1_6;
		end
	end
	  DATA1_6:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_6;
		end
		else
		begin
			next_state_rx =   DATA1_7;
		end
	end
	  DATA1_7:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_7;
		end
		else
		begin
			next_state_rx =   DATA1_8;
		end
	end
	  DATA1_8:
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DATA1_8;
		end
		else
		begin
			next_state_rx =   RESPONSE_DATA1_1;
		end
	end
	RESPONSE_DATA1_1:
	begin
		if(count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_rx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_rx  =   NACK;
		end	
	
	end
	DELAY_BYTES://THIS FORM WORKS 
	begin

		
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   DELAY_BYTES;
		end
		else
		begin

			if(count_rx == 2'd0)
			begin
				next_state_rx =   ADDRESS_1;
			end
			else if(count_rx == 2'd1)
			begin
				next_state_rx =   DATA0_1;
			end
			else if(count_rx == 2'd2)
			begin
				next_state_rx =   DATA1_1;
			end
			else if(count_rx == 2'd3)
			begin
				next_state_rx =   STOP;
			end
			
		end

	end
	  STOP://THIS WORK
	begin
		if(  count_receive_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_rx =   STOP;
		end
		else
		begin
			next_state_rx =   IDLE;
		end
	end
	default:
	begin
			next_state_rx =   IDLE;
	end
	endcase


end



//SEQUENTIAL   
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		//SIGNALS MUST BE RESETED
		  count_receive_data <= 12'd0;
		state_rx <=   IDLE;	
		SDA_OUT_RX<= 1'b0;
		fifo_rx_wr_en <= 1'b0;
		count_rx <= 2'd0;
		BR_CLK_O_RX <= 1'b0;	
	end
	else 
	begin
		
		// SEQUENTIAL FUN START
		state_rx <= next_state_rx;

		case(state_rx)
		  IDLE:
		begin



			if(((fifo_rx_f_full == 1'b0 && fifo_rx_f_empty == 1'b0) || (fifo_rx_f_full == 1'b0 && fifo_rx_f_empty == 1'b1)) && DATA_CONFIG_REG[1] == 1'b1)
			begin

				  SDA_OUT_RX<= SDA;
				  BR_CLK_O_RX<=SCL;
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  SDA_OUT_RX<= SDA_OUT_RX;
				  BR_CLK_O_RX<=BR_CLK_O_RX;
				  count_receive_data <=   count_receive_data;		
			end
	
		end
		  START:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(  count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[0]<= SDA;
				fifo_rx_data_in[1]<= SCL;			
			end

		end
		  CONTROLIN_1:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[0]<= SDA;			
			end

		end		
		  CONTROLIN_2:
		begin
	
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[1]<= SDA;			
			end
				
		end
		  CONTROLIN_3:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end


			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[2]<= SDA;			
			end

		
		end
		  CONTROLIN_4:
		begin
	
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[3]<= SDA;			
			end
				
		end
		  CONTROLIN_5:
		begin

			
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
					fifo_rx_data_in[4]<= SDA;			
			end
		

		end
		  CONTROLIN_6:
		begin
				if(  count_receive_data < DATA_CONFIG_REG[13:2])
				begin
					  count_receive_data <=   count_receive_data + 12'd1;
				end
				else
				begin
					  count_receive_data <= 12'd0;
				end

				if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					fifo_rx_data_in[5]<= SDA;			
				end		
		end

		  CONTROLIN_7:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[6]<= SDA;			
			end
		end
		  CONTROLIN_8:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[7]<= SDA;			
			end
	

				
		end
		  RESPONSE_CIN:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

		end
		  ADDRESS_1:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[8]<= SDA;			
			end
	
				
		end		
		  ADDRESS_2:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[9]<= SDA;			
			end
	

		end
		  ADDRESS_3:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[10]<= SDA;			
			end
	
	

		end
		  ADDRESS_4:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[11]<= SDA;			
			end
	
		end
		  ADDRESS_5:
		begin


				
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[12]<= SDA;			
			end

					
		end
		  ADDRESS_6:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[13]<= SDA;			
			end
	
		end
		  ADDRESS_7:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[14]<= SDA;			
			end
				
		end
		  ADDRESS_8:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[15]<= SDA;			
			end

				
		end
		  RESPONSE_ADDRESS:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end


		end
		  DATA0_1:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[16]<= SDA;			
			end
	

				
		end
		  DATA0_2:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[17]<= SDA;			
			end
	
				
		end		
		  DATA0_3:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[18]<= SDA;			
			end
				
		end
		  DATA0_4:
		begin



			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[19]<= SDA;			
			end
	
		end
		  DATA0_5:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[20]<= SDA;			
			end


		end
		  DATA0_6:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[21]<= SDA;			
			end
	
		end
		  DATA0_7:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[22]<= SDA;			
			end
				
		end
		  DATA0_8:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[23]<= SDA;			
			end
		
		end
		  RESPONSE_DATA0_1:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

		end
		  DATA1_1:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[24]<= SDA;			
			end
				
		end
		  DATA1_2:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[25]<= SDA;			
			end


		end
		  DATA1_3:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[26]<= SDA;			
			end

				
		end
		  DATA1_4:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[27]<= SDA;			
			end
	
				
		end
		  DATA1_5:
		begin



			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[28]<= SDA;			
			end
	
				
		end
		  DATA1_6:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[29]<= SDA;			
			end


				
		end
		  DATA1_7:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[30]<= SDA;			
			end


				
		end
		  DATA1_8:
		begin


			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end

			if(SCL == 1'b1 &&   count_receive_data >= DATA_CONFIG_REG[13:2]/12'd4 &&   count_receive_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
			begin
				fifo_rx_data_in[31]<= SDA;			
			end
				
		end
		RESPONSE_DATA1_1:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end
			//fifo_  _rd_en <= 1'b1;

		end
		DELAY_BYTES:
		begin

			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin


				if(count_rx == 2'd0)
				begin
					count_rx <= count_rx + 2'd1;
					//SDA_OUT<=fifo_tx_data_out[8:8];
				end
				else if(count_rx   == 2'd1)
				begin
					count_rx <= count_tx + 2'd1;
					//SDA_OUT<=fifo_tx_data_out[16:16];
				end
				else if(count_rx == 2'd2)
				begin
					count_rx <= count_rx + 2'd1;
					//SDA_OUT<=fifo_tx_data_out[24:24];
				end
				else if(count_rx == 2'd3)
				begin
					count_rx <= 2'd0;
				end

				count_receive_data <= 12'd0;
			
			end


		end
		STOP:
		begin
			if(  count_receive_data < DATA_CONFIG_REG[13:2])
			begin
				  count_receive_data <=   count_receive_data + 12'd1;
			end
			else
			begin
				  count_receive_data <= 12'd0;
			end
			fifo_rx_wr_en <= 1'b0;
		end
		default:
		begin
			fifo_rx_wr_en <= 1'b0;
			  count_receive_data <= 12'd4095;
		end
		endcase
		
	end


end 

//USED ONLY TO COUNTER TIME
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		count_timeout <= 12'd0;
	end
	else
	begin
		if(count_timeout <= TIMEOUT_TX && state_tx == IDLE)
		begin
			if(SDA == 1'b0 && SCL == 1'b0)
			count_timeout <= count_timeout + 12'd1;
		end
		else
		begin
			count_timeout <= 12'd0;
		end

	end

end


endmodule
","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""indicator signal that shows if the FIFO receiver is empty"",
      ""RX_EMPTY"": ""output signal representing the empty status of the FIFO receiver""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the FIFO receiver empty indicator equals 1, then the FIFO receiver empty output equals 1 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""indicator signal that shows if the FIFO receiver is empty"",
      ""RX_EMPTY"": ""output signal representing the empty status of the FIFO receiver""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the FIFO receiver empty indicator equals 0, then the FIFO receiver empty output equals 0 from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""indicator signal that shows if the FIFO receiver is empty"",
      ""RX_EMPTY"": ""output signal representing the empty status of the FIFO receiver""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the FIFO receiver empty indicator equals 1, then the FIFO receiver empty output equals 1 from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0)"",
    ""Signals"": [
      ""fifo_rx_f_empty"",
      ""RX_EMPTY""
    ],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""indicator signal that shows if the FIFO receiver is empty"",
      ""RX_EMPTY"": ""output signal representing the empty status of the FIFO receiver""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the FIFO receiver empty indicator equals 0, then the FIFO receiver empty output equals 0 from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(DATA_CONFIG_REG[1] == 0) |-> (ERROR == 0)"",
    ""Signals"": [
      ""DATA_CONFIG_REG[1]"",
      ""ERROR""
    ],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[1]"": ""the second bit (bit 1) of the configuration register"",
      ""ERROR"": ""error indicator signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the second bit of the configuration register equals 0, then the error signal equals 0 from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(DATA_CONFIG_REG[0] == 0) |-> (ERROR == 0)"",
    ""Signals"": [
      ""DATA_CONFIG_REG[0]"",
      ""ERROR""
    ],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[0]"": ""the first bit (bit 0) of the configuration register"",
      ""ERROR"": ""error indicator signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the first bit of the configuration register equals 0, then the error signal equals 0 from the current clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge PCLK)"",
    ""disable condition"": """",
    ""logical expression"": ""(DATA_CONFIG_REG[0] == 1 & DATA_CONFIG_REG[1] == 1) |-> (ERROR == 1)"",
    ""Signals"": [
      ""DATA_CONFIG_REG[0]"",
      ""DATA_CONFIG_REG[1]"",
      ""ERROR""
    ],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[0]"": ""the first bit (bit 0) of the configuration register"",
      ""DATA_CONFIG_REG[1]"": ""the second bit (bit 1) of the configuration register"",
      ""ERROR"": ""error indicator signal""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the first bit of the configuration register equals 1 and the second bit of the configuration register equals 1, then the error signal equals 1 from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((fifo_rx_f_empty == 1'b1) |-> (RX_EMPTY == 1'b1));"",
""Assertion 2"": ""assert property ((fifo_rx_f_empty == 1'b0) |-> (RX_EMPTY == 1'b0)) @(posedge PCLK);"",
""Assertion 3"": ""assert property ((fifo_rx_f_empty == 1'b1) |-> (RX_EMPTY == 1'b1)) @(posedge PCLK);"",
""Assertion 4"": ""assert property (fifo_rx_f_empty == 1'b0 |-> RX_EMPTY == 1'b0);"",
""Assertion 5"": ""assert property (!DATA_CONFIG_REG[1] |-> (ERROR == 1'b0));"",
""Assertion 6"": ""assert property (!DATA_CONFIG_REG[0] |-> !ERROR);"",
""Assertion 7"": ""assert property ((DATA_CONFIG_REG[0] == 1'b1 && DATA_CONFIG_REG[1] == 1'b1) |-> (ERROR == 1'b1));""
}"
delay2,"module delay2 
#(
          parameter N = 750, 
          parameter CBITS = 10
) 
(input clk, input rst, output reg sig);
  reg [CBITS-1 :0] cnt;
  always @(posedge clk) begin
    if (rst) cnt = 0;
    else cnt = cnt + 1;
    if (cnt > N) begin sig = 1;
      cnt = 0; end
    else sig = 0;
  end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""s_eventually (rst || sig == 1)"",
    ""Signals"": [""rst"", ""sig""],
    ""Signal Explanations"": {
      ""rst"": ""reset signal of the verilog module"",
      ""sig"": ""output signal of the verilog module that indicates when the delay period is complete""
    },
    ""Logical Operators"": [""s_eventually"", ""||"", ""==""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
      ""||"": ""or"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""eventually, reset signal is asserted or output signal equals 1""
  }
}","{
""Assertion 1"": ""assert property (eventually (rst || sig == 1));""
}"
simple_req_ack,"module simple_req_ack (
	input  clk,
	input  rst_n,

	input  req,
	output ack
);
	logic req_ff, ack_ff;

	always_ff @(negedge rst_n, posedge clk)
		if (!rst_n)
			req_ff <= '0;
		else
			if (req_ff)
				req_ff <= '0;
			else
				req_ff <= req;

	always_ff @(negedge rst_n, posedge clk)
		if (!rst_n)
			ack_ff <= '0;
		else
		if (ack_ff)
			ack_ff <= '0;
		else
		if (req_ff)
			ack_ff <= '1;

	assign ack = ack_ff;

endmodule","{
""leaf_sv_files"": [],
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff(!rst_n)"",
""logical expression"": ""$rose(req) |-> ##2 $rose(ack)"",
""Signals"": [""req"", ""ack""],
""Signal Explanations"": {
  ""req"": ""request signal input of the verilog module"",
  ""ack"": ""acknowledge signal output of the verilog module""
},
""Logical Operators"": [""$rose"", ""|->"", ""##2""],
""Logical Operators Explanation"": {
  ""$rose"": ""a function that returns true if the referenced signal transitions from 0 to 1 in the current clock cycle"",
  ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
  ""##2"": ""a delay operator indicating that the condition following it should occur after 2 clock cycles""
},
""Assertion Explaination"": ""when request signal is detected to have a rising edge, then after a delay of 2 clock cycles the acknowledge signal is detected to have a rising edge""
}
}","{
""Assertion 1"": ""assert property ($rose(req) |-> ##2 $rose(ack));""
}"
Gray_Code_Counter,"module Gray_Code_Counter #(parameter
  DATA_WIDTH = 4
) (
  input clk,
  input resetn,
  output logic [DATA_WIDTH-1:0] out
);

reg  [DATA_WIDTH-1:0] bin_q;	
wire [DATA_WIDTH-1:0] bin_next;	
wire                  unused_bin_inc;
reg  [DATA_WIDTH-1:0] gray_q;	
wire [DATA_WIDTH-1:0] gray_next;	

always @(posedge clk)
begin
	if(~resetn) begin
		bin_q  <= {DATA_WIDTH{1'd1}};;
		gray_q <= {DATA_WIDTH{1'd0}};
	end else begin
		bin_q  <= bin_next;
		gray_q <= gray_next;
	end
end

assign { unused_bin_inc, bin_next } = bin_q + {DATA_WIDTH{1'd1}};
assign gray_next = bin_q ^ ( bin_q >> 1 );

assign out = gray_q;

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~resetn)"",
    ""logical expression"": ""unused_bin_inc | $onehot(gray_next ^ gray_q)"",
    ""Signals"": [
      ""unused_bin_inc"",
      ""gray_next"",
      ""gray_q""
    ],
    ""Signal Explanations"": {
      ""unused_bin_inc"": ""a signal representing the carry-out from the binary increment, which is not used in subsequent logic"",
      ""gray_next"": ""the next Gray code computed from the binary counter's value using Gray code conversion"",
      ""gray_q"": ""the current Gray code stored in the register""
    },
    ""Logical Operators"": [
      ""|"",
      ""$onehot"",
      ""^""
    ],
    ""Logical Operators Explanation"": {
      ""|"": ""OR operator that yields true if at least one of the operands is true"",
      ""$onehot"": ""a function that verifies that exactly one bit in its operand is set to 1"",
      ""^"": ""XOR operator returning 1 if the compared bits differ and 0 if they are the same""
    },
    ""Assertion Explaination"": ""there is only 1 bit difference between 2 consequtive gray code's or we have overflown""
  }
}","{
""Assertion 1"": ""assert property ($countones(gray_next) == $countones(gray_q) + 1);""
}"
uartTrans,"////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16


module uartTrans (clk, reset, sTick, txDoneTick, din, tx, txStart);

		parameter dataBits = `dataBits;
		parameter sbTick = `sbTick;
		
		input [dataBits-1 :0] din;
		input clk, reset, sTick, txStart;
		output tx, txDoneTick;
		
		reg txDoneTick;
		
/*
should be impleneted as a 4-state FSM : idle, start, data, stop;

*/

	localparam [1:0] idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11;
	
		reg [1:0] stateReg, stateNext;	// current and next states
		reg [3:0] sReg, sNext;		//	counter
		reg [2:0] nReg, nNext;		// counter
		reg [7:0] bReg, bNext;		// perhaps keeps data to be sent
		reg		 txReg, txNext;	// current bit being transferred
		
		
		//	reset and non-reset conditions:
		
		always @ (posedge clk or posedge reset)
		begin
			if (reset)
			begin
				stateReg <= idle;
				sReg <= 1'b0;
				bReg <= 1'b0;
				nReg <= 1'b0;
				txReg <= 1'b1;
			end	// end if
			
			else
			begin
				stateReg <= stateNext;
				sReg <= sNext;
				bReg <= bNext;
				nReg <= nNext;
				txReg <= txNext;
			end	// end else
		
		end	// end always
		
		// FSM:
		
		always @ *
		begin
				stateNext = stateReg;
				sNext = sReg;
				bNext = bReg;
				nNext = nReg;
				txNext = txReg;
				
				txDoneTick = 1'b0;		// not done yet!
				
			case	(stateReg)
			
				idle	:	begin
								txNext = 1'b1;	// start bit '0'; thus, send '1' in idle
								
								if (txStart)
								begin
									txDoneTick = 1'b1;	// generate rd for fifo **
									stateNext = start;	// should go into start state
									sNext = 0;
								end	// end if txStart
							// in idle state unless txStart...
							end	// end idle case
							
				start	:	begin
								txNext = 0;
								txDoneTick = 1'b0;		// **
								bNext = din;		// take din into bReg
								if (sTick)
									if (sReg == 15)
									begin
										stateNext = data;
										sNext = 1'b0;
										nNext = 1'b0;
									end	// end if sReg==15
									
									else
										sNext = sReg + 1;	// keep incrementing sNext (sReg)
										// sReg = sNext on each clk edge !!
							end	// end start case
							
				data	:	begin
								txNext = bReg[0];	// keep sending LSB of bReg
								
								if (sTick)
									if (sReg == 15)
									begin
										sNext = 0;	// reset counter
										bNext = bReg >> 1;	// shift word to be sent
										
										if (nReg == (dataBits-1))
											stateNext = stop;
										else
											nNext = nReg +1;
									end	// end if sReg==15
								else
									sNext = sReg + 1;
				
							end	// end data state
							
				stop	:	begin
								txNext = 1'b1;
								
								if (sTick)
									if (sReg == sbTick-1)
									begin
										stateNext = idle;
										//txDoneTick = 1'b1; it's working as read signal to
										// fifo, so, used at starting . . .
									end //end if sReg==15
									else
										sNext = sReg + 1;
							end	// end stop state
			
			endcase
		
		end	// end always combinatorial

		
		// output bit-stream
		
		assign tx = txReg;

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(txNext == 0) |=> (tx == 0)"",
    ""Signals"": [
      ""txNext"",
      ""tx""
    ],
    ""Signal Explanations"": {
      ""txNext"": ""next value of the transmit register; this signal holds the value that will update the transmit register in the next clock cycle"",
      ""tx"": ""transmit bit‐stream output signal; this is the actual serial output of the UART transmitter""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the signal holding the next value of the transmit register is equal to 0, then the transmit bit-stream output should be equal to 0 from the next clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(txNext == 1) |=> (tx == 1)"",
    ""Signals"": [
      ""txNext"",
      ""tx""
    ],
    ""Signal Explanations"": {
      ""txNext"": ""next value of the transmit register; this signal holds the value that will update the transmit register in the next clock cycle"",
      ""tx"": ""transmit bit‐stream output signal; this is the actual serial output of the UART transmitter""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the signal holding the next value of the transmit register is equal to 1, then the transmit bit-stream output should be equal to 1 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(stateReg[0] == 1) |-> (txDoneTick == 0)"",
    ""Signals"": [
      ""stateReg[0]"",
      ""txDoneTick""
    ],
    ""Signal Explanations"": {
      ""stateReg[0]"": ""the least significant bit of the current state register, representing a particular state condition in the FSM"",
      ""txDoneTick"": ""transmit done tick signal that indicates completion of a transmit cycle""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the first bit of the current state register is equal to 1, then the transmit done tick signal should be equal to 0 from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(txStart == 0) |-> (txDoneTick == 0)"",
    ""Signals"": [
      ""txStart"",
      ""txDoneTick""
    ],
    ""Signal Explanations"": {
      ""txStart"": ""transmit start signal that indicates the initiation of a transmission"",
      ""txDoneTick"": ""transmit done tick signal that indicates completion of a transmit cycle""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the transmit start signal is equal to 0, then the transmit done tick signal should be equal to 0 from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (txNext == 0 |=> tx == 0);"",
""Assertion 2"": ""assert property ((txNext == 1) |=> (tx == 1));"",
""Assertion 3"": ""assert property ((stateReg[0] == 1'b1) |-> (txDoneTick == 1'b0));"",
""Assertion 4"": ""assert property (txStart == 1'b0 |-> txDoneTick == 1'b0);""
}"
i2c,"module i2c #(parameter divider = 125, parameter CBITS = 9) (input clk, input rst, input scl_not_ena, output reg data_clk);
	reg [CBITS - 1:0] cnt;	//0 to 4*divider
	reg scl_clk;
	reg stretch;
	always @(posedge clk) begin
		if(rst == 1) begin
			stretch = 0;
			cnt = 0;
		end
		if(cnt >= divider*4 - 1)
			cnt = 0;
		else if(stretch == 0)
			cnt = cnt + 1;

		if( cnt <= divider - 1) begin
			scl_clk = 0;
			data_clk = 0;
		end
		else if( divider <= cnt && cnt <= 2*divider - 1) begin
			scl_clk = 0;
			data_clk = 1;
		end
		else if( 2*divider <= cnt && cnt <= 3*divider - 1) begin
			if(scl_clk == 0 & scl_not_ena == 0)
				stretch = 1;
			else
				stretch = 0;
			scl_clk = 1;
			data_clk = 1;
		end
		else begin
			scl_clk = 1;
			data_clk = 0;
		end
	end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""s_eventually rst == 1 || scl_not_ena == 1 || stretch == 1"",
    ""Signals"": [
      ""rst"",
      ""scl_not_ena"",
      ""stretch""
    ],
    ""Signal Explanations"": {
      ""rst"": ""reset signal"",
      ""scl_not_ena"": ""input signal indicating that scl is not enabled"",
      ""stretch"": ""internal signal that indicates if clock stretching is occurring""
    },
    ""Logical Operators"": [
      ""s_eventually"",
      ""=="",
      ""||""
    ],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
      ""=="": ""equal"",
      ""||"": ""or""
    },
    ""Assertion Explaination"": ""eventually, reset signal equals 1 or input signal indicating that scl is not enabled equals 1 or internal signal that indicates if clock stretching is occurring equals 1""
  }
}","{
""Assertion 1"": ""assert property (   @(posedge clk)     eventually ( rst == 1 || scl_not_ena == 1 || stretch == 1 ) );""
}"
uartRec,"////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16


module uartRec(clk, reset, sTick, rx, rxDoneTick, dOut);

		parameter dataBits = `dataBits;
		parameter sbTick = `sbTick;
		
		input clk, reset, sTick, rx;
		output rxDoneTick;
		output [dataBits-1:0] dOut;
		
		reg rxDoneTick;
		// states:
		
	localparam idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11;
	
		reg [1:0] stateReg, stateNext;	// current and next states
		reg [3:0] sReg, sNext;		//	counter
		reg [2:0] nReg, nNext;		// counter
		reg [7:0] bReg, bNext;		// data recieved in this..
		
		
		always @ (posedge clk or posedge reset)
		begin
			if (reset)
			begin
				stateReg <= idle;
				sReg <= 1'b0;
				bReg <= 1'b0;
				nReg <= 1'b0;
			end	// end if
			
			else
			begin
				stateReg <= stateNext;
				sReg <= sNext;
				bReg <= bNext;
				nReg <= nNext;
			end	// end else
		
		end	// end always
		
		
		
		// FSM next state logic:
		
		always @ *
		begin
		
				stateNext = stateReg;
				sNext = sReg;
				bNext = bReg;
				nNext = nReg;
				rxDoneTick = 1'b0;
				
			case (stateReg)
			
			idle	:	if (~rx)
						begin
							stateNext = start;	// start when rx is activated
							sNext = 0;	// initialize sampling counter
						end	// end if rx
						
			start	:	if (sTick)
							if (sReg == 7)
							begin
								stateNext = data;		// at middle of oversampled start
													// bit, go to data state
								sNext = 0;
								nNext = 0;
							end	// end if sReg==7
							
							else
								sNext = sReg + 1;	// otherwise keep increment sReg upto 7
			
			data	:	if (sTick)
							if (sReg == 15)	// if reached middle of next bit
							begin
								sNext = 0;	// reset counter
								bNext = {rx, bReg[7:1]};	// LSB first, and the
														//data recieved in bReg
								if (nReg == (dataBits-1))	// if all data recvd,
									stateNext = stop;	// go to stop bit(s) state
								else
									nNext = nReg + 1;
							end	// end if sReg==15
							
							else
								sNext = sReg + 1;	// otherwise keep increment sReg upto 15
							
			stop	:	if (sTick)
							if (sReg == (sbTick-1))
							begin
								stateNext = idle;		// done reception, go to idle state
								rxDoneTick = 1'b1;	// raise done tick!
							end	// end if sReg==sbTick-1
							
							else
								sNext = sReg + 1;		// otherwise keep increment sReg 
															//upto (sbTick-1)
			endcase
		
		end	// end always combinatorial
		
		
		// recvd data output
		
		assign dOut = bReg;


endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(stateReg[0] == 0) |-> (rxDoneTick == 0)"",
    ""Signals"": [
      ""stateReg"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""stateReg"": ""current state register of the UART FSM"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the least significant bit of the current state register is 0, then the flag indicating UART reception completion must be 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sReg[2] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sReg"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sReg"": ""current sampling counter register in the UART receiver"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the third bit of the sampling counter is 0, then the UART reception done flag must be 0 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sReg[1] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sReg"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sReg"": ""current sampling counter register in the UART receiver"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the second bit of the sampling counter is 0, then the UART reception done flag signal must be 0 from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(nReg[1] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""nReg"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""nReg"": ""current bit counter register tracking the number of received data bits"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the second bit of the bit counter is 0, then the UART reception done flag signal must be 0 from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(nReg[0] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""nReg"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""nReg"": ""current bit counter register tracking the number of received data bits"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the least significant bit of the bit counter is 0, then the UART reception done flag signal must be 0 from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sTick == 0) |-> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sTick"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sTick"": ""the sampling tick signal used to trigger sampling in the UART receiver"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the sampling tick signal is 0, then the UART reception done flag signal must be 0 from the next clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""(sNext[0] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [
      ""sNext"",
      ""rxDoneTick""
    ],
    ""Signal Explanations"": {
      ""sNext"": ""next value of the sampling counter register"",
      ""rxDoneTick"": ""flag indicating that UART reception is completed""
    },
    ""Logical Operators"": [
      ""=="",
      ""|=>""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""when the first bit of the next sampling counter value is 0, then the UART reception done flag signal must be 0 from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property (!stateReg[0] |-> !rxDoneTick);"",
""Assertion 2"": ""assert property (!sReg[3] |-> ##1 !rxDoneTick);"",
""Assertion 3"": ""assert property ((sReg[2] == 1ʼb0) |=> (rxDoneTick == 1ʼb0));"",
""Assertion 4"": ""assert property ((nReg[2] == 1'b0) |-> ##1 (rxDoneTick == 1'b0));"",
""Assertion 5"": ""assert property ((nReg[0] == 0) |=> (rxDoneTick == 0));"",
""Assertion 6"": ""assert property ((!sTick) |=> (!rxDoneTick)) @(posedge clk);"",
""Assertion 7"": ""assert property ((sNext[0] == 1ʼb0) |=> (rxDoneTick == 1ʼb0));""
}"
APB_FSM_Controller,"
// AHB to APG Bridge | Maven Silicon
//
//
//
// APB FSM Controller
// Date:08-06-2022
//
// By-Prajwal Kumar Sahu

module APB_FSM_Controller( Hclk,Hresetn,valid,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata,Hwrite,Haddr,Hwdata,Hwritereg,tempselx, 
			   Pwrite,Penable,Pselx,Paddr,Pwdata,Hreadyout);

input Hclk,Hresetn,valid,Hwrite,Hwritereg;
input [31:0] Hwdata,Haddr,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata;
input [2:0] tempselx;
output reg Pwrite,Penable;
output reg Hreadyout;  
output reg [2:0] Pselx;
output reg [31:0] Paddr,Pwdata;

//////////////////////////////////////////////////////PARAMETERS

parameter ST_IDLE=3'b000;
parameter ST_WWAIT=3'b001;
parameter ST_READ= 3'b010;
parameter ST_WRITE=3'b011;
parameter ST_WRITEP=3'b100;
parameter ST_RENABLE=3'b101;
parameter ST_WENABLE=3'b110;
parameter ST_WENABLEP=3'b111;


//////////////////////////////////////////////////// PRESENT STATE LOGIC

reg [2:0] PRESENT_STATE,NEXT_STATE;

always @(posedge Hclk)
 begin:PRESENT_STATE_LOGIC
  if (~Hresetn)
    PRESENT_STATE<=ST_IDLE;
  else
    PRESENT_STATE<=NEXT_STATE;
 end


/////////////////////////////////////////////////////// NEXT STATE LOGIC

always @(PRESENT_STATE,valid,Hwrite,Hwritereg)
 begin:NEXT_STATE_LOGIC
  case (PRESENT_STATE)
    
 	ST_IDLE:begin
		 if (~valid)
		  NEXT_STATE=ST_IDLE;
		 else if (valid && Hwrite)
		  NEXT_STATE=ST_WWAIT;
		 else 
		  NEXT_STATE=ST_READ;
		end    

	ST_WWAIT:begin
		 if (~valid)
		  NEXT_STATE=ST_WRITE;
		 else
		  NEXT_STATE=ST_WRITEP;
		end

	ST_READ: begin
		   NEXT_STATE=ST_RENABLE;
		 end

	ST_WRITE:begin
		  if (~valid)
		   NEXT_STATE=ST_WENABLE;
		  else
		   NEXT_STATE=ST_WENABLEP;
		 end

	ST_WRITEP:begin
		   NEXT_STATE=ST_WENABLEP;
		  end

	ST_RENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLEP:begin
		      if (~valid && Hwritereg)
		       NEXT_STATE=ST_WRITE;
		      else if (valid && Hwritereg)
		       NEXT_STATE=ST_WRITEP;
		      else
		       NEXT_STATE=ST_READ;
		    end

	default: begin
		   NEXT_STATE=ST_IDLE;
		  end
  endcase
 end


////////////////////////////////////////////////////////OUTPUT LOGIC:COMBINATIONAL

reg Penable_temp,Hreadyout_temp,Pwrite_temp;
reg [2:0] Pselx_temp;
reg [31:0] Paddr_temp, Pwdata_temp;

always @(*)
 begin:OUTPUT_COMBINATIONAL_LOGIC
   case(PRESENT_STATE)
    
	ST_IDLE: begin
			  if (valid && ~Hwrite) 
			   begin:IDLE_TO_READ
			        Paddr_temp=Haddr;
				Pwrite_temp=Hwrite;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Hreadyout_temp=0;
			   end
			  
			  else if (valid && Hwrite)
			   begin:IDLE_TO_WWAIT
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;			   
			   end
			   
			  else
                            begin:IDLE_TO_IDLE
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;	
			   end
		     end    

	ST_WWAIT:begin
	          if (~valid) 
			   begin:WAIT_TO_WRITE
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Pwdata_temp=Hwdata;
				Hreadyout_temp=0;
			   end
			  
			  else 
			   begin:WAIT_TO_WRITEP
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Pwdata_temp=Hwdata;
				Penable_temp=0;
				Hreadyout_temp=0;		   
			   end
			   
		     end  

	ST_READ: begin:READ_TO_RENABLE
			  Penable_temp=1;
			  Hreadyout_temp=1;
		     end

	ST_WRITE:begin
              if (~valid) 
			   begin:WRITE_TO_WENABLE
				Penable_temp=1;
				Hreadyout_temp=1;
			   end
			  
			  else 
			   begin:WRITE_TO_WENABLEP ///DOUBT
				Penable_temp=1;
				Hreadyout_temp=1;		   
			   end
		     end

	ST_WRITEP:begin:WRITEP_TO_WENABLEP
               Penable_temp=1;
			   Hreadyout_temp=1;
		      end

	ST_RENABLE:begin
	            if (valid && ~Hwrite) 
				 begin:RENABLE_TO_READ
					Paddr_temp=Haddr;
					Pwrite_temp=Hwrite;
					Pselx_temp=tempselx;
					Penable_temp=0;
					Hreadyout_temp=0;
				 end
			  
			  else if (valid && Hwrite)
			    begin:RENABLE_TO_WWAIT
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;			   
			    end
			   
			  else
                begin:RENABLE_TO_IDLE
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;	
			    end

		       end

	ST_WENABLEP:begin
                 if (~valid && Hwritereg) 
			      begin:WENABLEP_TO_WRITEP
			       Paddr_temp=Haddr2;
				   Pwrite_temp=Hwrite;
				   Pselx_temp=tempselx;
				   Penable_temp=0;
				   Pwdata_temp=Hwdata;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLEP_TO_WRITE_OR_READ /////DOUBT
			      Paddr_temp=Haddr2;
				  Pwrite_temp=Hwrite;
				  Pselx_temp=tempselx;
				  Pwdata_temp=Hwdata;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end
		        end

	ST_WENABLE :begin
	             if (~valid && Hwritereg) 
			      begin:WENABLE_TO_IDLE
				   Pselx_temp=0;
				   Penable_temp=0;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLE_TO_WAIT_OR_READ /////DOUBT
				  Pselx_temp=0;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end

		        end

 endcase
end


////////////////////////////////////////////////////////OUTPUT LOGIC:SEQUENTIAL

always @(posedge Hclk)
 begin
  
  if (~Hresetn)
   begin
    Paddr<=0;
	Pwrite<=0;
	Pselx<=0;
	Pwdata<=0;
	Penable<=0;
	Hreadyout<=0;
   end
  
  else
   begin
        Paddr<=Paddr_temp;
	Pwrite<=Pwrite_temp;
	Pselx<=Pselx_temp;
	Pwdata<=Pwdata_temp;
	Penable<=Penable_temp;
	Hreadyout<=Hreadyout_temp;
   end
 end
 ///////////////////////


endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""1 |-> ##2 PRESENT_STATE == $past(NEXT_STATE)"",
    ""Signals"": [""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""|->"", ""##2"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""##2"": ""a delay operator meaning that the condition on the right is evaluated 2 clock cycles later"",
      ""=="": ""equal"",
      ""$past"": ""the value from previous clock cycle(s)""
    },
    ""Assertion Explaination"": ""Property to verify that after 2 clock cycles the current state of the FSM equals the previous value of the next state of the FSM""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""(PRESENT_STATE == ST_IDLE && valid && Hwrite) |-> (NEXT_STATE == ST_WWAIT)"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_IDLE that when the current state of the FSM equals ST_IDLE, transaction is valid, and a write operation is active, then the next state of the FSM equals ST_WWAIT wait from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_IDLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_IDLE that when the current state of the FSM equals ST_IDLE, transaction is valid, and the write operation is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_IDLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_IDLE that when the current state of the FSM equals ST_IDLE and transaction is not valid, then the next state of the FSM equals ST_IDLE from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WWAIT && !valid |-> NEXT_STATE == ST_WRITE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WWAIT that when the current state of the FSM equals ST_WWAIT and transaction is not valid, then the next state of the FSM equals ST_WRITE from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WWAIT && valid |-> NEXT_STATE == ST_WRITEP"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WWAIT that when the current state of the FSM equals ST_WWAIT and transaction is valid, then the next state of the FSM equals ST_WRITEP from the currect clock cycle""

  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE"",
    ""Signals"": [""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_READ that when the current state of the FSM equals ST_READ, then the next state of the FSM equals ST_RENABLE from the current clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITE && !valid |-> NEXT_STATE == ST_WENABLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WRITE that when the current state of the FSM equals ST_WRITE and transaction is not valid, then the next state of the FSM equals ST_WENABLE from the current clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITE && valid |-> NEXT_STATE == ST_WENABLEP"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WRITE that when the current state of the FSM equals ST_WRITE and transaction is valid, then the next state of the FSM equals ST_WENABLEP from the current clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP"",
    ""Signals"": [""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WRITEP that when the current state of the FSM equals ST_WRITEP, then the next state of the FSM equals ST_WENABLEP from the current clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_RENABLE that when the current state of the FSM equals ST_RENABLE and transaction is not valid, then the next state of the FSM equals ST_IDLE from the current clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_RENABLE that when the current state of the FSM equals ST_RENABLE, and transaction is valid, and a write operation is active, then the next state of the FSM equals ST_WWAIT from the current clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_RENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_RENABLE that when the current state of the FSM equals ST_RENABLE, and transaction is valid, and the write operation is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && !valid |-> NEXT_STATE == ST_IDLE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLE that when the current state of the FSM equals ST_WENABLE and transaction is not valid, then the next state of the FSM equals ST_IDLE from the current clock cycle""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLE that when the current state of the FSM equals ST_WENABLE, and transaction is valid, and a write operation is active, then the next state of the FSM equals ST_WWAIT from the current clock cycle""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwrite"": ""a signal indicating a write operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLE that when the current state of the FSM equals ST_WENABLE, transaction is valid, and the write operation is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  },
  ""Assertion 17"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && !valid && Hwritereg |-> NEXT_STATE == ST_WRITE"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwritereg"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwritereg"": ""a control signal for write register operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLEP that when the current state of the FSM equals ST_WENABLEP, and transaction is not valid, and the write register control is active, then the next state of the FSM equals ST_WRITE from the current clock cycle""
  },
  ""Assertion 18"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && valid && Hwritereg |-> NEXT_STATE == ST_WRITEP"",
    ""Signals"": [""PRESENT_STATE"", ""valid"", ""Hwritereg"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""valid"": ""a signal indicating transaction validity"",
      ""Hwritereg"": ""a control signal for write register operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLEP that when the current state of the FSM equals ST_WENABLEP, and transaction is valid, and the write register control is active, then the next state of the FSM equals ST_WRITEP from the current clock cycle""
  },
  ""Assertion 19"": {
    ""clock signal condition"": ""@(posedge Hclk)"",
    ""disable condition"": ""disable iff (!Hresetn)"",
    ""logical expression"": ""PRESENT_STATE == ST_WENABLEP && !Hwritereg |-> NEXT_STATE == ST_READ"",
    ""Signals"": [""PRESENT_STATE"", ""Hwritereg"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""PRESENT_STATE"": ""the current state of the FSM"",
      ""Hwritereg"": ""a control signal for write register operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM""
    },
    ""Logical Operators"": [""=="", ""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""&&"": ""logical AND"",
      ""!"": ""the value of a signal is reset (0)"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE""
    },
    ""Assertion Explaination"": ""Property to verify the transition from ST_WENABLEP that when the current state of the FSM equals ST_WENABLEP and the write register control is not active, then the next state of the FSM equals ST_READ from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (##2 (PRESENT_STATE == $past(NEXT_STATE)));"",
""Assertion 2"": ""assert property ((PRESENT_STATE == ST_IDLE && valid && Hwrite) |-> ##1 (PRESENT_STATE == ST_WWAIT));"",
""Assertion 3"": ""assert property ((PRESENT_STATE == ST_IDLE && valid && !Hwrite) |-> ##1 (PRESENT_STATE == ST_READ));"",
""Assertion 4"": ""assert property ((PRESENT_STATE == ST_IDLE && !valid) |-> (NEXT_STATE == ST_IDLE));"",
""Assertion 5"": ""assert property ((PRESENT_STATE == ST_WWAIT && !valid) |-> (NEXT_STATE == ST_WRITE));"",
""Assertion 6"": ""assert property ((PRESENT_STATE == ST_WWAIT && valid) |-> (NEXT_STATE == ST_WRITEP));"",
""Assertion 7"": ""assert property ((PRESENT_STATE == ST_READ) |-> (NEXT_STATE == ST_RENABLE));"",
""Assertion 8"": ""assert property ((PRESENT_STATE == ST_WRITE && !valid) |-> (NEXT_STATE == ST_WENABLE));"",
""Assertion 9"": ""assert property ( ((PRESENT_STATE == ST_WRITE) && valid) |-> (NEXT_STATE == ST_WENABLEP) );"",
""Assertion 10"": ""assert property (@(posedge Hclk) (PRESENT_STATE == ST_WRITEP) |-> (NEXT_STATE == ST_WENABLEP));"",
""Assertion 11"": ""assert property ((PRESENT_STATE == ST_RENABLE && !valid) |-> (NEXT_STATE == ST_IDLE));"",
""Assertion 12"": ""assert property ((PRESENT_STATE == ST_RENABLE && valid && Hwrite) |-> NEXT_STATE == ST_WWAIT);"",
""Assertion 13"": ""assert property ((PRESENT_STATE == ST_RENABLE && valid && !Hwrite) |-> (NEXT_STATE == ST_READ));"",
""Assertion 14"": ""assert property ((PRESENT_STATE == ST_WENABLE && !valid) |-> ##1 (PRESENT_STATE == ST_IDLE));"",
""Assertion 15"": ""assert property (     (PRESENT_STATE == ST_WENABLE && valid && Hwrite)   |-> (NEXT_STATE     == ST_WWAIT) );"",
""Assertion 16"": ""assert property ((PRESENT_STATE == ST_WENABLE && valid && !Hwrite) |-> (PRESENT_STATE == ST_READ));"",
""Assertion 17"": ""assert property ((PRESENT_STATE == ST_WENABLEP && !valid && Hwritereg) |-> (NEXT_STATE == ST_WRITE));"",
""Assertion 18"": ""assert property ((PRESENT_STATE == ST_WENABLEP && valid && Hwritereg) |-> (NEXT_STATE == ST_WRITEP));"",
""Assertion 19"": ""assert property ((PRESENT_STATE == ST_WENABLEP && !Hwritereg) |-> (NEXT_STATE == ST_READ));""
}"
register,"module register
  #(
    parameter WIDTH=8
    )
   (
    input logic              clk,
    input logic              rst,
    input logic              en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );
   
   always_ff @(posedge clk or posedge rst) begin
      if (rst)
        out <= '0;
      else if (en)
        out <= in;      
   end 
   
endmodule
","{
""leaf_sv_files"": [],    
""Assertion 1"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""en |=> out == $past(in,1)"",
""Signals"": [""en"", ""out"", ""in""],
""Signal Explanations"": {
          ""en"": ""enable signal"",
          ""out"": ""output signal of the verilog module"",
          ""in"": ""input signal of the verilog module""
},
""Logical Operators"": [""|=>"", ""=="", ""$past""],
""Logical Operators Explanation"": {
          ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE"",
          ""=="": ""equal"",
          ""$past"": ""the last one clock cycle's value""
},
""Assertion Explaination"": ""when enable signal is set (1), output signal equals the last one clock cycle's input signal from the next clock cycle""
},
""Assertion 2"": {
""clock signal condition"": ""@(posedge clk)"",
""disable condition"": ""disable iff (rst)"",
""logical expression"": ""!en |=> out == $past(out,1)"",
""Signals"": [""en"", ""out""],
""Signal Explanations"": {
          ""en"": ""enable signal"",
          ""out"": ""output signal of the verilog module""
},
""Logical Operators"": [""!"", ""|=>"", ""=="", ""$past""],
""Logical Operators Explanation"": {
          ""!"": ""the value of a signal is reset (0)"",
          ""|=>"": ""a non-overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE NEXT CLOCK CYCLE"",
          ""=="": ""equal"",
          ""$past"": ""the last one clock cycle's value""
},
""Assertion Explaination"": ""when enable signal is reset (0), output signal equals the last one clock cycle's output signal from the next clock cycle""
}
}","{
""Assertion 1"": ""assert property (en |-> (out == $past(in))) @(posedge clk);"",
""Assertion 2"": ""assert property ((!en) |-> (out == $past(out))) @(posedge clk);""
}"
SEVEN,"module SEVEN #(parameter freq = 250, parameter CBITS = 8) (input clk, input rst, input [13:0] both7seg, output reg[6:0] segment);
	reg [CBITS-1:0] cnt;
	reg digit_select;

	always @(posedge clk) begin
		if(rst == 1) begin
			cnt = 0;
			digit_select = 0;
			segment = 0;
		end
		if(cnt < freq)
			cnt = cnt + 1;
		else begin
			cnt = 0;
			if(digit_select == 0) begin
				digit_select = 1;
				segment = both7seg[13:7];
			end
			else begin
				digit_select = 0;
				segment = both7seg[6:0];
			end
		end
	end
endmodule","{
""leaf_sv_files"": [],
""Assertion 1"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""s_eventually rst == 1 || digit_select == 1"",
  ""Signals"": [""rst"", ""digit_select""],
  ""Signal Explanations"": {
    ""rst"": ""reset signal for the module"",
    ""digit_select"": ""digit selection register that toggles between the two seven-segment digits""
  },
  ""Logical Operators"": [""s_eventually"", ""=="", ""||"", ""==""],
  ""Logical Operators Explanation"": {
    ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
    ""=="": ""equal"",
    ""||"": ""or""
  },
  ""Assertion Explaination"": ""there exists a current or future clock tick at which reset signal equals 1 or digit selection register equals 1""
},
""Assertion 2"": {
  ""clock signal condition"": ""@(posedge clk)"",
  ""disable condition"": """",
  ""logical expression"": ""s_eventually rst == 1 || digit_select == 0"",
  ""Signals"": [""rst"", ""digit_select""],
  ""Signal Explanations"": {
    ""rst"": ""reset signal for the module"",
    ""digit_select"": ""digit selection register that toggles between the two seven-segment digits""
  },
  ""Logical Operators"": [""s_eventually"", ""=="", ""||"", ""==""],
  ""Logical Operators Explanation"": {
    ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
    ""=="": ""equal"",
    ""||"": ""or""
  },
  ""Assertion Explaination"": ""eventually, reset signal equals 1 or digit selection register equals 0""
}
}","{
""Assertion 1"": ""assert property (@(posedge clk) ##[0:$] (rst == 1 || digit_select == 1));"",
""Assertion 2"": ""assert property (s_eventually(rst == 1 || digit_select == 0)) @(posedge clk);""
}"
arbiter,"//EE382M-Verification of Digital Systems
//Lab 4 - Formal Property Verification
//
//
//Module - PNSeqGen
//Pseudo-random pattern generator

module PNSeqGen(
  input        clk,
  input        rst_n,
  output [1:0] rand_out
  );

reg s1, s2, s3;
wire s0;

assign s0 = s1 ^ s3;

always @ (posedge clk or negedge rst_n) begin
  if(!rst_n) begin
   s1 <= 1;
   s2 <= 0;
   s3 <= 0;
  end else begin   
   s1 <= s0;
   s2 <= s1;
   s3 <= s2;
  end
end

assign rand_out = {s3,s2};

endmodule

module arbiter(
  clk,
  rst_n,
  req,
  arb_type,
  gnt
  );

// Input and Output ports
input        clk;
input        rst_n;
input  [3:0] req;
input  [2:0] arb_type;

output [3:0] gnt;

// Internal variables
wire [3:0] req;

reg  [3:0] r_gnt_p0; // P0 priority scheme output
reg  [3:0] r_gnt_p1; // P1 priority scheme output
reg  [3:0] r_gnt_p2; // P2 priority scheme output
reg  [3:0] r_gnt_p3; // P3 priority scheme output
reg  [3:0] r_gnt_rr; // Prr: Round robin arbitration scheme output
reg  [3:0] r_gnt_px; // Prand: Random arbitration scheme output
reg  [3:0] r_gnt;

wire [1:0] rand_out;
wire [1:0] r_gnt_rr_encoded;

assign gnt   = r_gnt;

// P0 Fixed Priority req[0]
always @(*) begin
  if(req[0])
    r_gnt_p0 = 4'b0001;
  else if(req[1])
    r_gnt_p0 = 4'b0010;
  else if(req[2])
    r_gnt_p0 = 4'b0100;
  else if(req[3])
    r_gnt_p0 = 4'b1000; // Saqib changed this from r_gnt_p0 = 4'b0000;
  else
    r_gnt_p0 = 4'b0000;
end

// P1 Fixed Priority req[1]
always @(*) begin
  if(req[1])
    r_gnt_p1 = 4'b0010;
  else if(req[0])
    r_gnt_p1 = 4'b0001;
  else if(req[2])
    r_gnt_p1 = 4'b0100;
  else if(req[3])
    r_gnt_p1 = 4'b1000;
  else
    r_gnt_p1 = 4'b0000;
end

// P2 Fixed Priority req[2]
always @(*) begin
  if(req[2])
    r_gnt_p2 = 4'b0100;
  else if(req[0])
    r_gnt_p2 = 4'b0001;
  else if(req[1])
    r_gnt_p2 = 4'b0010;
  else if(req[3])
    r_gnt_p2 = 4'b1000;
  else
    r_gnt_p2 = 4'b0000;
end

// P3 Fixed Priority req[3]
always @(*) begin
  if(req[3])
    r_gnt_p3 = 4'b1000;
  else if(req[0])
    r_gnt_p3 = 4'b0001;
  else if(req[1])
    r_gnt_p3 = 4'b0010;
  else if(req[2])
    r_gnt_p3 = 4'b0100;
  else
    r_gnt_p3 = 4'b0000;
end

// Prr: Round robin arbiter
always @ (*) begin
  r_gnt_rr[0] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & req[0]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & req[0]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & req[0]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & ~req[1] & req[0]) ;

  r_gnt_rr[1] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & req[1]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[0] & req[1]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[3] & ~req[2] & ~req[0] & req[1]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & req[1]) ;
  
  r_gnt_rr[2] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & ~req[1] & req[2]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[3] & ~req[0] & ~req[1] & req[2]) |  // Saqib changed req[1] to ~req[1]
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & req[2]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[1] & req[2]) ;
 
  r_gnt_rr[3] = 
    (r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[0] & ~req[1] & ~req[2] & req[3]) |
    (r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & req[3]) |
    (~r_gnt_rr_encoded[1] & r_gnt_rr_encoded[0] & ~req[2] & req[3]) |
    (~r_gnt_rr_encoded[1] & ~r_gnt_rr_encoded[0] & ~req[1] & ~req[2] & req[3]) ;
end

// encode the 4b r_gnt_rrs to 2b
assign r_gnt_rr_encoded = {r_gnt[3] | r_gnt[2], r_gnt[3] | r_gnt[1]};

// Prand: Random arbitration
PNSeqGen u_PNSeqGen ( .clk(clk), .rst_n(rst_n), .rand_out(rand_out) );

always @(*) begin
  case(rand_out)

  2'b00: begin
    if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end
  
  2'b01: begin
    if(req[1])
      r_gnt_px = 4'b0010;  // Saqib change 4'b0001 to 4'b0010
    else if(req[0])
      r_gnt_px = 4'b0001;  // Saqib change 4'b0010 to 4'b0001
    else if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end

  2'b10: begin
    if(req[2])
      r_gnt_px = 4'b0100;
    else if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[3])
      r_gnt_px = 4'b1000;
    else
      r_gnt_px = 4'b0000;
  end

  2'b11: begin
    if(req[3])
      r_gnt_px = 4'b1000;
    else if(req[0])
      r_gnt_px = 4'b0001;
    else if(req[1])
      r_gnt_px = 4'b0010;
    else if(req[2])
      r_gnt_px = 4'b0100;
    else
      r_gnt_px = 4'b0000;
  end

  endcase
end

// Priority selection
always @(posedge clk or negedge rst_n)
begin
  if(!rst_n)
    r_gnt <= 4'b0000;
  else
    case(arb_type)
      4'b0000: r_gnt <= r_gnt_p0;
      4'b0001: r_gnt <= r_gnt_p1;
      4'b0010: r_gnt <= r_gnt_p2;
      4'b0011: r_gnt <= r_gnt_p3;
      4'b0100: r_gnt <= r_gnt_rr;
      4'b0101: r_gnt <= r_gnt_px;
      default: r_gnt <= 4'b0000;
    endcase
end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd0)) |-> $past(req[0])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the first bit of request input signal must be asserted from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd0)) |-> $past(req[1] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the second bit of request input signal must be asserted and the first bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd0)) |-> $past(req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the third bit of request input signal must be asserted and the first and second bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd0)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 0, then in the previous clock cycle the fourth bit of request input signal must be asserted and the first, second, and third bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd1)) |-> $past(req[0] & ~req[1])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[1]"": ""request input signal for request 1""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the first bit of request input signal must be asserted and the second bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd1)) |-> $past(req[1])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the second bit of request input signal must be asserted from the current clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd1)) |-> $past(req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the third bit of request input signal must be asserted and the first and second bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd1)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 1, then in the previous clock cycle the fourth bit of request input signal must be asserted and the third, second and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd2)) |-> $past(req[0] & ~req[2])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[2]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[2]"": ""request input signal for request 2""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the first bit of request input signal must be asserted and the third bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd2)) |-> $past(req[1] & ~req[2] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[2]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the second bit of request input signal must be asserted and the third and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd2)) |-> $past(req[2])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the third bit of request input signal must be asserted from the current clock cycle""
  },
  ""Assertion 12"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd2)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]"", ""req[2]"", ""req[1]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 2, then in the previous clock cycle the fourth bit of request input signal must be asserted and the third, second and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 13"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[0] && $past(arb_type == 3'd3)) |-> $past(req[0] & ~req[3])"",
    ""Signals"": [""gnt[0]"", ""arb_type"", ""req[0]"", ""req[3]""],
    ""Signal Explanations"": {
      ""gnt[0]"": ""grant output for request 0"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[3]"": ""request input signal for request 3""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the first bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the first bit of request input signal must be asserted and the fourth bit of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 14"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[1] && $past(arb_type == 3'd3)) |-> $past(req[1] & ~req[3] & ~req[0])"",
    ""Signals"": [""gnt[1]"", ""arb_type"", ""req[1]"", ""req[3]"", ""req[0]""],
    ""Signal Explanations"": {
      ""gnt[1]"": ""grant output for request 1"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[1]"": ""request input signal for request 1"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[0]"": ""request input signal for request 0""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the second bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the second bit of request input signal must be asserted and the fourth and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 15"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[2] && $past(arb_type == 3'd3)) |-> $past(req[2] & ~req[3] & ~req[0] & ~req[1])"",
    ""Signals"": [""gnt[2]"", ""arb_type"", ""req[2]"", ""req[3]"", ""req[0]"", ""req[1]""],
    ""Signal Explanations"": {
      ""gnt[2]"": ""grant output for request 2"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[2]"": ""request input signal for request 2"",
      ""req[3]"": ""request input signal for request 3"",
      ""req[0]"": ""request input signal for request 0"",
      ""req[1]"": ""request input signal for request 1""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""&"", ""~"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""&"": ""logical and used to combine conditions"",
      ""~"": ""the value of a signal is inverted (logical not)"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the third bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the third bit of request input signal must be asserted and the fourth, second and first bits of request input signal must not be asserted from the current clock cycle""
  },
  ""Assertion 16"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~rst_n)"",
    ""logical expression"": ""(gnt[3] && $past(arb_type == 3'd3)) |-> $past(req[3])"",
    ""Signals"": [""gnt[3]"", ""arb_type"", ""req[3]""],
    ""Signal Explanations"": {
      ""gnt[3]"": ""grant output for request 3"",
      ""arb_type"": ""arbitration type selector signal"",
      ""req[3]"": ""request input signal for request 3""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""$past"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""the value of a signal in the previous clock cycle"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""Property for checking the priority scheme that when the fourth bit of grant output is asserted and in the previous clock cycle the arbitration type selector signal was equal to 3, then in the previous clock cycle the fourth bit of request input signal must be asserted from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property ((gnt[0] && $past(arb_type) == 3'b000) |-> $past(req[0]));"",
""Assertion 2"": ""assert property ((gnt[1] && $past(arb_type == 3'b000)) |-> ($past(req[1]) && !req[0]));"",
""Assertion 3"": ""assert property ((gnt[2] && $past(arb_type) == 3'b000) |-> ($past(req[2]) && !req[0] && !req[1]));"",
""Assertion 4"": ""assert property ((gnt[3] && $past(arb_type) == 3'b000) |-> ($past(req[3]) && !req[0] && !req[1] && !req[2]));"",
""Assertion 5"": ""assert property ((gnt[0] && $past(arb_type == 3'b001)) |-> ($past(req[0]) && !req[1]));"",
""Assertion 6"": ""assert property ((gnt[2] && $past(arb_type) == 1) |-> $past(req[2]));"",
""Assertion 7"": ""assert property (   ($past(arb_type == 3'b001) ##1 gnt[2])     |-> ($past(req[2]) && !req[0] && !req[1]) );"",
""Assertion 8"": ""assert property ((gnt[3] && $past(arb_type == 3'b001,1)) |-> ($past(req[3],1) && !req[2] && !req[1] && !req[0]));"",
""Assertion 9"": ""assert property (   (gnt[0] && $past(arb_type == 3'b010))   |->    ($past(req[0]) && !req[2]) );"",
""Assertion 10"": ""assert property ((gnt[2] && $past(arb_type == 3’d2)) |-> ($past(req[1]) && !req[2] && !req[0]));"",
""Assertion 11"": ""assert property ((gnt[3] && $past(arb_type) == 3’b010) |-> $past(req[3]));"",
""Assertion 12"": ""assert property (   (gnt[3] && $past(arb_type) == 3'b010)   |->    ($past(req[3]) && !req[2] && !req[1] && !req[0]) );"",
""Assertion 13"": ""assert property ((gnt[0] && $past(arb_type) == 3) |-> ($past(req[0]) && !req[3]));"",
""Assertion 14"": ""assert property ((gnt[2] && $past(arb_type) == 3) |-> ($past(req[2]) && !req[3] && !req[0]));"",
""Assertion 15"": ""assert property ((gnt[2] && $past(arb_type) == 3) |-> ($past(req[2]) && !req[3] && !req[1] && !req[0])) @(posedge clk);"",
""Assertion 16"": ""assert property ((gnt[3] && $past(arb_type) == 3) |-> $past(req[3])) @(posedge clk);""
}"
simple_pipeline,"// Greg Stitt
// University of Florida

// Module: simple_pipeline
// Description: This module takes 8 WIDTH-bit inputs, multiplies the 4 pairs,
// and then sums the products using a 2-level adder tree. Each stage of the
// pipeline is registered, and all overflow is ignored at each stage.

//===================================================================
// Parameter Description
// WIDTH : The data width (number of bits) of the input and output
//===================================================================

//===================================================================
// Interface Description
// clk  : Clock input
// rst  : Reset input (active high)
// in   : An array of 8 WIDTH-bit inputs
// valid_in : User should assert any time the input data on ""in"" is valid.
// out  : The output of the multiply accumulate computation.
// valid_out : Asserted whenever ""out"" contains valid data.
//===================================================================

module simple_pipeline
  #(
    parameter int WIDTH=16
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic [WIDTH-1:0]  in[8],
    input logic 	     valid_in,
    output logic [WIDTH-1:0] out,
    output logic 	     valid_out
    );

   // Specifies the cycle latency of the pipeline.
   localparam int 	     LATENCY = 4;
   
   logic [WIDTH-1:0] 	     in_r[8];
   logic [WIDTH-1:0] 	     mult_r[4];
   logic [WIDTH-1:0] 	     add_r[2];
   logic [WIDTH-1:0] 	     out_r;   
   logic [0:LATENCY-1] 	     valid_delay_r;

   assign out = out_r;
   
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
	 // Reset all the registers.
	 for (int i=0; i < 8; i++) in_r[i] <= '0;
	 for (int i=0; i < 4; i++) mult_r[i] <= '0;
	 for (int i=0; i < 2; i++) add_r[i] <= '0;
	 out_r <= '0;	 
      end
      else begin
	 // Register the inputs.
	 for (int i=0; i < 8; i++) in_r[i] <= in[i];
	 // Perform the multiplications.
	 for (int i=0; i < 4; i++) mult_r[i] <= in_r[i*2] * in_r[i*2+1];
	 // Create the first level of adders.
	 for (int i=0; i < 2; i++) add_r[i] <= mult_r[i*2] + mult_r[i*2+1];
	 // Create the final adder.
	 out_r <= add_r[0] + add_r[1];
      end
   end 

   // Delay that determines when out is valid based on the pipeline latency.
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
	 for (int i=0; i < LATENCY; i++) valid_delay_r[i] = '0;
      end
      else begin
	 valid_delay_r[0] <= valid_in;	 
	 for (int i=1; i < LATENCY; i++) valid_delay_r[i] <= valid_delay_r[i-1];
      end      
   end

   assign valid_out = valid_delay_r[LATENCY-1];   

int count;    
always_ff @(posedge clk or posedge rst)
if (rst) count = 0;
else if (count < LATENCY) count ++;
endmodule

","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""count < LATENCY |-> valid_out == 1'b0"",
    ""Signals"": [""count"", ""LATENCY"", ""valid_out""],
    ""Signal Explanations"": {
      ""count"": ""an integer register used to count the number of cycles until the pipeline latency is reached"",
      ""LATENCY"": ""the cycle latency of the pipeline"",
      ""valid_out"": ""the valid output signal of the pipeline indicating that the output is valid""
    },
    ""Logical Operators"": [""<"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""<"": ""less-than comparison"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when the integer register used for counting cycles is less than the cycle latency, then the valid output signal equals 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""count == LATENCY |-> valid_out == $past(valid_in, LATENCY)"",
    ""Signals"": [""count"", ""LATENCY"", ""valid_out"", ""valid_in""],
    ""Signal Explanations"": {
      ""count"": ""an integer register used to count the number of cycles until the pipeline latency is reached"",
      ""LATENCY"": ""the cycle latency of the pipeline"",
      ""valid_out"": ""the valid output signal of the pipeline indicating that the output is valid"",
      ""valid_in"": ""the valid input signal, which is asserted when the input data is valid""
    },
    ""Logical Operators"": [""=="", ""|->"", ""$past""],
    ""Logical Operators Explanation"": {
      ""=="": ""equal"",
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""$past"": ""returns the value of a signal a specified number of clock cycles in the past""
    },
    ""Assertion Explaination"": ""when the integer register used for counting cycles equals the cycle latency, then the valid output signal equals the valid input signal LATENCY cycles in the past from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (count < LATENCY |-> valid_out == 0) @(posedge clk);"",
""Assertion 2"": ""assert property ((count == LATENCY) |-> (valid_out == $past(valid_in, LATENCY))) @(posedge clk);""
}"
lcd,"module lcd #(parameter clk_freq = 1, parameter CBITS = 9) (input rst, input clk, input [6:0] in_data, input lcd_enable, input [9:0] lcd_bus, output reg e, output reg[7:0] lcd_data, output reg rw, output reg rs, output reg busy);
	reg [CBITS - 1:0] cnt;			// 0 to 500*clk_freg
	reg [1:0] state;

	always @(posedge clk) begin
		rw = 0;
		rs = 0;
		busy = 0;
		lcd_data = 0;
		e = 0;
		if(state == 0) begin
			busy = 1;
			if(cnt < 500*clk_freq)				// wait 500
				cnt = cnt + 1;
			else begin							// power-up completed
				cnt = 0;
				rs = 0;
				rw = 0;
				lcd_data = 8'b00110000;
				state = 1;
			end
		end
		if(state == 1) begin
			busy = 1;
			cnt = cnt + 1;
			if(cnt < (10*clk_freq))begin			//function set
				lcd_data = {4'b0011, in_data[6], in_data[5], 2'b00};
				e = 1;
			end
			else if(cnt < (60*clk_freq))begin		// wait 50
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (70*clk_freq))begin		//display on/off control
				lcd_data = {5'b00001, in_data[4], in_data[3], in_data[2]};
				e = 1;
			end
			else if(cnt < (120*clk_freq))begin		// wait 50
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (130*clk_freq))begin		// display clear
				lcd_data = 8'b00000001;
				e = 1;
			end
			else if(cnt < (330*clk_freq))begin		// wait 200
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (340*clk_freq))begin		// entry mode set
				lcd_data = {6'b000001, in_data[1], in_data[0]};
				e = 1;
			end
			else if(cnt < (440*clk_freq))begin		// wait 100
				lcd_data = 8'b00000000;
				e = 0;
			end
			else begin								// initialization complete
				cnt = 0;
				busy = 0;
				state = 2;
			end
		end
		if(state == 2) begin
			if(lcd_enable == 1) begin
				busy = 1;
				rs = lcd_bus[9];
				rw = lcd_bus[8];
				lcd_data = lcd_bus[7:0];
				cnt = 0;
				state = 3;
			end
			else begin
				busy = 0;
				rs = 0;
				rw = 0;
				lcd_data = 8'b00000000;
				cnt = 0;
			end
		end
		if(state == 3) begin
			if(cnt < 50* clk_freq) begin 		// do not exit for 50
				if(cnt < clk_freq)
					e = 0;
				else if(cnt < 14*clk_freq)		// positive enable half-cycle
					e = 1;
				else if(cnt < 27*clk_freq)		// negative enable half-cycle
					e = 0;
				cnt = cnt + 1;
			end
			else begin
				cnt = 0;
				state = 2;
			end
		end
	end

endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""none"",
    ""logical expression"": ""s_eventually (lcd_enable == 0 || state == 2)"",
    ""Signals"": [""lcd_enable"", ""state""],
    ""Signal Explanations"": {
      ""lcd_enable"": ""LCD enable control signal"",
      ""state"": ""internal state variable representing the current state of the LCD initialization and command execution""
    },
    ""Logical Operators"": [""s_eventually"", ""=="", ""||"", ""==""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""a temporal operator indicating that the contained condition is required to occur at some future clock cycle (eventually)"",
      ""=="": ""equal"",
      ""||"": ""or""
    },
    ""Assertion Explaination"": ""eventually, LCD enable control signal equals 0 or internal state variable equals 2""
  }
}","{
""Assertion 1"": ""assert property (eventually (lcd_enable == 1'b0 || state == 2'b10));""
}"
Parallel_In_Serial_Out_Shift_Reg,"module Parallel_In_Serial_Out_Shift_Reg #(
	parameter DATA_WIDTH = 16
) 
(
	input clk,
	input resetn,
	input [DATA_WIDTH-1:0] din,
	input                  din_en,
	output logic           dout
);

reg  [DATA_WIDTH-1:0] data_q;
wire [DATA_WIDTH-1:0] data_next;

assign data_next = din_en ? din : data_q >> 1;

always @(posedge clk)
begin
	if( ~resetn) begin
		data_q <= '0;
	end else begin
		data_q <= data_next;
	end
end

assign dout = data_q[0]; 



reg  v_f_q;
wire v_f_next;
reg  [DATA_WIDTH-1:0] din_f_q;
wire [DATA_WIDTH-1:0] din_f_next;
assign din_f_next = { 1'b0 , din_f_q[7:1] };
assign v_f_next   = resetn & din_en;

always @(posedge clk)
begin
	din_f_q <= ~resetn ? {DATA_WIDTH{1'bx}} : 
					din_en ? din : din_f_next; 
	v_f_q   <= v_f_next;
end
endmodule","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (~resetn)"",
    ""logical expression"": ""~v_f_q | (v_f_q & din_f_q[0] == dout)"",
    ""Signals"": [""v_f_q"", ""din_f_q[0]"", ""dout""],
    ""Signal Explanations"": {
      ""v_f_q"": ""valid flag register indicating that the input data is valid"",
      ""din_f_q[0]"": ""the least significant bit of the register that captures and shifts the input data"",
      ""dout"": ""the serial output of the shift register""
    },
    ""Logical Operators"": [""~"", ""|"", ""&"", ""==""],
    ""Logical Operators Explanation"": {
      ""~"": ""the value of a signal is reset (0)"",
      ""|"": ""or"",
      ""&"": ""and"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when valid flag register is reset (0), valid flag register is set (1) and the first bit of the register that captures and shifts the input data equals the output signal""
  }
}","{
""Assertion 1"": ""assert property ((v_f_q == 1'b0) && (v_f_q == 1'b1) && (din_f_q[0] == dout));""
}"
fifo,"module fifo
  #(
    parameter WIDTH=8,
    parameter DEPTH=16
    )
   (
    input logic              clk,
    input logic              rst,
    output logic             full,
    input logic              wr_en,
    input logic [WIDTH-1:0]  wr_data,
    output logic             empty, 
    input logic              rd_en,
    output logic [WIDTH-1:0] rd_data  
    );

   localparam int READ_LATENCY = 1;
   
   logic [WIDTH-1:0]         ram[DEPTH];
   logic                     valid_wr, valid_rd;

   localparam int            ADDR_WIDTH = $clog2(DEPTH)+1;
   logic [ADDR_WIDTH-1:0]   wr_addr_r, rd_addr_r;

   always_ff @(posedge clk) begin
      if (valid_wr) ram[wr_addr_r[ADDR_WIDTH-2:0]] <= wr_data;
      rd_data <= ram[rd_addr_r[ADDR_WIDTH-2:0]];      
   end
      
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
         rd_addr_r <= '0;
         wr_addr_r <= '0;
      end
      else begin         
         if (valid_wr) wr_addr_r <= wr_addr_r + 1'b1;
         if (valid_rd) rd_addr_r <= rd_addr_r + 1'b1;
      end
   end 
      
   assign valid_wr = wr_en && !full;
   assign valid_rd = rd_en && !empty;

   assign full = rd_addr_r[ADDR_WIDTH-2:0] == wr_addr_r[ADDR_WIDTH-2:0] && rd_addr_r[ADDR_WIDTH-1] != wr_addr_r[ADDR_WIDTH-1];

   assign empty = rd_addr_r == wr_addr_r;
      
endmodule

","{
  ""leaf_sv_files"": [],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""valid_wr |-> !full"",
    ""Signals"": [""valid_wr"", ""full""],
    ""Signal Explanations"": {
      ""valid_wr"": ""derived valid write signal, defined as wr_en && !full"",
      ""full"": ""output signal indicating FIFO is full""
    },
    ""Logical Operators"": [""|->"", ""!""],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""!"": ""the value of a signal is reset (0)""
    },
    ""Assertion Explaination"": ""when the derived valid write signal is set (1), then the FIFO full indicator is reset (0) from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""valid_rd |-> !empty"",
    ""Signals"": [""valid_rd"", ""empty""],
    ""Signal Explanations"": {
      ""valid_rd"": ""derived valid read signal, defined as rd_en && !empty"",
      ""empty"": ""output signal indicating FIFO is empty""
    },
    ""Logical Operators"": [""|->"", ""!""],
    ""Logical Operators Explanation"": {
      ""|->"": ""an overlapping implication operator meaning that if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""!"": ""the value of a signal is reset (0)""
    },
    ""Assertion Explaination"": ""when the derived valid read signal is set (1), then the FIFO empty indicator is reset (0) from the current clock cycle""
  }
}","{
""Assertion 1"": ""assert property (valid_wr |-> !full) @(posedge clk);"",
""Assertion 2"": ""assert property (valid_rd |-> !empty) @(posedge clk);""
}"
or1200_if,"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's instruction fetch                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  PC, instruction fetch, interface to IC.                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_if.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
// `include ""timescale.v""
// synopsys translate_on
`include ""or1200_defines.v""

module or1200_if(
	// Clock and reset
	clk, rst,

	// External i/f to IC
	icpu_dat_i, icpu_ack_i, icpu_err_i, icpu_adr_i, icpu_tag_i,

	// Internal i/f
	if_freeze, if_insn, if_pc, if_flushpipe, saving_if_insn, 
	if_stall, no_more_dslot, genpc_refetch, rfe,
	except_itlbmiss, except_immufault, except_ibuserr
);

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External i/f to IC
//
input	[31:0]			icpu_dat_i;
input				icpu_ack_i;
input				icpu_err_i;
input	[31:0]			icpu_adr_i;
input	[3:0]			icpu_tag_i;

//
// Internal i/f
//
input				if_freeze;
output	[31:0]			if_insn;
output	[31:0]			if_pc;
input				if_flushpipe;
output				saving_if_insn;
output				if_stall;
input				no_more_dslot;
output				genpc_refetch;
input				rfe;
output				except_itlbmiss;
output				except_immufault;
output				except_ibuserr;

//
// Internal wires and regs
//
wire			save_insn;
wire			if_bypass;
reg			if_bypass_reg;
reg	[31:0]		insn_saved;
reg	[31:0]		addr_saved;
reg	[2:0]		err_saved;
reg			saved;

assign save_insn = (icpu_ack_i | icpu_err_i) & if_freeze & !saved;
assign saving_if_insn = !if_flushpipe & save_insn;

//
// IF bypass 
//
assign if_bypass = icpu_adr_i[0] ? 1'b0 : if_bypass_reg | if_flushpipe;

always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		if_bypass_reg <=  1'b0;
	else
		if_bypass_reg <=  if_bypass;

//
// IF stage insn
//
assign if_insn = no_more_dslot | rfe | if_bypass ? {`OR1200_OR32_NOP, 26'h041_0000} : saved ? insn_saved : icpu_ack_i ? icpu_dat_i : {`OR1200_OR32_NOP, 26'h061_0000};
assign if_pc = saved ? addr_saved : {icpu_adr_i[31:2], 2'h0};
assign if_stall = !icpu_err_i & !icpu_ack_i & !saved;
assign genpc_refetch = saved & icpu_ack_i;
assign except_itlbmiss = no_more_dslot ? 1'b0 : saved ? err_saved[0] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_TE);
assign except_immufault = no_more_dslot ? 1'b0 : saved ? err_saved[1] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_PE);
assign except_ibuserr = no_more_dslot ? 1'b0 : saved ? err_saved[2] : icpu_err_i & (icpu_tag_i == `OR1200_ITAG_BE);

//
// Flag for saved insn/address
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		saved <=  1'b0;
	else if (if_flushpipe)
		saved <=  1'b0;
	else if (save_insn)
		saved <=  1'b1;
	else if (!if_freeze)
		saved <=  1'b0;

//
// Store fetched instruction
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (if_flushpipe)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};
	else if (save_insn)
		insn_saved <=  icpu_err_i ? {`OR1200_OR32_NOP, 26'h041_0000} : icpu_dat_i;
	else if (!if_freeze)
		insn_saved <=  {`OR1200_OR32_NOP, 26'h041_0000};

//
// Store fetched instruction's address
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		addr_saved <=  32'h00000000;
	else if (if_flushpipe)
		addr_saved <=  32'h00000000;
	else if (save_insn)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};
	else if (!if_freeze)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};

//
// Store fetched instruction's error tags 
//
always @(posedge clk or `OR1200_RST_EVENT rst)
	if (rst == `OR1200_RST_VALUE)
		err_saved <=  3'b000;
	else if (if_flushpipe)
		err_saved <=  3'b000;
	else if (save_insn) begin
		err_saved[0] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_TE);
		err_saved[1] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_PE);
		err_saved[2] <=  icpu_err_i & (icpu_tag_i == `OR1200_ITAG_BE);
	end
	else if (!if_freeze)
		err_saved <=  3'b000;


endmodule","{
  ""leaf_sv_files"": [""or1200_defines""],
  ""Assertion 1"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": """",
    ""logical expression"": ""no_more_dslot |-> (except_itlbmiss == 0 && except_immufault == 0 && except_ibuserr == 0)"",
    ""Signals"": [""no_more_dslot"", ""except_itlbmiss"", ""except_immufault"", ""except_ibuserr""],
    ""Signal Explanations"": {
      ""no_more_dslot"": ""input signal indicating that there is no delay slot instruction"",
      ""except_itlbmiss"": ""output signal indicating an ITLB miss exception"",
      ""except_immufault"": ""output signal indicating an immediate fault exception"",
      ""except_ibuserr"": ""output signal indicating an instruction bus error exception""
    },
    ""Logical Operators"": [""|->"", ""=="", ""&&""],
    ""Logical Operators Explanation"": {
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&&"": ""and""
    },
    ""Assertion Explaination"": ""when no delay slot instruction signal is true, then ITLB miss exception equals 0 and immediate fault exception equals 0 and instruction bus error exception equals 0 from the current clock cycle""
  },
  ""Assertion 2"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 saved == 1"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""saved"": ""flag indicating if an instruction has been saved""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then saved flag equals 1 from the next clock cycle""
  },
  ""Assertion 3"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 saved == 0"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""saved"": ""flag indicating if an instruction has been saved""
    },
    ""Logical Operators"": [""|"", ""!"", ""&&"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""|"": ""or"",
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true or both save instruction condition is reset (0) and pipeline freeze is reset (0), then saved flag equals 0 from the next clock cycle""
  },
  ""Assertion 4"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn && !icpu_err_i) |-> ##1 (insn_saved == $past(icpu_dat_i))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""icpu_err_i"", ""insn_saved"", ""icpu_dat_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""insn_saved"": ""register holding the saved instruction"",
      ""icpu_dat_i"": ""input data from the instruction cache""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true and instruction cache error signal is reset (0), then insn_saved equals the previous clock cycle's instruction cache data from the next clock cycle""
  },
  ""Assertion 5"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze) && !icpu_err_i) |-> ##1 (insn_saved == {6'b000101, 26'h041_0000})"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""icpu_err_i"", ""insn_saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""insn_saved"": ""register holding the saved instruction""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|"": ""or"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true or both save instruction condition is reset (0) and pipeline freeze is reset (0) and instruction cache error is reset (0), then insn_saved equals the constant value {6'b000101, 26'h041_0000} from the next clock cycle""
  },
  ""Assertion 6"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && (save_insn | !if_freeze)) |-> ##1 (addr_saved == {$past(icpu_adr_i[31:2]), 2'b00})"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""addr_saved"", ""icpu_adr_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""addr_saved"": ""register holding the saved instruction address"",
      ""icpu_adr_i"": ""input signal providing the instruction cache address""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|"", ""|->"", ""##1"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|"": ""or"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and either save instruction is true or pipeline freeze is reset (0), then addr_saved equals the previous clock cycle's instruction cache address with its lower two bits set to 0 from the next clock cycle""
  },
  ""Assertion 7"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe) |-> ##1 (addr_saved == 32'h00000000)"",
    ""Signals"": [""if_flushpipe"", ""addr_saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""addr_saved"": ""register holding the saved instruction address""
    },
    ""Logical Operators"": [""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""|->"": ""if the condition on the left is met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true then addr_saved equals 32'h00000000 from the next clock cycle""
  },
  ""Assertion 8"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[0] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hd)))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""err_saved[0]"", ""icpu_err_i"", ""icpu_tag_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""err_saved[0]"": ""bit 0 of the saved error register representing an ITLB miss"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""icpu_tag_i"": ""input signal providing the instruction cache tag""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""&"", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&"": ""and"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then the first bit of the saved error register equals the logical AND of the previous clock cycle's instruction cache error signal and the result of comparing the previous clock cycle's instruction cache tag signal equal to 4'hd from the next clock cycle""
  },
  ""Assertion 9"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[1] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hc)))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""err_saved[1]"", ""icpu_err_i"", ""icpu_tag_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""err_saved[1]"": ""bit 1 of the saved error register representing an immediate fault"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""icpu_tag_i"": ""input signal providing the instruction cache tag""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""&"", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&"": ""and"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then the second bit of the saved error register equals the logical AND of the previous clock cycle's instruction cache error signal and the result of comparing the previous clock cycle's instruction cache tag signal equal to 4'hc from the next clock cycle""
  },
  ""Assertion 10"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(!if_flushpipe && save_insn) |-> ##1 (err_saved[2] == ($past(icpu_err_i) & ($past(icpu_tag_i) == 4'hb)))"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""err_saved[2]"", ""icpu_err_i"", ""icpu_tag_i""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""err_saved[2]"": ""bit 2 of the saved error register representing an instruction bus error"",
      ""icpu_err_i"": ""input signal indicating an instruction cache error"",
      ""icpu_tag_i"": ""input signal providing the instruction cache tag""
    },
    ""Logical Operators"": [""!"", ""&&"", ""|->"", ""##1"", ""=="", ""&"", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal"",
      ""&"": ""and"",
      ""$past"": ""the value from the previous clock cycle""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is reset (0) and save instruction condition is true, then the third bit of the saved error register equals the logical AND of the previous clock cycle's instruction cache error signal and the result of comparing the previous clock cycle's instruction cache tag signal equal to 4'hb from the next clock cycle""
  },
  ""Assertion 11"": {
    ""clock signal condition"": ""@(posedge clk)"",
    ""disable condition"": ""disable iff (rst)"",
    ""logical expression"": ""(if_flushpipe | (!save_insn && !if_freeze)) |-> ##1 (err_saved == 3'b000)"",
    ""Signals"": [""if_flushpipe"", ""save_insn"", ""if_freeze"", ""err_saved""],
    ""Signal Explanations"": {
      ""if_flushpipe"": ""input signal indicating pipeline flush"",
      ""save_insn"": ""wire signal indicating that an instruction should be saved"",
      ""if_freeze"": ""input signal indicating a pipeline freeze"",
      ""err_saved"": ""register holding the saved error tags for the instruction""
    },
    ""Logical Operators"": [""|"", ""!"", ""&&"", ""|->"", ""##1"", ""==""],
    ""Logical Operators Explanation"": {
      ""|"": ""or"",
      ""!"": ""the value of a signal is negated"",
      ""&&"": ""and"",
      ""|->"": ""if the conditions on the left are met then the condition on the right must hold SINCE THE SAME CLOCK CYCLE (modified by a delay)"",
      ""##1"": ""a temporal delay operator indicating that the consequent is checked SINCE NEXT CLOCK CYCLE"",
      ""=="": ""equal""
    },
    ""Assertion Explaination"": ""when pipeline flush signal is true or both save instruction condition is reset (0) and pipeline freeze is reset (0), then err_saved equals 3'b000 from the next clock cycle""
  }
}","{
""Assertion 1"": ""assert property (no_more_dslot |-> (!except_itlbmiss && !except_immufault && !except_ibuserr));"",
""Assertion 2"": ""assert property ((!if_flushpipe && save_insn) |-> ##1 (saved == 1’b1));"",
""Assertion 3"": ""assert property ((if_flushpipe || (!save_insn && !if_freeze)) |-> ##1 (saved == 1’b0));"",
""Assertion 4"": ""assert property ((!if_flushpipe && save_insn && !icpu_err_i) |-> (insn_saved == $past(icpu_dat_i)));"",
""Assertion 5"": ""assert property ((if_flushpipe || (!save_insn && !if_freeze && !icpu_err_i)) |-> ##1 (insn_saved == {6'b000101, 26'h041_0000}));"",
""Assertion 6"": ""assert property (   (if_flushpipe == 1'b0 && (save_insn || if_freeze == 1'b0))   |-> (addr_saved == {icpu_adr_i[31:2], 2'b00}) );"",
""Assertion 7"": ""assert property (if_flushpipe |-> (addr_saved == 32'h00000000));"",
""Assertion 8"": ""assert property (( !if_flushpipe && save_insn ) |-> ( err_saved[0] == $past(icpu_err_i && (icpu_tag_i == 4'hd)) ));"",
""Assertion 9"": ""assert property (   (!if_flushpipe && save_insn)   |->    (err_saved[1] == ($past(icpu_err_i) && ($past(icpu_tag_i) == 4'hC))) );"",
""Assertion 10"": ""assert property(   (!if_flushpipe && save_insn)   |->    (err_saved[2] == ($past(icpu_err_i) && ($past(icpu_tag_i) == 4'hb))) );"",
""Assertion 11"": ""assert property ((if_flushpipe || (!save_insn && !if_freeze)) |-> (err_saved == 3’b000));""
}"
