code,assertion,link,HumanExplanation
"module register
  #(
    parameter WIDTH,
    parameter logic HAS_ASYNC_RESET = 1'b1,
    parameter logic RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic 	     en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );

   generate
      if (HAS_ASYNC_RESET) begin
	 always_ff @(posedge clk or posedge rst) begin
	    if (rst == RESET_ACTIVATION_LEVEL)
	      out <= RESET_VALUE;
	    else if (en)
	      out <= in;    	
	 end
      end
      else begin
	 always_ff @(posedge clk) begin
	    if (rst == RESET_ACTIVATION_LEVEL)
	      out <= RESET_VALUE;	      
	    else if (en)
	      out <= in;
	 end	
      end
   endgenerate
endmodule // register

// Module: delay
// Description: This module delays a provided WIDTH-bit input by CYCLES cycles.
// It also has configuration parmaters for reset type, activation level, and
// value. Finally, it has an enable signal that stalls the delay when not
// not asserted.
//
// See delay.pdf for an illustration of the schematic.

module delay
  #(
    parameter int 		CYCLES=4,
    parameter int 		WIDTH=8,
    parameter logic 		HAS_ASYNC_RESET = 1'b1,
    parameter logic 		RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk, rst, en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );

   // Ideally, every module would validate its parameters because often
   // certain values are undefined. For example, a negative cycles delay
   // doesn't make sense. Similarly, only positive widths make sense.
   // Unfortunately, parameter validation is somewhat lacking in SystemVerilog,
   // at least in the older versions. Some of the possibilities are shown
   // below.
   
   if (CYCLES < 0) begin
      // One workaround to missing validation constructs is to simply call
      // an undefined module with a name that specifies the error.
      cycles_parameter_must_be_ge_0();

      // The 2009 SV standard defines the $error function, which prints during
      // compilation. However, not every tool supports it yet. Also, despite 
      // the name, $error only created a warning in the version of Quartus
      // used for testing.
      //
      // $error(""ERROR: CYCLES parameter must be >= 0."");

      // $fatal does caused Quartus synthesis to terminate, but is not 
      // supported by every synthesis tool.
      //
      // $fatal(""ERROR: CYCLES parameter must be >= 0."");
   end
   if (WIDTH < 1) begin
      width_parameter_must_be_gt_0();      
      //$error(""ERROR: WIDTH parameter must be >= 1."");
      //$fatal(1, ""ERROR: WIDTH parameter must be >= 1."");      
   end

   // Create an array of WIDTH-bit signals, which will connect all the registers
   // together (see delay.pdf). The array uses CYCLES+1 elements because there
   // are CYCLES register outputs, plus the input to the first register.
   //
   // When creating an array this way, the CYCLES+1 section creates an unpacked
   // array. The [WIDTH-1:0] section creates a packed array. Packed arrays and
   // unpacked arrays support different operations, but generally you will use
   // the unpacked section to specify bits, and the unpacked section to specify
   // the total number of elements.
   //
   // The CYCLES+1 notation is short for [0:CYCLES+1-1]. A common convention is
   // to use ""downto"" syntax for the packed array, and ""to"" syntax for the
   // unpacked array. Most people are used to thinking of arrays starting at 
   // index 0, and the MSB starting at the highest number.
   //
   // VHDL COMPARISON: packed arrays are missing from VHDL, where you instead 
   // have to create a custom array type. In SV, every signal can become an
   // unpacked array simply by adding [], which is very convenient.
   logic [WIDTH-1:0] 	     regs[CYCLES+1];
   
   if (CYCLES == 0) begin
      // For CYCLES == 0, there is no delay, so just use a wire.
      assign out = in;
   end
   else if (CYCLES > 0) begin
      // Create a sequence of CYCLES registers, where each register adds one
      // cycle to the delay.
      
      for (genvar i=0; i < CYCLES; i++) begin : reg_array
	 register #(.WIDTH(WIDTH),
		    .HAS_ASYNC_RESET(HAS_ASYNC_RESET),
		    .RESET_ACTIVATION_LEVEL(RESET_ACTIVATION_LEVEL),
		    .RESET_VALUE(RESET_VALUE))
	 reg_array (.in(regs[i]), .out(regs[i+1]), .*);	 	 
      end

      // The first register's input comes from the delay's input.
      assign regs[0] = in;
      
      // The last register's output goes to the delay's output.
      assign out = regs[CYCLES];      
      
   end       
endmodule","module delay_sva
  #(
    parameter int 		CYCLES=4,
    parameter int 		WIDTH=8,
    parameter logic 		HAS_ASYNC_RESET = 1'b1,
    parameter logic 		RESET_ACTIVATION_LEVEL = 1'b1,
    parameter logic [WIDTH-1:0] RESET_VALUE = '0
    )
   (
    input logic 	     clk, rst, en,
    input logic [WIDTH-1:0]  in,
    input logic [WIDTH-1:0] out
    );
      
//   localparam CYCLES = 4;  
//   localparam WIDTH = 8;  
//   localparam logic HAS_ASYNC_RESET = 1'b1;   
//   localparam logic RESET_ACTIVATION_LEVEL = 1'b1;   
//   localparam logic [WIDTH-1:0] RESET_VALUE = '0; 

   default clocking cb @(posedge clk);
   endclocking
   default disable iff (rst);

   int count;    
   always_ff @(posedge clk or posedge rst)
     if (rst) count = 0;
     else if (en == 1'b1 && count < CYCLES) count ++;

   assert property(count < CYCLES || out == $past(in, CYCLES, en));

   assert property(count == CYCLES || out == RESET_VALUE);

   assert property(!en |=> $stable(out));
         
endmodule // delay_tb4",https://github.com/ARC-Lab-UF/sv-tutorial/blob/main/testbenches/assertions/delay_tb.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property(count < CYCLES || out == $past(in, CYCLES, en));"",
    ""Signals"": [""count"", ""CYCLES"", ""out"", ""in"", ""en""],
    ""Signal Explanations"": {
      ""count"": ""an internal counter that increments at each clock cycle when en is asserted until reaching CYCLES"",
      ""CYCLES"": ""the parameter that defines the number of register stages (delay cycles) for the module"",
      ""out"": ""the output signal of the delay module, driven by the delayed registers"",
      ""in"": ""the input signal to the delay module"",
      ""en"": ""the enable signal that controls when the delay registers update their values""
    },
    ""Logical Operators"": [""<"", ""||"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""<"": ""less than"",
      ""||"": ""logical OR which means that if the left condition is false then the right condition must be true"",
      ""=="": ""equality operator that checks if two values are the same"",
      ""$past"": ""a system function that returns the value of a signal from a specified number of clock cycles in the past, conditional on the enable signal""
    },
    ""Assertion Explaination"": ""This assertion checks that either the internal counter is still less than the configured delay cycles or, if the counter has reached (or exceeded) the delay, then the output signal equals the value of the input signal from CYCLES ago (sampled with the enable signal).""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property(count == CYCLES || out == RESET_VALUE);"",
    ""Signals"": [""count"", ""CYCLES"", ""out"", ""RESET_VALUE""],
    ""Signal Explanations"": {
      ""count"": ""an internal counter that increments at each clock cycle when en is asserted until reaching CYCLES"",
      ""CYCLES"": ""the parameter that defines the number of register stages (delay cycles) for the module"",
      ""out"": ""the output signal of the delay module, driven by the delayed registers"",
      ""RESET_VALUE"": ""a parameter that defines the value of the output when the module is reset or when the delay is not yet complete""
    },
    ""Logical Operators"": [""=="", ""||""],
    ""Logical Operators Explanation"": {
      ""=="": ""equality operator that checks if two values are the same"",
      ""||"": ""logical OR which means that if the left condition is false then the right condition must be true""
    },
    ""Assertion Explaination"": ""This assertion states that either the internal counter has exactly reached the configured delay (CYCLES) or, if it has not, then the output signal must equal the RESET_VALUE. In other words, before the delay is fully elapsed, the output is forced to the reset value.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property(!en |=> $stable(out));"",
    ""Signals"": [""en"", ""out""],
    ""Signal Explanations"": {
      ""en"": ""the enable signal that controls when the delay registers update their values"",
      ""out"": ""the output signal of the delay module, driven by the delayed registers""
    },
    ""Logical Operators"": [""!"", ""|=>"", ""$stable""],
    ""Logical Operators Explanation"": {
      ""!"": ""logical NOT that inverts the value of a signal"",
      ""|=>"": ""non-overlapping implication, meaning that if the antecedent holds in the current cycle, then the consequent must hold starting in the next cycle"",
      ""$stable"": ""a system function that checks if a signal remains unchanged over successive cycles""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the enable signal is deasserted (0) in the current cycle, then the output signal must remain stable (unchanged) in the next cycle.""
  }
}"
"module ff
  (
   input logic clk, rst, en, in,
   output logic out   
   );

   always_ff @(posedge clk or posedge rst)
      if (rst) out = 1'b0;
      else if (en) out = in;         
endmodule","module ff_sva(
input logic clk,
input logic rst, 
input logic en,
input logic in,
input logic out
);

    default clocking cb @(posedge clk);
    endclocking
    default disable iff (rst);

   assert property(en |=> out == $past(in,1));

   assert property(!en |=> out == $past(out,1));
   // assert property(@(posedge clk) disable iff (rst) !en |=> $stable(out));

endmodule",https://github.com/ARC-Lab-UF/sv-tutorial/blob/main/testbenches/assertions/ff_tb.sv ,"{
""Assertion 1"": {
  ""Assertion"": ""assert property(en |=> out == $past(in,1));"",
  ""Signals"": [""en"", ""out"", ""in""],
  ""Signal Explanations"": {
    ""en"": ""enable signal that allows the flip-flop to load the input when active"",
    ""out"": ""output signal of the flip-flop module updated on the rising clock edge"",
    ""in"": ""input signal for the flip-flop, whose value is captured when enable is high""
  },
  ""Logical Operators"": [""|=>"", ""=="", ""$past""],
  ""Logical Operators Explanation"": {
    ""|=>"": ""non-overlapping implication, meaning if the antecedent is true in the current cycle then the consequent must hold starting at the next clock cycle"",
    ""=="": ""equality operator used to compare two values"",
    ""$past"": ""a function that returns the value of a signal from a previous clock cycle (here, one cycle ago)""
  },
  ""Assertion Explaination"": ""If the enable signal is high in the current cycle, then at the next rising clock edge the output signal must equal the input signal’s value from the previous cycle.""
},
""Assertion 2"": {
  ""Assertion"": ""assert property(!en |=> out == $past(out,1));"",
  ""Signals"": [""en"", ""out""],
  ""Signal Explanations"": {
    ""en"": ""enable signal that controls whether the flip-flop should capture a new value"",
    ""out"": ""output signal of the flip-flop module whose value is maintained or updated based on enable""
  },
  ""Logical Operators"": [""!"", ""|=>"", ""=="", ""$past""],
  ""Logical Operators Explanation"": {
    ""!"": ""logical negation, used here to indicate that the enable signal is not active (i.e. 0)"",
    ""|=>"": ""non-overlapping implication, meaning if the antecedent is true in the current cycle then the consequent must hold starting at the next clock cycle"",
    ""=="": ""equality operator that checks if two values are equal"",
    ""$past"": ""a function that returns the value of a signal from the previous clock cycle (here used to fetch the previous value of out)""
  },
  ""Assertion Explaination"": ""If the enable signal is low in the current cycle, then at the next rising clock edge the output signal must remain equal to its value from the previous cycle, effectively holding its state.""
},
""Assertion 3"": {
  ""Assertion"": ""assert property(@(posedge clk) disable iff (rst) !en |=> $stable(out));"",
  ""Signals"": [""clk"", ""rst"", ""en"", ""out""],
  ""Signal Explanations"": {
    ""clk"": ""clock signal that triggers sequential evaluations on its rising edge"",
    ""rst"": ""reset signal that forces the flip-flop output to a known state and disables the assertion when active"",
    ""en"": ""enable signal that determines whether the flip-flop should load a new value"",
    ""out"": ""output signal of the flip-flop module whose state is monitored for stability""
  },
  ""Logical Operators"": [""@"", ""disable iff"", ""!"", ""|=>"", ""$stable""],
  ""Logical Operators Explanation"": {
    ""@"": ""clocking event operator specifying that the property is evaluated on every rising edge of clk"",
    ""disable iff"": ""disables the assertion evaluation when the specified condition (rst active) is true"",
    ""!"": ""logical negation indicating that enable is not active (i.e., en is 0)"",
    ""|=>"": ""non-overlapping implication that requires the consequent to hold starting from the next clock cycle when the antecedent is true"",
    ""$stable"": ""checks that the signal remains unchanged compared to its previous value""
  },
  ""Assertion Explaination"": ""On every rising edge of the clock, if the reset signal is not active (due to disable iff) and the enable signal is low (not active), then starting at the next clock cycle the output signal must remain stable (unchanged from its previous value).""
}
}"
"// Greg Stitt
// University of Florida

// Module: register
// Description: Implements a register with an active high, asynchronous reset
// and an enable signal.

module register
  #(
    parameter WIDTH
    )
   (
    input logic              clk,
    input logic              rst,
    input logic              en,
    input logic [WIDTH-1:0]  in,
    output logic [WIDTH-1:0] out
    );
   
   always_ff @(posedge clk or posedge rst) begin
      if (rst)
        out <= '0;
      else if (en)
        out <= in;      
   end 
   
endmodule","module register_sva  #(
    parameter WIDTH=8
    )
   (
    input logic              clk,
    input logic              rst,
    input logic              en,
    input logic [WIDTH-1:0]  in,
    input logic [WIDTH-1:0] out
    );

    default clocking cb @(posedge clk);
    endclocking
    default disable iff (rst);
   // For the enable, we can use the same strategy as the FF example.
   // Verify output when enable is asserted.
   assert property(en |=> out == $past(in,1));

   // Verify output when enable isn't asserted. Only one of these is needed
   // since they are equivalent.
   assert property(!en |=> out == $past(out,1));

endmodule",https://github.com/ARC-Lab-UF/sv-tutorial/blob/main/testbenches/assertions/register_tb.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property(en |=> out == $past(in,1));"",
    ""Signals"": [""en"", ""out"", ""in""],
    ""Signal Explanations"": {
      ""en"": ""enable signal"",
      ""out"": ""output signal of the verilog module"",
      ""in"": ""input signal of the verilog module""
    },
    ""Logical Operators"": [""|=>"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""|=>"": ""non-overlapped implication indicating that if the antecedent is true in the current cycle, then the consequent is expected in the next cycle"",
      ""=="": ""equality operator to check if two values are identical"",
      ""$past"": ""function returning the value of a signal in the previous clock cycle""
    },
    ""Assertion Explaination"": ""If the enable signal is asserted (1) in the current cycle, then in the next cycle the output signal must equal the value of the input signal from the previous cycle.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property(!en |=> out == $past(out,1));"",
    ""Signals"": [""en"", ""out""],
    ""Signal Explanations"": {
      ""en"": ""enable signal"",
      ""out"": ""output signal of the verilog module""
    },
    ""Logical Operators"": [""!"", ""|=>"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""!"": ""logical negation indicating the signal is not asserted (0)"",
      ""|=>"": ""non-overlapped implication meaning that if the antecedent is true in the current cycle, then the consequent is expected in the next cycle"",
      ""=="": ""equality operator to check if two values are identical"",
      ""$past"": ""function returning the value of a signal in the previous clock cycle""
    },
    ""Assertion Explaination"": ""If the enable signal is not asserted (0) in the current cycle, then in the next cycle the output signal must remain equal to its value from the previous cycle.""
  }
}"
"module fifo
  #(
    parameter WIDTH=8,
    parameter DEPTH=16
    )
   (
    input logic              clk,
    input logic              rst,
    output logic             full,
    input logic              wr_en,
    input logic [WIDTH-1:0]  wr_data,
    output logic             empty, 
    input logic              rd_en,
    output logic [WIDTH-1:0] rd_data  
    );

   localparam int READ_LATENCY = 1;
   
   logic [WIDTH-1:0]         ram[DEPTH];
   logic                     valid_wr, valid_rd;

   localparam int            ADDR_WIDTH = $clog2(DEPTH)+1;
   logic [ADDR_WIDTH-1:0]   wr_addr_r, rd_addr_r;

   always_ff @(posedge clk) begin
      if (valid_wr) ram[wr_addr_r[ADDR_WIDTH-2:0]] <= wr_data;
      rd_data <= ram[rd_addr_r[ADDR_WIDTH-2:0]];      
   end
      
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
         rd_addr_r <= '0;
         wr_addr_r <= '0;
      end
      else begin         
         if (valid_wr) wr_addr_r <= wr_addr_r + 1'b1;
         if (valid_rd) rd_addr_r <= rd_addr_r + 1'b1;
      end
   end 
      
   assign valid_wr = wr_en && !full;
   assign valid_rd = rd_en && !empty;

   assign full = rd_addr_r[ADDR_WIDTH-2:0] == wr_addr_r[ADDR_WIDTH-2:0] && rd_addr_r[ADDR_WIDTH-1] != wr_addr_r[ADDR_WIDTH-1];

   assign empty = rd_addr_r == wr_addr_r;
      
endmodule
","module fifo_sva  #(
    parameter WIDTH=8,
    parameter DEPTH=16
    )
   (
    input logic              clk,
    input logic              rst,
    input logic             full,
    input logic              wr_en,
    input logic [WIDTH-1:0]  wr_data,
    input logic             empty, 
    input logic              rd_en,
    input logic [WIDTH-1:0] rd_data,  
    input logic valid_wr, 
    input logic valid_rd
    );

   default clocking cb @(posedge clk);
   endclocking
   default disable iff (rst);
   assert property (valid_wr |-> !full);
   assert property (valid_rd |-> !empty);

endmodule",https://github.com/ARC-Lab-UF/sv-tutorial/blob/main/testbenches/assertions/fifo_tb.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (valid_wr |-> !full);"",
    ""Signals"": [""valid_wr"", ""full""],
    ""Signal Explanations"": {
      ""valid_wr"": ""A derived signal that indicates a valid write operation; it is true when the write enable is asserted and the FIFO is not full"",
      ""full"": ""A flag signal that indicates whether the FIFO is full; true when no more data can be written into the FIFO""
    },
    ""Logical Operators"": [""|->"", ""!""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication: if the antecedent is true in the current cycle then the consequent is required to be true in the same cycle"",
      ""!"": ""logical negation: inverts the value of the signal (i.e. true becomes false)""
    },
    ""Assertion Explaination"": ""The assertion states that if the valid write signal (valid_wr) is true, then it must be that the FIFO is not full (full is false).""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property (valid_rd |-> !empty);"",
    ""Signals"": [""valid_rd"", ""empty""],
    ""Signal Explanations"": {
      ""valid_rd"": ""A derived signal that indicates a valid read operation; it is true when the read enable is asserted and the FIFO is not empty"",
      ""empty"": ""A flag signal that indicates whether the FIFO is empty; true when there is no data available to be read""
    },
    ""Logical Operators"": [""|->"", ""!""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication: if the antecedent is true in the current cycle then the consequent must also be true in that cycle"",
      ""!"": ""logical negation: inverts the value of the signal (i.e. true becomes false)""
    },
    ""Assertion Explaination"": ""The assertion states that if the valid read signal (valid_rd) is true, then it must be that the FIFO is not empty (empty is false).""
  }
}"
"// Greg Stitt
// University of Florida

// Module: simple_pipeline
// Description: This module takes 8 WIDTH-bit inputs, multiplies the 4 pairs,
// and then sums the products using a 2-level adder tree. Each stage of the
// pipeline is registered, and all overflow is ignored at each stage.

//===================================================================
// Parameter Description
// WIDTH : The data width (number of bits) of the input and output
//===================================================================

//===================================================================
// Interface Description
// clk  : Clock input
// rst  : Reset input (active high)
// in   : An array of 8 WIDTH-bit inputs
// valid_in : User should assert any time the input data on ""in"" is valid.
// out  : The output of the multiply accumulate computation.
// valid_out : Asserted whenever ""out"" contains valid data.
//===================================================================

module simple_pipeline
  #(
    parameter int WIDTH=16
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic [WIDTH-1:0]  in[8],
    input logic 	     valid_in,
    output logic [WIDTH-1:0] out,
    output logic 	     valid_out
    );

   // Specifies the cycle latency of the pipeline.
   localparam int 	     LATENCY = 4;
   
   logic [WIDTH-1:0] 	     in_r[8];
   logic [WIDTH-1:0] 	     mult_r[4];
   logic [WIDTH-1:0] 	     add_r[2];
   logic [WIDTH-1:0] 	     out_r;   
   logic [0:LATENCY-1] 	     valid_delay_r;

   assign out = out_r;
   
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
	 // Reset all the registers.
	 for (int i=0; i < 8; i++) in_r[i] <= '0;
	 for (int i=0; i < 4; i++) mult_r[i] <= '0;
	 for (int i=0; i < 2; i++) add_r[i] <= '0;
	 out_r <= '0;	 
      end
      else begin
	 // Register the inputs.
	 for (int i=0; i < 8; i++) in_r[i] <= in[i];
	 // Perform the multiplications.
	 for (int i=0; i < 4; i++) mult_r[i] <= in_r[i*2] * in_r[i*2+1];
	 // Create the first level of adders.
	 for (int i=0; i < 2; i++) add_r[i] <= mult_r[i*2] + mult_r[i*2+1];
	 // Create the final adder.
	 out_r <= add_r[0] + add_r[1];
      end
   end 

   // Delay that determines when out is valid based on the pipeline latency.
   always_ff @(posedge clk or posedge rst) begin
      if (rst) begin
	 for (int i=0; i < LATENCY; i++) valid_delay_r[i] = '0;
      end
      else begin
	 valid_delay_r[0] <= valid_in;	 
	 for (int i=1; i < LATENCY; i++) valid_delay_r[i] <= valid_delay_r[i-1];
      end      
   end

   assign valid_out = valid_delay_r[LATENCY-1];   
endmodule","// Greg Stitt
// University of Florida
//
// This testbench illustrates how to create a testbench for a simple pipeline
// without an enable. It also demonstrates subtle timing differences when 
// functions are used within assertion properties.
//
// TODO: Change the commented out assertion properties to test each version. 

`timescale 1 ns / 100 ps

module simple_pipeline_sva   #(
    parameter int WIDTH=16,
    parameter int LATENCY=4
    )
   (
    input logic 	     clk,
    input logic 	     rst,
    input logic [WIDTH-1:0]  in[8],
    input logic 	     valid_in,
    input logic [WIDTH-1:0] out,
    input logic 	     valid_out
    );

    default clocking cb @(posedge clk);
    endclocking
    default disable iff (rst);
      

   function automatic logic is_out_correct1(logic [WIDTH-1:0] in[8]);      
     logic [WIDTH-1:0] sum = 0;
      
      for (int i=0; i < 4; i++) begin
         sum += in[i*2] * in[i*2+1];     
      end
      
      return sum == out;      
   endfunction
   
   // To solve the problem with the previous function, we simply add a parameter
   // to the function that takes the output from the assertion property, which
   // ensures that the output has not been changed yet after the clock edge.
   function automatic logic is_out_correct2(logic [WIDTH-1:0] in[8], logic [WIDTH-1:0] out);
      logic [WIDTH-1:0] sum = 0;
      
      for (int i=0; i < 4; i++) begin
         sum += in[i*2] * in[i*2+1];     
      end
      
      return sum == out;      
   endfunction
   
   int count;    
   always_ff @(posedge clk or posedge rst)
     if (rst) count = 0;
     else if (count < LATENCY) count ++;
      
   // Make sure the valid output is not asserted after reset until the pipeline
   // fills up.
   assert property (count < LATENCY |-> valid_out == 1'b0);

   // Make sure valid out is asserted correctly after the pipeline is full.
   assert property (count == LATENCY |-> valid_out == $past(valid_in, LATENCY));
   
      
endmodule",https://github.com/ARC-Lab-UF/sv-tutorial/blob/main/testbenches/assertions/fifo_tb.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (count < LATENCY |-> valid_out == 1'b0);"",
    ""Signals"": [""count"", ""LATENCY"", ""valid_out""],
    ""Signal Explanations"": {
      ""count"": ""A cycle counter that tracks how many clock cycles have passed since reset, indicating how many stages of the pipeline have been filled."",
      ""LATENCY"": ""A parameter that specifies the total number of pipeline stages (the cycle latency)."",
      ""valid_out"": ""A signal indicating when the pipeline's output ('out') contains valid computed data.""
    },
    ""Logical Operators"": [""<"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""<"": ""The 'less than' comparison operator used to check if one value is smaller than another."",
      ""|->"": ""The non-overlapping implication operator which specifies that if the antecedent condition is true, then the consequent must hold (in the same clock cycle) without overlapping the antecedent."",
      ""=="": ""The equality comparison operator.""
    },
    ""Assertion Explaination"": ""This assertion states that if the cycle counter 'count' is less than the pipeline latency 'LATENCY' (meaning the pipeline has not yet been fully filled), then the 'valid_out' signal must be equal to 0. This ensures that the output is not considered valid until the full pipeline delay has elapsed.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property (count == LATENCY |-> valid_out == $past(valid_in, LATENCY));"",
    ""Signals"": [""count"", ""LATENCY"", ""valid_out"", ""valid_in"", ""$past""],
    ""Signal Explanations"": {
      ""count"": ""A cycle counter that increments each clock cycle after reset to track the filling of the pipeline stages."",
      ""LATENCY"": ""The constant representing the total number of cycles required for data to pass through the pipeline."",
      ""valid_out"": ""The signal indicating that the pipeline's output ('out') contains valid data."",
      ""valid_in"": ""The input signal that indicates when the data entering the pipeline is valid."",
      ""$past"": ""A built-in function used to reference the value of a signal from a specified number of previous clock cycles.""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""The equality operator used to verify that two values are identical."",
      ""|->"": ""The non-overlapping implication operator which means that if the antecedent condition holds, then the consequent must be true in the related clock cycle.""
    },
    ""Assertion Explaination"": ""This assertion specifies that when the cycle counter 'count' exactly equals 'LATENCY' (indicating the pipeline has been completely filled), the 'valid_out' signal must be equal to the value of 'valid_in' captured 'LATENCY' cycles ago (using $past). This confirms that the valid signal is properly pipelined through all stages.""
  }
}"
"
// AHB to APG Bridge | Maven Silicon
//
//
//
// APB FSM Controller
// Date:08-06-2022
//
// By-Prajwal Kumar Sahu

module APB_FSM_Controller( Hclk,Hresetn,valid,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata,Hwrite,Haddr,Hwdata,Hwritereg,tempselx, 
			   Pwrite,Penable,Pselx,Paddr,Pwdata,Hreadyout);

input Hclk,Hresetn,valid,Hwrite,Hwritereg;
input [31:0] Hwdata,Haddr,Haddr1,Haddr2,Hwdata1,Hwdata2,Prdata;
input [2:0] tempselx;
output reg Pwrite,Penable;
output reg Hreadyout;  
output reg [2:0] Pselx;
output reg [31:0] Paddr,Pwdata;

//////////////////////////////////////////////////////PARAMETERS

parameter ST_IDLE=3'b000;
parameter ST_WWAIT=3'b001;
parameter ST_READ= 3'b010;
parameter ST_WRITE=3'b011;
parameter ST_WRITEP=3'b100;
parameter ST_RENABLE=3'b101;
parameter ST_WENABLE=3'b110;
parameter ST_WENABLEP=3'b111;


//////////////////////////////////////////////////// PRESENT STATE LOGIC

reg [2:0] PRESENT_STATE,NEXT_STATE;

always @(posedge Hclk)
 begin:PRESENT_STATE_LOGIC
  if (~Hresetn)
    PRESENT_STATE<=ST_IDLE;
  else
    PRESENT_STATE<=NEXT_STATE;
 end


/////////////////////////////////////////////////////// NEXT STATE LOGIC

always @(PRESENT_STATE,valid,Hwrite,Hwritereg)
 begin:NEXT_STATE_LOGIC
  case (PRESENT_STATE)
    
 	ST_IDLE:begin
		 if (~valid)
		  NEXT_STATE=ST_IDLE;
		 else if (valid && Hwrite)
		  NEXT_STATE=ST_WWAIT;
		 else 
		  NEXT_STATE=ST_READ;
		end    

	ST_WWAIT:begin
		 if (~valid)
		  NEXT_STATE=ST_WRITE;
		 else
		  NEXT_STATE=ST_WRITEP;
		end

	ST_READ: begin
		   NEXT_STATE=ST_RENABLE;
		 end

	ST_WRITE:begin
		  if (~valid)
		   NEXT_STATE=ST_WENABLE;
		  else
		   NEXT_STATE=ST_WENABLEP;
		 end

	ST_WRITEP:begin
		   NEXT_STATE=ST_WENABLEP;
		  end

	ST_RENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLE:begin
		     if (~valid)
		      NEXT_STATE=ST_IDLE;
		     else if (valid && Hwrite)
		      NEXT_STATE=ST_WWAIT;
		     else
		      NEXT_STATE=ST_READ;
		   end

	ST_WENABLEP:begin
		      if (~valid && Hwritereg)
		       NEXT_STATE=ST_WRITE;
		      else if (valid && Hwritereg)
		       NEXT_STATE=ST_WRITEP;
		      else
		       NEXT_STATE=ST_READ;
		    end

	default: begin
		   NEXT_STATE=ST_IDLE;
		  end
  endcase
 end


////////////////////////////////////////////////////////OUTPUT LOGIC:COMBINATIONAL

reg Penable_temp,Hreadyout_temp,Pwrite_temp;
reg [2:0] Pselx_temp;
reg [31:0] Paddr_temp, Pwdata_temp;

always @(*)
 begin:OUTPUT_COMBINATIONAL_LOGIC
   case(PRESENT_STATE)
    
	ST_IDLE: begin
			  if (valid && ~Hwrite) 
			   begin:IDLE_TO_READ
			        Paddr_temp=Haddr;
				Pwrite_temp=Hwrite;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Hreadyout_temp=0;
			   end
			  
			  else if (valid && Hwrite)
			   begin:IDLE_TO_WWAIT
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;			   
			   end
			   
			  else
                            begin:IDLE_TO_IDLE
			        Pselx_temp=0;
				Penable_temp=0;
				Hreadyout_temp=1;	
			   end
		     end    

	ST_WWAIT:begin
	          if (~valid) 
			   begin:WAIT_TO_WRITE
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Penable_temp=0;
				Pwdata_temp=Hwdata;
				Hreadyout_temp=0;
			   end
			  
			  else 
			   begin:WAIT_TO_WRITEP
			    Paddr_temp=Haddr1;
				Pwrite_temp=1;
				Pselx_temp=tempselx;
				Pwdata_temp=Hwdata;
				Penable_temp=0;
				Hreadyout_temp=0;		   
			   end
			   
		     end  

	ST_READ: begin:READ_TO_RENABLE
			  Penable_temp=1;
			  Hreadyout_temp=1;
		     end

	ST_WRITE:begin
              if (~valid) 
			   begin:WRITE_TO_WENABLE
				Penable_temp=1;
				Hreadyout_temp=1;
			   end
			  
			  else 
			   begin:WRITE_TO_WENABLEP ///DOUBT
				Penable_temp=1;
				Hreadyout_temp=1;		   
			   end
		     end

	ST_WRITEP:begin:WRITEP_TO_WENABLEP
               Penable_temp=1;
			   Hreadyout_temp=1;
		      end

	ST_RENABLE:begin
	            if (valid && ~Hwrite) 
				 begin:RENABLE_TO_READ
					Paddr_temp=Haddr;
					Pwrite_temp=Hwrite;
					Pselx_temp=tempselx;
					Penable_temp=0;
					Hreadyout_temp=0;
				 end
			  
			  else if (valid && Hwrite)
			    begin:RENABLE_TO_WWAIT
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;			   
			    end
			   
			  else
                begin:RENABLE_TO_IDLE
			     Pselx_temp=0;
				 Penable_temp=0;
				 Hreadyout_temp=1;	
			    end

		       end

	ST_WENABLEP:begin
                 if (~valid && Hwritereg) 
			      begin:WENABLEP_TO_WRITEP
			       Paddr_temp=Haddr2;
				   Pwrite_temp=Hwrite;
				   Pselx_temp=tempselx;
				   Penable_temp=0;
				   Pwdata_temp=Hwdata;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLEP_TO_WRITE_OR_READ /////DOUBT
			      Paddr_temp=Haddr2;
				  Pwrite_temp=Hwrite;
				  Pselx_temp=tempselx;
				  Pwdata_temp=Hwdata;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end
		        end

	ST_WENABLE :begin
	             if (~valid && Hwritereg) 
			      begin:WENABLE_TO_IDLE
				   Pselx_temp=0;
				   Penable_temp=0;
				   Hreadyout_temp=0;
				  end

			  
			    else 
			     begin:WENABLE_TO_WAIT_OR_READ /////DOUBT
				  Pselx_temp=0;
				  Penable_temp=0;
				  Hreadyout_temp=0;		   
			     end

		        end

 endcase
end


////////////////////////////////////////////////////////OUTPUT LOGIC:SEQUENTIAL

always @(posedge Hclk)
 begin
  
  if (~Hresetn)
   begin
    Paddr<=0;
	Pwrite<=0;
	Pselx<=0;
	Pwdata<=0;
	Penable<=0;
	Hreadyout<=0;
   end
  
  else
   begin
        Paddr<=Paddr_temp;
	Pwrite<=Pwrite_temp;
	Pselx<=Pselx_temp;
	Pwdata<=Pwdata_temp;
	Penable<=Penable_temp;
	Hreadyout<=Hreadyout_temp;
   end
 end
 ///////////////////////


endmodule","module APB_FSM_Controller_sva(input wire Hclk,
                              input wire Hresetn,
                              input wire valid,
                              input wire Hwrite,
                              input wire [31:0] Hwdata,
                              input wire [31:0] Haddr,
                              input wire [31:0] Haddr1,
                              input wire [31:0] Haddr2,
                              input wire [31:0] Hwdata1,
                              input wire [31:0] Hwdata2,
                              input wire [31:0] Prdata,
                              input wire [2:0] tempselx,
                              input wire Hwritereg,
                              input wire Pwrite,
                              input wire Penable,
                              input wire [2:0] Pselx,
                              input wire [31:0] Paddr,
                              input wire [31:0] Pwdata,
                              input wire Hreadyout,
                              input wire [2:0] PRESENT_STATE,
                              input wire [2:0] NEXT_STATE);
//PARAMETERS

parameter ST_IDLE=3'b000;
parameter ST_WWAIT=3'b001;
parameter ST_READ= 3'b010;
parameter ST_WRITE=3'b011;
parameter ST_WRITEP=3'b100;
parameter ST_RENABLE=3'b101;
parameter ST_WENABLE=3'b110;
parameter ST_WENABLEP=3'b111;

    // Assertions, assumptions and cover properties go here

// Property to verify that PRESENT_STATE becomes NEXT_STATE one cycle later
property p_state_transition;
    @(posedge Hclk) disable iff (!Hresetn) 1 |-> ##2 PRESENT_STATE == $past(NEXT_STATE);
endproperty
assert_state_transition: assert property (p_state_transition);



// Transition from ST_IDLE
property p_IDLE_to_WWAIT;
    @(posedge Hclk) disable iff (!Hresetn) 
    (PRESENT_STATE == ST_IDLE && valid && Hwrite) |-> (NEXT_STATE == ST_WWAIT);
endproperty
assert_IDLE_to_WWAIT: assert property (p_IDLE_to_WWAIT);

property p_IDLE_to_READ;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_IDLE && valid && !Hwrite |-> NEXT_STATE == ST_READ;
endproperty
assert_IDLE_to_READ: assert property (p_IDLE_to_READ);

property p_IDLE_to_IDLE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_IDLE && !valid |-> NEXT_STATE == ST_IDLE;
endproperty
assert_IDLE_to_IDL: assert property (p_IDLE_to_IDLE);
///////////////////////////

// Transition from ST_WWAIT
property p_WWAIT_to_WRITE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WWAIT && !valid |-> NEXT_STATE == ST_WRITE;
endproperty
assert_WWAIT_to_WRITE: assert property (p_WWAIT_to_WRITE);

property p_WWAIT_to_WRITEP;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WWAIT && valid |-> NEXT_STATE == ST_WRITEP;
endproperty
assert_WWAIT_to_WRITEP: assert property (p_WWAIT_to_WRITEP);
///////////////////////////

// Transition from ST_READ
property p_READ_to_RENABLE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE;
endproperty
assert_READ_to_RENABLE: assert property (p_READ_to_RENABLE);
///////////////////////////

// Transition from ST_WRITE
property p_WRITE_to_WENABLE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WRITE && !valid |-> NEXT_STATE == ST_WENABLE;
endproperty
assert_WRITE_to_WENABLE: assert property (p_WRITE_to_WENABLE);

property p_WRITE_to_WENABLEP;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WRITE && valid |-> NEXT_STATE == ST_WENABLEP;
endproperty
assert_WRITE_to_WENABLEP: assert property (p_WRITE_to_WENABLEP);
///////////////////////////

// Transition from ST_WRITEP
property p_WRITEP_to_WENABLEP;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP;
endproperty
assert_WRITEP_to_WENABLEP: assert property (p_WRITEP_to_WENABLEP);
///////////////////////////

// Transitions from ST_RENABLE
property p_RENABLE_to_IDLE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_RENABLE && !valid |-> NEXT_STATE == ST_IDLE;
endproperty
assert_RENABLE_to_IDLE: assert property (p_RENABLE_to_IDLE);

property p_RENABLE_to_WWAIT;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_RENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT;
endproperty
assert_RENABLE_to_WWAIT: assert property (p_RENABLE_to_WWAIT);

property p_RENABLE_to_READ;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_RENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ;
endproperty
assert_RENABLE_to_READ: assert property (p_RENABLE_to_READ);
///////////////////////////

// Transitions from ST_WENABLE
property p_WENABLE_to_IDLE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WENABLE && !valid |-> NEXT_STATE == ST_IDLE;
endproperty
assert_WENABLE_to_IDLE: assert property (p_WENABLE_to_IDLE);

property p_WENABLE_to_WWAIT;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT;
endproperty
assert_WENABLE_to_WWAIT: assert property (p_WENABLE_to_WWAIT);

property p_WENABLE_to_READ;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ;
endproperty
assert_WENABLE_to_READ: assert property (p_WENABLE_to_READ);
///////////////////////////

// Transitions from ST_WENABLEP
property p_WENABLEP_to_WRITE;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WENABLEP && !valid && Hwritereg |-> NEXT_STATE == ST_WRITE;
endproperty
assert_WENABLEP_to_WRITE: assert property (p_WENABLEP_to_WRITE);

property p_WENABLEP_to_WRITEP;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WENABLEP && valid && Hwritereg |-> NEXT_STATE == ST_WRITEP;
endproperty
assert_WENABLEP_to_WRITEP: assert property (p_WENABLEP_to_WRITEP);

property p_WENABLEP_to_READ;
    @(posedge Hclk) disable iff (!Hresetn) PRESENT_STATE == ST_WENABLEP && !Hwritereg |-> NEXT_STATE == ST_READ;
endproperty
assert_WENABLEP_to_READ: assert property (p_WENABLEP_to_READ);


endmodule


",https://github.com/Ghonimo/Formal-Verification-of-an-AHB2APB-Bridge/tree/main,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (p_state_transition);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""NEXT_STATE""],
    ""Signal Explanations"": {
      ""Hclk"": ""the clock signal that triggers state transitions"",
      ""Hresetn"": ""active low reset signal that initializes the state machine"",
      ""PRESENT_STATE"": ""register holding the current state of the FSM"",
      ""NEXT_STATE"": ""combinational signal computed as the next state of the FSM""
    },
    ""Logical Operators"": [""disable iff"", ""!"", ""|->"", ""##2"", ""=="", ""$past""],
    ""Logical Operators Explanation"": {
      ""disable iff"": ""disables the assertion check when the specified condition is true"",
      ""!"": ""logical NOT operator"",
      ""|->"": ""non-overlapping implication (if antecedent then, after a delay, consequent must hold)"",
      ""##2"": ""temporal delay operator that waits for 2 clock cycles before evaluating the consequent"",
      ""=="": ""equality operator"",
      ""$past"": ""refers to the value of a signal in a previous clock cycle""
    },
    ""Assertion Explaination"": ""At every positive edge of Hclk, provided that Hresetn is active (not reset), the assertion mandates that two clock cycles later, the current PRESENT_STATE must equal the value of NEXT_STATE as captured in the previous cycle. This checks that the next state computed earlier correctly becomes the present state after the required delay.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property (p_IDLE_to_WWAIT);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE"", ""ST_IDLE"", ""ST_WWAIT""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for synchronizing state transitions"",
      ""Hresetn"": ""active low reset signal for the FSM"",
      ""PRESENT_STATE"": ""current state register of the FSM"",
      ""valid"": ""input signal indicating the validity of an operation"",
      ""Hwrite"": ""input signal indicating a write operation"",
      ""NEXT_STATE"": ""next state combinational signal for the FSM"",
      ""ST_IDLE"": ""parameter representing the IDLE state"",
      ""ST_WWAIT"": ""parameter representing the write wait state""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator that requires both conditions to be true"",
      ""|->"": ""non-overlapping implication meaning if the antecedent holds then the consequent must occur in the next evaluation phase"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When at a positive edge of the clock the FSM is in the IDLE state, and both valid and Hwrite are asserted, the assertion requires that the NEXT_STATE must be equal to ST_WWAIT. This ensures that on a valid write operation from IDLE, the FSM correctly transitions into the write wait state.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property (p_IDLE_to_READ);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE"", ""ST_IDLE"", ""ST_READ""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal driving the FSM progress"",
      ""Hresetn"": ""active low reset to initialize the FSM"",
      ""PRESENT_STATE"": ""current state of the FSM"",
      ""valid"": ""indicates that an operation (read or write) is taking place"",
      ""Hwrite"": ""indicates a write operation; here its low implies a read operation"",
      ""NEXT_STATE"": ""next state computed for the FSM"",
      ""ST_IDLE"": ""constant representing the idle state of the FSM"",
      ""ST_READ"": ""constant representing the read state of the FSM""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator requiring both conditions to be true"",
      ""!"": ""logical NOT operator, here used to negate Hwrite"",
      ""|->"": ""non-overlapping implication meaning the consequent must follow if the antecedent is true"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""On a positive edge of Hclk, if the FSM is in the IDLE state, valid is asserted and Hwrite is false (indicating a read), then the assertion requires that NEXT_STATE becomes ST_READ. This ensures that a valid read operation from the IDLE state properly triggers the transition to the read state.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property (p_IDLE_to_IDLE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_IDLE""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal of the FSM"",
      ""Hresetn"": ""active low reset for the FSM"",
      ""PRESENT_STATE"": ""current state register, here expected to be IDLE"",
      ""valid"": ""indicates whether an operation is requested"",
      ""NEXT_STATE"": ""signal representing the next state of the FSM"",
      ""ST_IDLE"": ""parameter representing the idle state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator, used here to indicate 'not valid'"",
      ""|->"": ""non-overlapping implication indicating that if the antecedent holds then the consequent must follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the IDLE state and the valid signal is not asserted, the assertion requires that the NEXT_STATE remains ST_IDLE. This ensures that in the absence of a valid operation, the FSM stays in the idle state.""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property (p_WWAIT_to_WRITE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_WWAIT"", ""ST_WRITE""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal synchronizing state transitions"",
      ""Hresetn"": ""active low reset signal of the FSM"",
      ""PRESENT_STATE"": ""current state of the FSM, here expected to be ST_WWAIT"",
      ""valid"": ""signal that indicates if an operation is ongoing"",
      ""NEXT_STATE"": ""signal representing what the next state will be"",
      ""ST_WWAIT"": ""parameter representing the write wait state"",
      ""ST_WRITE"": ""parameter representing the write state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator, here used to indicate that valid is not asserted"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent is true then the consequent must follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the ST_WWAIT state and the valid signal is de-asserted, the assertion requires that the NEXT_STATE becomes ST_WRITE. This confirms that in the absence of a valid operation in write-wait, the FSM properly transitions to the write state.""
  },
  ""Assertion 6"": {
    ""Assertion"": ""assert property (p_WWAIT_to_WRITEP);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_WWAIT"", ""ST_WRITEP""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for the FSM"",
      ""Hresetn"": ""active low reset signal for the FSM"",
      ""PRESENT_STATE"": ""current state, here expected to be ST_WWAIT"",
      ""valid"": ""signal indicating a valid operation is in progress"",
      ""NEXT_STATE"": ""signal that will hold the next state"",
      ""ST_WWAIT"": ""constant representing the write wait state"",
      ""ST_WRITEP"": ""constant representing the write priority state""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""|->"": ""non-overlapping implication ensuring the consequent follows if the antecedent holds"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the write wait state and the valid signal is asserted, this assertion requires that NEXT_STATE becomes ST_WRITEP. This ensures that the FSM transitions to the write priority state when a valid operation is requested during the wait.""
  },
  ""Assertion 7"": {
    ""Assertion"": ""assert property (p_READ_to_RENABLE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""NEXT_STATE"", ""ST_READ"", ""ST_RENABLE""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal controlling the FSM transitions"",
      ""Hresetn"": ""active low reset signal for the FSM"",
      ""PRESENT_STATE"": ""current state of the FSM, here expected to be ST_READ"",
      ""NEXT_STATE"": ""signal representing the next state of the FSM"",
      ""ST_READ"": ""parameter representing the read state"",
      ""ST_RENABLE"": ""parameter representing the read enable state""
    },
    ""Logical Operators"": [""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication, meaning when the antecedent holds the consequent must occur next"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the read state (ST_READ) at a clock edge, then the assertion requires that NEXT_STATE becomes ST_RENABLE. This guarantees that a read operation transitions into the read enable stage.""
  },
  ""Assertion 8"": {
    ""Assertion"": ""assert property (p_WRITE_to_WENABLE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_WRITE"", ""ST_WENABLE""],
    ""Signal Explanations"": {
      ""Hclk"": ""global clock signal for the FSM"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state of the FSM, here expected to be ST_WRITE"",
      ""valid"": ""signal indicating whether an operation is valid"",
      ""NEXT_STATE"": ""signal representing the next computed state"",
      ""ST_WRITE"": ""parameter representing the write state"",
      ""ST_WENABLE"": ""parameter representing the write enable state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator, used here to indicate that valid is not asserted"",
      ""|->"": ""non-overlapping implication indicating that if the antecedent holds then the consequent must follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When in the write state (ST_WRITE) and the valid signal is de-asserted, the assertion requires that NEXT_STATE becomes ST_WENABLE. This ensures that a write operation with no subsequent valid input moves into the write enable stage.""
  },
  ""Assertion 9"": {
    ""Assertion"": ""assert property (p_WRITE_to_WENABLEP);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_WRITE"", ""ST_WENABLEP""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for the FSM operation"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state register, here ST_WRITE"",
      ""valid"": ""signal denoting a valid operation is occurring"",
      ""NEXT_STATE"": ""signal representing the upcoming state"",
      ""ST_WRITE"": ""constant representing the write state"",
      ""ST_WENABLEP"": ""constant representing the write enable priority state""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""|->"": ""non-overlapping implication, meaning next state must follow if conditions hold"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the write state (ST_WRITE) and the valid signal is asserted, the assertion requires that NEXT_STATE is set to ST_WENABLEP. This confirms that a valid write operation transitions into the prioritized write enable state.""
  },
  ""Assertion 10"": {
    ""Assertion"": ""assert property (p_WRITEP_to_WENABLEP);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""NEXT_STATE"", ""ST_WRITEP"", ""ST_WENABLEP""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal driving the FSM"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state of the FSM, here expected to be ST_WRITEP"",
      ""NEXT_STATE"": ""signal representing the next state of the FSM"",
      ""ST_WRITEP"": ""constant representing the write priority state"",
      ""ST_WENABLEP"": ""constant representing the write enable priority state""
    },
    ""Logical Operators"": [""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication operator ensuring the consequent follows the antecedent in the next evaluation"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the write priority state (ST_WRITEP), the assertion mandates that the NEXT_STATE becomes ST_WENABLEP. This verifies that a write priority operation moves correctly into the write enable priority phase.""
  },
  ""Assertion 11"": {
    ""Assertion"": ""assert property (p_RENABLE_to_IDLE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_RENABLE"", ""ST_IDLE""],
    ""Signal Explanations"": {
      ""Hclk"": ""the clock signal for the FSM"",
      ""Hresetn"": ""active low reset signal to initialize or reset the FSM"",
      ""PRESENT_STATE"": ""current state of the FSM, which here is ST_RENABLE"",
      ""valid"": ""signal indicating the presence of an ongoing operation"",
      ""NEXT_STATE"": ""the computed next state of the FSM"",
      ""ST_RENABLE"": ""parameter for the read enable state"",
      ""ST_IDLE"": ""parameter for the idle state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator (indicating that valid is false)"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent holds, then the consequent must follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""In the read enable state (ST_RENABLE), if there is no valid operation (valid is false), the assertion requires that the FSM transitions to the idle state (ST_IDLE) in the next cycle. This ensures proper idle restoration when no further operation is indicated.""
  },
  ""Assertion 12"": {
    ""Assertion"": ""assert property (p_RENABLE_to_WWAIT);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE"", ""ST_RENABLE"", ""ST_WWAIT""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for synchronizing FSM transitions"",
      ""Hresetn"": ""active low reset signal for the FSM"",
      ""PRESENT_STATE"": ""current state, here expected to be ST_RENABLE"",
      ""valid"": ""signal indicating that an operation is valid"",
      ""Hwrite"": ""signal indicating a write operation"",
      ""NEXT_STATE"": ""the next state computed by the FSM"",
      ""ST_RENABLE"": ""constant representing the read enable state"",
      ""ST_WWAIT"": ""constant representing the write wait state""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator ensuring all conditions must be met"",
      ""|->"": ""non-overlapping implication operator"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the read enable state (ST_RENABLE) and both valid and Hwrite are asserted (indicating a valid write operation), the assertion requires that NEXT_STATE transitions to ST_WWAIT. This confirms that a read enable state correctly switches to write wait when a write is requested.""
  },
  ""Assertion 13"": {
    ""Assertion"": ""assert property (p_RENABLE_to_READ);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE"", ""ST_RENABLE"", ""ST_READ""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal driving the FSM transitions"",
      ""Hresetn"": ""active low reset ensuring proper initialization"",
      ""PRESENT_STATE"": ""current state of the FSM, here ST_RENABLE"",
      ""valid"": ""signal indicating a valid operation"",
      ""Hwrite"": ""signal indicating a write operation; here its negation indicates a read"",
      ""NEXT_STATE"": ""next state output of the FSM"",
      ""ST_RENABLE"": ""parameter for the read enable state"",
      ""ST_READ"": ""parameter representing the read state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator used on Hwrite"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent holds, then the consequent should follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the read enable state (ST_RENABLE) and valid is true while Hwrite is false (indicating a read operation), then the assertion requires that NEXT_STATE becomes ST_READ. This ensures the FSM correctly transitions back into the read state for a valid read operation.""
  },
  ""Assertion 14"": {
    ""Assertion"": ""assert property (p_WENABLE_to_IDLE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""NEXT_STATE"", ""ST_WENABLE"", ""ST_IDLE""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for the state machine"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state of the FSM, expected to be ST_WENABLE"",
      ""valid"": ""signal indicating whether an operation is active"",
      ""NEXT_STATE"": ""signal representing the upcoming state"",
      ""ST_WENABLE"": ""constant representing the write enable state"",
      ""ST_IDLE"": ""constant representing the idle state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator indicating that valid is false"",
      ""|->"": ""non-overlapping implication operator"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the write enable state (ST_WENABLE) and no valid operation is indicated (valid is false), the assertion mandates that the NEXT_STATE must be ST_IDLE. This ensures that the FSM returns to the idle state when there is no active operation.""
  },
  ""Assertion 15"": {
    ""Assertion"": ""assert property (p_WENABLE_to_WWAIT);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE"", ""ST_WENABLE"", ""ST_WWAIT""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal synchronizing FSM transitions"",
      ""Hresetn"": ""active low reset signal for the FSM"",
      ""PRESENT_STATE"": ""current state, here expected to be ST_WENABLE"",
      ""valid"": ""signal indicating that an operation is active"",
      ""Hwrite"": ""signal indicating a write operation"",
      ""NEXT_STATE"": ""computed next state of the FSM"",
      ""ST_WENABLE"": ""parameter representing the write enable state"",
      ""ST_WWAIT"": ""parameter representing the write wait state""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""|->"": ""non-overlapping implication operator"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the write enable state (ST_WENABLE) and both valid and Hwrite are asserted (indicating a valid write operation), then the assertion requires that NEXT_STATE becomes ST_WWAIT. This confirms that under a valid write condition, the FSM transitions from write enable to write wait.""
  },
  ""Assertion 16"": {
    ""Assertion"": ""assert property (p_WENABLE_to_READ);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwrite"", ""NEXT_STATE"", ""ST_WENABLE"", ""ST_READ""],
    ""Signal Explanations"": {
      ""Hclk"": ""the clock signal driving state updates"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state of the FSM, here expected to be ST_WENABLE"",
      ""valid"": ""indicates whether a valid operation is present"",
      ""Hwrite"": ""signal indicating a write operation; its negation implies a read"",
      ""NEXT_STATE"": ""signal representing the next intended state"",
      ""ST_WENABLE"": ""constant for the write enable state"",
      ""ST_READ"": ""constant for the read state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator used on Hwrite"",
      ""|->"": ""non-overlapping implication operator"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the write enable state (ST_WENABLE) and valid is true while Hwrite is false (indicating a read), the assertion requires that NEXT_STATE becomes ST_READ. This guarantees that under a valid read condition, the FSM transitions appropriately from write enable to read.""
  },
  ""Assertion 17"": {
    ""Assertion"": ""assert property (p_WENABLEP_to_WRITE);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwritereg"", ""NEXT_STATE"", ""ST_WENABLEP"", ""ST_WRITE""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for the FSM transitions"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state of the FSM, here expected to be ST_WENABLEP"",
      ""valid"": ""signal indicating if an operation is valid"",
      ""Hwritereg"": ""signal that further qualifies a write operation in certain conditions"",
      ""NEXT_STATE"": ""signal representing the next state of the FSM"",
      ""ST_WENABLEP"": ""parameter for the write enable priority state"",
      ""ST_WRITE"": ""parameter for the write state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator applied to valid"",
      ""|->"": ""non-overlapping implication operator ensuring that if the antecedent holds, the consequent must follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the write enable priority state (ST_WENABLEP) and valid is de-asserted while Hwritereg is asserted, then the assertion requires that NEXT_STATE becomes ST_WRITE. This ensures that under these conditions the FSM correctly transitions from the prioritized write enable state to the write state.""
  },
  ""Assertion 18"": {
    ""Assertion"": ""assert property (p_WENABLEP_to_WRITEP);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""valid"", ""Hwritereg"", ""NEXT_STATE"", ""ST_WENABLEP"", ""ST_WRITEP""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for the FSM"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state, here expected to be ST_WENABLEP"",
      ""valid"": ""signal that indicates a valid operation"",
      ""Hwritereg"": ""signal qualifying the write operation"",
      ""NEXT_STATE"": ""signal representing the computed next state of the FSM"",
      ""ST_WENABLEP"": ""constant representing the write enable priority state"",
      ""ST_WRITEP"": ""constant representing the write priority state""
    },
    ""Logical Operators"": [""&&"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator requiring both conditions to be true"",
      ""|->"": ""non-overlapping implication operator"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""When the FSM is in the write enable priority state (ST_WENABLEP) and both valid and Hwritereg are asserted, the assertion requires that NEXT_STATE becomes ST_WRITEP. This confirms that when a valid prioritized write is indicated, the FSM transitions into the write priority state.""
  },
  ""Assertion 19"": {
    ""Assertion"": ""assert property (p_WENABLEP_to_READ);"",
    ""Signals"": [""Hclk"", ""Hresetn"", ""PRESENT_STATE"", ""Hwritereg"", ""NEXT_STATE"", ""ST_WENABLEP"", ""ST_READ""],
    ""Signal Explanations"": {
      ""Hclk"": ""clock signal for the FSM operation"",
      ""Hresetn"": ""active low reset signal"",
      ""PRESENT_STATE"": ""current state of the FSM, expected here to be ST_WENABLEP"",
      ""Hwritereg"": ""signal that determines if a write operation is to be prioritized; its negation implies a read"",
      ""NEXT_STATE"": ""signal representing what the next state will be"",
      ""ST_WENABLEP"": ""constant representing the write enable priority state"",
      ""ST_READ"": ""constant representing the read state""
    },
    ""Logical Operators"": [""&&"", ""!"", ""|->"", ""==""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical AND operator"",
      ""!"": ""logical NOT operator used on Hwritereg to indicate low"",
      ""|->"": ""non-overlapping implication operator specifying that if the antecedent holds then the consequent must follow"",
      ""=="": ""equality operator""
    },
    ""Assertion Explaination"": ""If the FSM is in the write enable priority state (ST_WENABLEP) and Hwritereg is de-asserted (indicating that a write is not prioritized), then the assertion requires that NEXT_STATE becomes ST_READ. This ensures that under these circumstances the FSM transitions to the read state.""
  }
}"
"parameter N_MASTERS = 3;
typedef bit [N_MASTERS-1:0] arb_vector;
parameter arb_vector NO_REQUEST = '{default: '0};
parameter arb_vector NO_GRANT = '{default: '0};

module busarbiter(input clk, reset, bus_ack, input arb_vector bus_req, output arb_vector bus_grant);

    enum {READY, BUSY} state_s;
    arb_vector prio_req;
    reg found;
    always @(bus_req) begin: prio
        arb_vector prio_req_v;
	found = 0;
        for (int i=0; i < N_MASTERS; i++) begin
            if(~found & (bus_req[i]==1'b1)) begin
                prio_req_v[i] = 1'b1;
                found = 1;
            end
            else begin
                prio_req_v[i] = 1'b0;
            end
        end
        prio_req <= prio_req_v;
    end

    always @(posedge clk or posedge reset) begin: ctrl
        if(reset) begin //always block triggered by reset
            state_s <= READY;
            bus_grant <= NO_GRANT;
        end
        else begin //always block triggered by clk
            case (state_s)
                READY: begin
                    if (bus_req == NO_REQUEST) begin
			state_s <= READY;
                    end
                    else begin
                        state_s <= BUSY;
                    end 
                    bus_grant <= prio_req;
                end

                BUSY: begin
                    if (bus_ack) begin
                        if (bus_req == NO_REQUEST) begin
                            state_s <= READY;
                        end
                        else begin
                            state_s <= BUSY;
                        end 
		        bus_grant <= prio_req;
		    end
                end
            endcase 
        end
    end
endmodule","// @lang=sva @ts=2

module busarbitersuit(clk, reset, bus_req, bus_grant, bus_ack); 

input logic clk;
input logic reset;

input logic [2:0] bus_req;
input logic [2:0] bus_grant;
input logic bus_ack;

parameter READY = 1'b0;
parameter BUSY  = 1'b1;

parameter NO_REQUEST = 3'b000; 
parameter NO_GRANT = 3'b000; 


// TIDAL properties must be enclosed within begin_tda and end_tda macros

// your definitions...
property p_reset;
          reset |-> bus_grant == NO_GRANT;
endproperty

property p_at_most_one_grant;
          bus_grant[0]+bus_grant[1]+bus_grant[2]<2;
endproperty

property p_at_most_one_grant_1;
          bus_grant[0] |-> (!bus_grant[1] && !bus_grant[2]);
          //bus_grant[0] |-> (!bus_grant[1] && !bus_grant[2]) || bus_grant[1] |-> (!bus_grant[0] && !bus_grant[2])  || bus_grant[2] |-> (!bus_grant[1] && !bus_grant[0]);
endproperty
property p_at_most_one_grant_2;
          bus_grant[1] |-> (!bus_grant[0] && !bus_grant[2]);
endproperty
property p_at_most_one_grant_3;
          bus_grant[2] |-> (!bus_grant[1] && !bus_grant[0]);
endproperty
property p_grant_stable;
          //bus_grant != NO_GRANT |=> ##[1:$] (bus_grant != NO_GRANT && !bus_ack);
          bus_grant != NO_GRANT && bus_ack != 1 |=> $stable(bus_grant) ;
endproperty
property p_arbitration_master0;
          (bus_req[0] && bus_grant== NO_GRANT)|| (bus_ack && bus_req[0]) |=>  (bus_grant[0] && !bus_grant[1] && !bus_grant[2]);
endproperty

property p_arbitration_master1;
          (bus_req[1] && !bus_req[0] && bus_grant== NO_GRANT) || (bus_ack && bus_req[1]&& !bus_req[0])|=>  (!bus_grant[0] && bus_grant[1] && !bus_grant[2]);
endproperty

property p_arbitration_master2;
          (bus_req[2] && !bus_req[1] && !bus_req[0] && bus_grant== NO_GRANT) || (bus_ack && bus_req[2]&& !bus_req[0] &&  !bus_req[1]) |=>  (!bus_grant[0] && !bus_grant[1] && bus_grant[2]);
endproperty

property p_grant_master1;
          //bus_grant[1] implies ($past(bus_req[1]) && !$past(bus_req[0]));
          $rose(bus_grant[1]) |-> ($past(bus_req[1]) && !$past(bus_req[0]));
endproperty
property p_grant_master2;
          //bus_grant[2] implies ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0]));
          $rose(bus_grant[2]) |-> ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0]));
endproperty

// assertions
// a_reset: assert property(@(posedge clk) p_reset);
a_atmostone: assert property(@(posedge clk) disable iff(reset) p_at_most_one_grant);
a_atmostone_1: assert property(@(posedge clk) disable iff(reset) p_at_most_one_grant_1);
a_atmostone_2: assert property(@(posedge clk) disable iff(reset) p_at_most_one_grant_2);
a_atmostone_3: assert property(@(posedge clk) disable iff(reset) p_at_most_one_grant_3);
a_grantstable: assert property(@(posedge clk) disable iff(reset) p_grant_stable);
a_arbmaster0: assert property(@(posedge clk) disable iff(reset) p_arbitration_master0);
a_arbmaster1: assert property(@(posedge clk) disable iff(reset) p_arbitration_master1);
a_arbmaster2: assert property(@(posedge clk) disable iff(reset) p_arbitration_master2);
a_grantmaster1: assert property(@(posedge clk) disable iff(reset) p_grant_master1);
a_grantmaster2: assert property(@(posedge clk) disable iff(reset) p_grant_master2);
endmodule",https://github.com/ahmedsherif99/Bus-Arbiter-Systemverilog-module-with-Formal-Verification-SVA-on-OneSpin/tree/main,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property(bus_grant[0]+bus_grant[1]+bus_grant[2] < 2);"",
    ""Signals"": [""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
    ""Signal Explanations"": {
      ""bus_grant[0]"": ""bit 0 of the bus_grant output vector representing the grant for master 0"",
      ""bus_grant[1]"": ""bit 1 of the bus_grant output vector representing the grant for master 1"",
      ""bus_grant[2]"": ""bit 2 of the bus_grant output vector representing the grant for master 2""
    },
    ""Logical Operators"": [""+"", ""<""],
    ""Logical Operators Explanation"": {
      ""+"": ""sums the values of the bits"",
      ""<"": ""checks if the sum is less than the given number""
    },
    ""Assertion Explaination"": ""This assertion ensures that the sum of the grant bits for master 0, master 1, and master 2 is less than 2; in other words, at most one master is granted at any given time.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property(bus_grant[0] |-> (!bus_grant[1] && !bus_grant[2]));"",
    ""Signals"": [""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
    ""Signal Explanations"": {
      ""bus_grant[0]"": ""bit 0 of the bus_grant output vector representing the grant for master 0"",
      ""bus_grant[1]"": ""bit 1 of the bus_grant output vector representing the grant for master 1"",
      ""bus_grant[2]"": ""bit 2 of the bus_grant output vector representing the grant for master 2""
    },
    ""Logical Operators"": [""|->"", ""!"", ""&&""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication operator; if the left expression is true then the right expression must hold in the same time frame"",
      ""!"": ""logical negation, indicating that the signal is not asserted"",
      ""&&"": ""logical and operator, ensuring that both adjacent conditions are true""
    },
    ""Assertion Explaination"": ""This assertion states that if master 0 is granted (bus_grant[0] is high), then both master 1 and master 2 must not be granted (their grant bits are low), ensuring a single grant condition for master 0.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property(bus_grant[1] |-> (!bus_grant[0] && !bus_grant[2]));"",
    ""Signals"": [""bus_grant[1]"", ""bus_grant[0]"", ""bus_grant[2]""],
    ""Signal Explanations"": {
      ""bus_grant[1]"": ""bit 1 of the bus_grant output vector representing the grant for master 1"",
      ""bus_grant[0]"": ""bit 0 of the bus_grant output vector representing the grant for master 0"",
      ""bus_grant[2]"": ""bit 2 of the bus_grant output vector representing the grant for master 2""
    },
    ""Logical Operators"": [""|->"", ""!"", ""&&""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication operator; when the left condition holds, the right condition must follow in the current or next time frame"",
      ""!"": ""logical negation, used here to represent that a signal is not asserted"",
      ""&&"": ""logical and operator, combining two conditions that must both be true""
    },
    ""Assertion Explaination"": ""This assertion ensures that if master 1 is granted (bus_grant[1] is high), then neither master 0 nor master 2 can be granted at the same time, thereby ensuring only master 1 receives the grant.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property(bus_grant[2] |-> (!bus_grant[1] && !bus_grant[0]));"",
    ""Signals"": [""bus_grant[2]"", ""bus_grant[1]"", ""bus_grant[0]""],
    ""Signal Explanations"": {
      ""bus_grant[2]"": ""bit 2 of the bus_grant output vector representing the grant for master 2"",
      ""bus_grant[1]"": ""bit 1 of the bus_grant output vector representing the grant for master 1"",
      ""bus_grant[0]"": ""bit 0 of the bus_grant output vector representing the grant for master 0""
    },
    ""Logical Operators"": [""|->"", ""!"", ""&&""],
    ""Logical Operators Explanation"": {
      ""|->"": ""non-overlapping implication operator; if the antecedent is true then the consequent must hold"",
      ""!"": ""logical negation, indicating a signal is not active"",
      ""&&"": ""logical and operator, meaning both conditions following it must be satisfied""
    },
    ""Assertion Explaination"": ""This assertion specifies that if master 2 is granted (bus_grant[2] is high), then master 1 and master 0 must not be granted (their corresponding bits are low), ensuring only master 2 is granted.""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property(bus_grant != NO_GRANT && bus_ack != 1 |=> $stable(bus_grant));"",
    ""Signals"": [""bus_grant"", ""NO_GRANT"", ""bus_ack""],
    ""Signal Explanations"": {
      ""bus_grant"": ""the output grant vector from the arbiter which indicates which master is granted access"",
      ""NO_GRANT"": ""a parameter representing a state where no master is granted (all bits low)"",
      ""bus_ack"": ""acknowledgment signal indicating that the bus transaction is complete""
    },
    ""Logical Operators"": [""!="", ""&&"", ""|=>"", ""$stable""],
    ""Logical Operators Explanation"": {
      ""!="": ""inequality operator, ensuring the value of the signal is not equal to the compared value"",
      ""&&"": ""logical and, requiring both conditions to be true"",
      ""|=>"": ""non-overlapping implication; if the left-hand condition holds, then the right-hand condition must hold in the subsequent evaluation"",
      ""$stable"": ""checks that the specified signal remains unchanged over a period""
    },
    ""Assertion Explaination"": ""This assertion declares that if the bus_grant output is not NO_GRANT and bus_ack is not asserted (not equal to 1), then the bus_grant signal must remain stable in the following cycle(s), ensuring that once a grant is issued without an acknowledgment, it does not change unexpectedly.""
  },
  ""Assertion 6"": {
    ""Assertion"": ""assert property((bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[0]) |=> (bus_grant[0] && !bus_grant[1] && !bus_grant[2]));"",
    ""Signals"": [""bus_req[0]"", ""bus_grant"", ""NO_GRANT"", ""bus_ack"", ""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
    ""Signal Explanations"": {
      ""bus_req[0]"": ""bit 0 of the bus_req vector representing the request signal from master 0"",
      ""bus_grant"": ""the output grant vector from the arbiter indicating the current grant status for the masters"",
      ""NO_GRANT"": ""a parameter indicating that no grant is currently active (all bits low)"",
      ""bus_ack"": ""the bus acknowledgment signal, indicating completion of a bus transaction"",
      ""bus_grant[0]"": ""bit 0 of the bus_grant vector, should be high if master 0 is granted"",
      ""bus_grant[1]"": ""bit 1 of the bus_grant vector, considered for mutual exclusion with master 0"",
      ""bus_grant[2]"": ""bit 2 of the bus_grant vector, considered for mutual exclusion with master 0""
    },
    ""Logical Operators"": [""&&"", ""=="", ""||"", ""|=>"", ""!"", ""&&""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and operator, used to combine conditions that must all be true"",
      ""=="": ""equality operator, checking if the signals are equal"",
      ""||"": ""logical or operator, meaning at least one of the conditions must be true"",
      ""|=>"": ""non-overlapping implication operator, specifying that if the antecedent holds then the consequent must follow"",
      ""!"": ""logical negation, indicating that the signal should not be asserted""
    },
    ""Assertion Explaination"": ""This assertion specifies that if master 0 requests the bus (bus_req[0] is high) and there is currently no grant (bus_grant equals NO_GRANT), or if bus_ack is asserted in the presence of master 0's request, then the arbiter must grant access solely to master 0 (bus_grant[0] high) while ensuring that master 1 and master 2 are not granted (bus_grant[1] and bus_grant[2] are low).""
  },
  ""Assertion 7"": {
    ""Assertion"": ""assert property((bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[1] && !bus_req[0]) |=> (!bus_grant[0] && bus_grant[1] && !bus_grant[2]));"",
    ""Signals"": [""bus_req[1]"", ""bus_req[0]"", ""bus_grant"", ""NO_GRANT"", ""bus_ack"", ""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
    ""Signal Explanations"": {
      ""bus_req[1]"": ""bit 1 of the bus_req vector representing the request signal from master 1"",
      ""bus_req[0]"": ""bit 0 of the bus_req vector representing the request signal from master 0 (higher priority than master 1)"",
      ""bus_grant"": ""the output grant vector from the arbiter indicating which master is granted access"",
      ""NO_GRANT"": ""a parameter indicating that no grant is currently active"",
      ""bus_ack"": ""the bus acknowledgment signal that indicates the completion of a transaction"",
      ""bus_grant[0]"": ""bit 0 of the bus_grant vector, which must not be set if master 1 is granted"",
      ""bus_grant[1]"": ""bit 1 of the bus_grant vector, indicating the grant for master 1"",
      ""bus_grant[2]"": ""bit 2 of the bus_grant vector, which must not be set if master 1 is granted""
    },
    ""Logical Operators"": [""&&"", ""!"", ""=="", ""||"", ""|=>"", ""&&"", ""!""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and operator, ensuring multiple conditions are met simultaneously"",
      ""!"": ""logical negation, ensuring that the specified signal is not asserted"",
      ""=="": ""equality operator, comparing signals for an exact match"",
      ""||"": ""logical or operator, meaning that at least one of the combined conditions must be true"",
      ""|=>"": ""non-overlapping implication operator, dictating that if the left-hand side condition holds, the right-hand side must be true in the subsequent observation""
    },
    ""Assertion Explaination"": ""This assertion checks that if master 1 requests access (bus_req[1] is high) while master 0 is not requesting (!bus_req[0]) and there is no current grant, or if a bus acknowledgment occurs while master 1 is requesting without master 0's request, then only master 1 should be granted access (bus_grant[1] is high) with neither master 0 nor master 2 being granted.""
  },
  ""Assertion 8"": {
    ""Assertion"": ""assert property((bus_req[2] && !bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[2] && !bus_req[0] && !bus_req[1]) |=> (!bus_grant[0] && !bus_grant[1] && bus_grant[2]));"",
    ""Signals"": [""bus_req[2]"", ""bus_req[1]"", ""bus_req[0]"", ""bus_grant"", ""NO_GRANT"", ""bus_ack"", ""bus_grant[0]"", ""bus_grant[1]"", ""bus_grant[2]""],
    ""Signal Explanations"": {
      ""bus_req[2]"": ""bit 2 of the bus_req vector representing the request signal from master 2"",
      ""bus_req[1]"": ""bit 1 of the bus_req vector representing the request signal from master 1 (higher priority than master 2)"",
      ""bus_req[0]"": ""bit 0 of the bus_req vector representing the request signal from master 0 (highest priority)"",
      ""bus_grant"": ""the output grant vector from the arbiter showing which master is granted access"",
      ""NO_GRANT"": ""a parameter representing the state where no master currently holds a grant"",
      ""bus_ack"": ""the bus acknowledgment signal showing the completion of a bus transaction"",
      ""bus_grant[0]"": ""bit 0 of the bus_grant vector, which must remain low when master 2 is granted"",
      ""bus_grant[1]"": ""bit 1 of the bus_grant vector, which must remain low when master 2 is granted"",
      ""bus_grant[2]"": ""bit 2 of the bus_grant vector, representing the grant for master 2""
    },
    ""Logical Operators"": [""&&"", ""!"", ""=="", ""||"", ""|=>"", ""&&"", ""!""],
    ""Logical Operators Explanation"": {
      ""&&"": ""logical and operator, requiring all combined conditions to be met"",
      ""!"": ""logical negation operator, asserting that a condition is false"",
      ""=="": ""equality operator, used to compare if two signals are equal"",
      ""||"": ""logical or operator, meaning that at least one condition in the group must be true"",
      ""|=>"": ""non-overlapping implication operator, used to express that if the antecedent is true then the consequent must hold in the evaluation window""
    },
    ""Assertion Explaination"": ""This assertion ensures that if master 2 requests access (bus_req[2] is high) while both master 0 and master 1 are not requesting (!bus_req[0] and !bus_req[1]) and there is no current grant, or if a bus acknowledgment occurs with master 2 requesting in the absence of higher priority requests, then only master 2 should be granted (bus_grant[2] is high) and the grant signals for master 0 and master 1 must be low.""
  },
  ""Assertion 9"": {
    ""Assertion"": ""assert property($rose(bus_grant[1]) |-> ($past(bus_req[1]) && !$past(bus_req[0])));"",
    ""Signals"": [""bus_grant[1]"", ""bus_req[1]"", ""bus_req[0]""],
    ""Signal Explanations"": {
      ""bus_grant[1]"": ""bit 1 of the bus_grant output vector representing the grant for master 1"",
      ""bus_req[1]"": ""bit 1 of the bus_req input vector representing the request signal from master 1"",
      ""bus_req[0]"": ""bit 0 of the bus_req input vector representing the request signal from master 0 (higher priority than master 1)""
    },
    ""Logical Operators"": [""$rose"", ""|->"", ""$past"", ""&&"", ""!""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects a rising edge on the signal (transition from 0 to 1)"",
      ""|->"": ""non-overlapping implication operator, meaning if the antecedent occurs then the consequent must be true in the subsequent evaluation"",
      ""$past"": ""refers to the value of a signal from the previous clock cycle"",
      ""&&"": ""logical and operator, used here to combine two conditions from the past"",
      ""!"": ""logical negation operator, indicating that the signal should have been low in the previous cycle""
    },
    ""Assertion Explaination"": ""This assertion specifies that when there is a rising edge on bus_grant[1] (indicating master 1 is being granted), it implies that in the previous cycle, master 1 had requested (bus_req[1] was high) and master 0 had not requested (!bus_req[0]).""
  },
  ""Assertion 10"": {
    ""Assertion"": ""assert property($rose(bus_grant[2]) |-> ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0])));"",
    ""Signals"": [""bus_grant[2]"", ""bus_req[2]"", ""bus_req[1]"", ""bus_req[0]""],
    ""Signal Explanations"": {
      ""bus_grant[2]"": ""bit 2 of the bus_grant output vector representing the grant for master 2"",
      ""bus_req[2]"": ""bit 2 of the bus_req input vector representing the request signal from master 2"",
      ""bus_req[1]"": ""bit 1 of the bus_req input vector representing the request signal from master 1 (higher priority than master 2)"",
      ""bus_req[0]"": ""bit 0 of the bus_req input vector representing the request signal from master 0 (highest priority)""
    },
    ""Logical Operators"": [""$rose"", ""|->"", ""$past"", ""&&"", ""!""],
    ""Logical Operators Explanation"": {
      ""$rose"": ""detects a rising edge of the signal (transition from 0 to 1)"",
      ""|->"": ""non-overlapping implication operator, enforcing that if the left-hand condition is met then the right-hand condition must hold"",
      ""$past"": ""obtains the value of a signal from the previous clock cycle"",
      ""&&"": ""logical and operator, requiring that all conditions be true"",
      ""!"": ""logical negation operator, asserting that the signal was false in the previous cycle""
    },
    ""Assertion Explaination"": ""This assertion states that when there is a rising edge on bus_grant[2] (indicating master 2 is being granted), it implies that in the previous clock cycle, master 2 had requested access (bus_req[2] was high) and neither master 1 nor master 0 had requested access (both bus_req[1] and bus_req[0] were low).""
  }
}"
"module simple_router #(
	parameter DATA_WIDTH = 32
) (
  input  rst,
  input  clk,
  input  [DATA_WIDTH-1:0] din,
  input  din_en,
  input  [1:0] addr,
  output logic [DATA_WIDTH-1:0] dout0,
  output logic [DATA_WIDTH-1:0] dout1,
  output logic [DATA_WIDTH-1:0] dout2,
  output logic [DATA_WIDTH-1:0] dout3
);

// data should be forced to 0 when not driven 
assign dout0 = {DATA_WIDTH{din_en & ( addr == 2'd0 )}} & din; 
assign dout1 = {DATA_WIDTH{din_en & ( addr == 2'd1 )}} & din; 
assign dout2 = {DATA_WIDTH{din_en & ( addr == 2'd2 )}} & din; 
assign dout3 = {DATA_WIDTH{din_en & ( addr == 2'd3 )}} & din; 


endmodule","module simple_router_sva #(
	parameter DATA_WIDTH = 32
) (
  input  rst,
  input  clk,
  input  [DATA_WIDTH-1:0] din,
  input  din_en,
  input  [1:0] addr,
  input logic [DATA_WIDTH-1:0] dout0,
  input logic [DATA_WIDTH-1:0] dout1,
  input logic [DATA_WIDTH-1:0] dout2,
  input logic [DATA_WIDTH-1:0] dout3
);

dout_zero_din_en_false: assert property (din_en | ((dout0 == 0) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0)));
dout_addr0_match: assert property ((~(din_en & (addr == 2'd0))) | ((dout0 == din) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0)));
dout_addr1_match: assert property ((~(din_en & (addr == 2'd1))) | ((dout1 == din) & (dout0 == 0) & (dout2 == 0) & (dout3 == 0)));
dout_addr2_match: assert property ((~(din_en & (addr == 2'd2))) | ((dout2 == din) & (dout0 == 0) & (dout1 == 0) & (dout3 == 0)));
dout_addr3_match: assert property ((~(din_en & (addr == 2'd3))) | ((dout3 == din) & (dout0 == 0) & (dout1 == 0) & (dout2 == 0)));

endmodule",https://github.com/Essenceia/formal_experiements/blob/master/1_Simple_Router/router.v,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (din_en | ((dout0 == 0) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0)));"",
    ""Signals"": [""din_en"", ""dout0"", ""dout1"", ""dout2"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal that indicates when din is driven"",
      ""dout0"": ""output channel 0 signal"",
      ""dout1"": ""output channel 1 signal"",
      ""dout2"": ""output channel 2 signal"",
      ""dout3"": ""output channel 3 signal""
    },
    ""Logical Operators"": [""|"", ""=="", ""&""],
    ""Logical Operators Explanation"": {
      ""|"": ""logical OR, meaning one or the other condition must be true"",
      ""=="": ""equality comparison"",
      ""&"": ""logical AND, meaning all conditions must be true together""
    },
    ""Assertion Explaination"": ""This assertion checks that either the data enable signal is true, or, if it is false, all output channels (dout0, dout1, dout2, dout3) must be equal to 0. In other words, when the router is not enabled, it forces all outputs to 0.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property ((~(din_en & (addr == 2'd0))) | ((dout0 == din) & (dout1 == 0) & (dout2 == 0) & (dout3 == 0)));"",
    ""Signals"": [""din_en"", ""addr"", ""dout0"", ""din"", ""dout1"", ""dout2"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal that indicates when din is driven"",
      ""addr"": ""2-bit address signal selecting which output channel should receive the input data"",
      ""din"": ""input data signal"",
      ""dout0"": ""output channel 0 signal"",
      ""dout1"": ""output channel 1 signal"",
      ""dout2"": ""output channel 2 signal"",
      ""dout3"": ""output channel 3 signal""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT (negation) which inverts the condition"",
      ""&"": ""logical AND, meaning all conditions must be true together"",
      ""=="": ""equality comparison"",
      ""|"": ""logical OR, meaning at least one condition must be true""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the router is enabled (din_en is true) and the address selects channel 0 (addr == 0), then channel 0's output (dout0) must match the input data (din) and all other channels (dout1, dout2, dout3) must be 0. The left side of the OR negates the specific condition when din_en is true and addr equals 0, so if that condition holds, the right side must be true.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property ((~(din_en & (addr == 2'd1))) | ((dout1 == din) & (dout0 == 0) & (dout2 == 0) & (dout3 == 0)));"",
    ""Signals"": [""din_en"", ""addr"", ""dout1"", ""din"", ""dout0"", ""dout2"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal that indicates when din is driven"",
      ""addr"": ""2-bit address signal selecting which output channel should receive the input data"",
      ""din"": ""input data signal"",
      ""dout1"": ""output channel 1 signal"",
      ""dout0"": ""output channel 0 signal"",
      ""dout2"": ""output channel 2 signal"",
      ""dout3"": ""output channel 3 signal""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT (negation) which inverts the condition"",
      ""&"": ""logical AND, meaning all conditions must be true together"",
      ""=="": ""equality comparison"",
      ""|"": ""logical OR, meaning at least one condition must be true""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the router is enabled (din_en is true) and the address selects channel 1 (addr == 1), then the output on channel 1 (dout1) must equal the input data (din) and all other outputs (dout0, dout2, dout3) must be 0. If the condition din_en and addr==1 is met, then the right side of the OR must hold.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property ((~(din_en & (addr == 2'd2))) | ((dout2 == din) & (dout0 == 0) & (dout1 == 0) & (dout3 == 0)));"",
    ""Signals"": [""din_en"", ""addr"", ""dout2"", ""din"", ""dout0"", ""dout1"", ""dout3""],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal that indicates when din is driven"",
      ""addr"": ""2-bit address signal that selects the output channel for the input data"",
      ""din"": ""input data signal"",
      ""dout2"": ""output channel 2 signal"",
      ""dout0"": ""output channel 0 signal"",
      ""dout1"": ""output channel 1 signal"",
      ""dout3"": ""output channel 3 signal""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT (negation) which inverts the condition"",
      ""&"": ""logical AND, meaning all conditions must be true together"",
      ""=="": ""equality comparison"",
      ""|"": ""logical OR, meaning at least one condition must be true""
    },
    ""Assertion Explaination"": ""This assertion verifies that if the router is enabled (din_en is true) and the address selects channel 2 (addr == 2), then channel 2's output (dout2) must equal the input data (din) while all other outputs (dout0, dout1, dout3) are forced to 0. If the enable and address condition is active, the specified routing must occur.""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property ((~(din_en & (addr == 2'd3))) | ((dout3 == din) & (dout0 == 0) & (dout1 == 0) & (dout2 == 0)));"",
    ""Signals"": [""din_en"", ""addr"", ""dout3"", ""din"", ""dout0"", ""dout1"", ""dout2""],
    ""Signal Explanations"": {
      ""din_en"": ""input data enable signal that indicates when din is driven"",
      ""addr"": ""2-bit address signal selecting which output channel receives the input data"",
      ""din"": ""input data signal"",
      ""dout3"": ""output channel 3 signal"",
      ""dout0"": ""output channel 0 signal"",
      ""dout1"": ""output channel 1 signal"",
      ""dout2"": ""output channel 2 signal""
    },
    ""Logical Operators"": [""~"", ""&"", ""=="", ""|""],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT (negation) which inverts the condition"",
      ""&"": ""logical AND, meaning all conditions must be true together"",
      ""=="": ""equality comparison"",
      ""|"": ""logical OR, meaning at least one condition must be true""
    },
    ""Assertion Explaination"": ""This assertion confirms that if the router is enabled (din_en is true) and the address selects channel 3 (addr == 3), then channel 3's output (dout3) should match the input data (din) while all other outputs (dout0, dout1, dout2) must be 0. The condition ensures correct data routing based on the address.""
  }
}"
"module second_largest #(parameter
  DATA_WIDTH = 32
) (
  input clk,
  input resetn,
  input [DATA_WIDTH-1:0] din,
  output logic [DATA_WIDTH-1:0] dout
);

reg  [DATA_WIDTH-1:0] max_q;
wire [DATA_WIDTH-1:0] max_next;
reg  [DATA_WIDTH-1:0] max2_q; // second largest
wire [DATA_WIDTH-1:0] max2_next;

wire new_max;

assign new_max   = ( max_q < din);
assign max_next  = new_max ? din : max_q;
assign max2_next = new_max ? max_q : max2_q; 

always @(posedge clk)
begin
	if(~resetn) begin
		max_q  <= {DATA_WIDTH{1'b0}}; 
		max2_q <= {DATA_WIDTH{1'b0}}; 
	end
	else begin
		max_q  <= max_next;
		max2_q <= max2_next;
	end
end

// output 
assign dout = max2_q;

`ifdef FORMAL

initial begin
	// assumption
	// max_q and max2_q are not equal on init unless 0
	a_init : assume property ( (max_q == 0 & max2_q == 0) | ( max2_q < max_q));
end

always @(posedge clk)
begin
	if (~resetn) begin
		
		// assertions
		sva_max_greater_max2: assert( (max_q == 0) | ( max_q > max2_q )); 

		// cover
		c_max_zero : cover ( max_q == 0 );
		c_change : cover ( din != dout );
		c_max_greater : cover ( max_q > max2_q );	
		c_max_update : cover ( new_max );
	end
	c_reset : cover ( resetn );
end
`endif // FORMAL 
endmodule","module second_largest_sva #(parameter
  DATA_WIDTH = 32
) (
  input clk,
  input resetn,
  input [DATA_WIDTH-1:0] din,
  input logic [DATA_WIDTH-1:0] dout,
  input logic [DATA_WIDTH-1:0] max_q,
  input logic [DATA_WIDTH-1:0] max2_q
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~resetn);

sva_max_greater_max2: assert property ( (max_q == 0) | ( max_q > max2_q )); 

endmodule
",https://github.com/Essenceia/formal_experiements/blob/master/2_Second_Largest/model.v,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property ( (max_q == 0) | ( max_q > max2_q ));"",
    ""Signals"": [""max_q"", ""max2_q""],
    ""Signal Explanations"": {
      ""max_q"": ""A register that holds the current largest value observed from the input 'din'. It is initialized to 0 upon reset and updated to 'din' when a new largest value is detected."",
      ""max2_q"": ""A register that holds the second largest value among the seen inputs. It is updated to the previous 'max_q' when a new maximum is found, ensuring it remains less than the current maximum.""
    },
    ""Logical Operators"": [""=="", ""|"", "">""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks for equality between two values."",
      ""|"": ""Logical OR operator; the overall condition is true if at least one of its operands is true."",
      "">"": ""Relational operator that returns true when the left operand is strictly greater than the right.""
    },
    ""Assertion Explaination"": ""This assertion specifies that at any given positive clock edge, either the 'max_q' register is 0 (indicating an initial state or no valid update yet) or the current maximum value ('max_q') is strictly greater than the second largest value ('max2_q'). This ensures that when a valid maximum exists, it is always greater than the second largest value tracked.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property ( (max_q == 0) | ( max_q > max2_q ));"",
    ""Signals"": [""max_q"", ""max2_q""],
    ""Signal Explanations"": {
      ""max_q"": ""A register that holds the current largest value observed from the input 'din'. It is initialized to 0 upon reset and updated to 'din' when a new largest value is detected."",
      ""max2_q"": ""A register that holds the second largest value among the seen inputs. It is updated to the previous 'max_q' when a new maximum is found, ensuring it remains less than the current maximum.""
    },
    ""Logical Operators"": [""=="", ""|"", "">""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks for equality between two values."",
      ""|"": ""Logical OR operator; the overall condition is true if at least one of its operands is true."",
      "">"": ""Relational operator that returns true when the left operand is strictly greater than the right.""
    },
    ""Assertion Explaination"": ""This assertion, applied in the separate SVA module, verifies that either 'max_q' is 0 or that its value is strictly greater than 'max2_q'. This confirms that, beyond the reset condition, the maximum value remains distinctly higher than the second largest value, preserving the intended behavior of tracking the two highest values.""
  }
}"
"module Gray_Code_Counter #(parameter
  DATA_WIDTH = 4
) (
  input clk,
  input resetn,
  output logic [DATA_WIDTH-1:0] out
);

reg  [DATA_WIDTH-1:0] bin_q;	
wire [DATA_WIDTH-1:0] bin_next;	
wire                  unused_bin_inc;
reg  [DATA_WIDTH-1:0] gray_q;	
wire [DATA_WIDTH-1:0] gray_next;	

always @(posedge clk)
begin
	if(~resetn) begin
		bin_q  <= {DATA_WIDTH{1'd1}};;
		gray_q <= {DATA_WIDTH{1'd0}};
	end else begin
		bin_q  <= bin_next;
		gray_q <= gray_next;
	end
end

assign { unused_bin_inc, bin_next } = bin_q + {DATA_WIDTH{1'd1}};
assign gray_next = bin_q ^ ( bin_q >> 1 );

assign out = gray_q;

endmodule","module Gray_Code_Counter_sva #(parameter
  DATA_WIDTH = 4
) (
  input clk,
  input resetn,
  input logic [DATA_WIDTH-1:0] out,
  input unused_bin_inc,
  input logic [DATA_WIDTH-1:0] gray_q,	
  input logic [DATA_WIDTH-1:0] gray_next
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~resetn);

sva_gray_1_bit_diff : assert property ( unused_bin_inc |  $onehot( gray_next ^ gray_q ) );


endmodule",https://github.com/Essenceia/formal_experiements/blob/master/4_Gray_Code_Counter/model.v,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (unused_bin_inc | $onehot( gray_next ^ gray_q ));"",
    ""Signals"": [
      ""unused_bin_inc"",
      ""gray_next"",
      ""gray_q""
    ],
    ""Signal Explanations"": {
      ""unused_bin_inc"": ""The extra bit from the binary counter increment which indicates an overflow beyond the DATA_WIDTH."",
      ""gray_next"": ""The next Gray code value computed by applying the binary-to-gray conversion (bin_q XOR (bin_q >> 1)) to the current binary count."",
      ""gray_q"": ""The current Gray code stored in the module's register.""
    },
    ""Logical Operators"": [
      ""|"",
      ""$onehot"",
      ""^""
    ],
    ""Logical Operators Explanation"": {
      ""|"": ""Logical OR operator that returns true if at least one of its operands is true."",
      ""$onehot"": ""A function that returns true if exactly one bit in its operand is set to 1."",
      ""^"": ""Bitwise XOR operator that returns a bitwise comparison between two bit vectors, indicating differences in each bit.""
    },
    ""Assertion Explaination"": ""This assertion verifies that either the overflow flag 'unused_bin_inc' is active or the change from the current Gray code ('gray_q') to the next Gray code ('gray_next') involves exactly one bit difference. The XOR operation identifies which bits differ between 'gray_q' and 'gray_next', and the $onehot function ensures that only one of those bits is different, thereby enforcing the Gray code property (only one bit changes between consecutive values) unless an overflow (unused_bin_inc) occurs.""
  }
}"
"module reversing_bits #(
	parameter DATA_WIDTH=3
) 
(
  input clk,
  input rst,
  input  [DATA_WIDTH-1:0]       din,
  output logic [DATA_WIDTH-1:0] dout
);

genvar i;
generate;
	for (i=0; i<DATA_WIDTH; i++) begin
		assign dout[i] = din[DATA_WIDTH-i-1];
	end
endgenerate

endmodule","module reversing_bits_sva #(
	parameter DATA_WIDTH=3
) 
(
  input  [DATA_WIDTH-1:0]       din,
  input logic [DATA_WIDTH-1:0] dout,
  input clk,
  input rst
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~rst);

sva_rev : assert property ( dout[0]  == din[DATA_WIDTH-1]);

endmodule",https://github.com/Essenceia/formal_experiements/blob/master/5_Reversing_Bits/model.v,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property ( dout[0] == din[DATA_WIDTH-1]);"",
    ""Signals"": [""din"", ""dout""],
    ""Signal Explanations"": {
      ""din"": ""input signal of the module carrying the data bits to be reversed"",
      ""dout"": ""output signal of the module representing the reversed version of the input data""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the two values are equal""
    },
    ""Assertion Explaination"": ""This assertion checks that the least significant bit (dout[0]) of the reversed output is equal to the most significant bit (din[DATA_WIDTH-1]) of the input, ensuring that the bit reversal operation performed by the module is correct.""
  }
}"
"module Edge_Detector (
	input  clk,
	input  resetn,
	input  din,
	output dout
);

// trigger a pulse 1 cycle after din goes up
reg  edge_seen_q;
wire edge_seen_next;
reg  pulse_q;
wire pulse_next;
assign edge_seen_next = ( din & ~edge_seen_q) 
					  | ( din & edge_seen_q );
assign pulse_next      = din & ~edge_seen_q;
 
always @(posedge clk)
begin
	if ( ~resetn ) begin
		edge_seen_q <= 1'b0;
		pulse_q     <= 1'b0;
	end else begin
		edge_seen_q <= edge_seen_next;
		pulse_q     <= pulse_next;
	end
end

assign dout = pulse_q;

endmodule","module Edge_Detector_sva (
	input  clk,
	input  resetn,
	input  din,
	input dout
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~resetn);

reg din_f_q;
always @(posedge clk)
begin
	if ( ~resetn ) begin
		din_f_q <= 1'b0;
	end
	if (resetn) begin
		din_f_q <= din;
	end
end

sva_pulse : assert property ( $rose(din_f_q) == dout );

endmodule",https://github.com/Essenceia/formal_experiements/blob/master/6_Edge_Detector/model.v,"{
""Assertion 1"": {
""Assertion"": ""assert property ( $rose(din_f_q) == dout );"",
""Signals"": [""din_f_q"", ""dout""],
""Signal Explanations"": {
  ""din_f_q"": ""a registered version of the input 'din', used in the SVA module to detect the transition of 'din' from low to high"",
  ""dout"": ""the output signal 'dout' of the Edge_Detector module which produces a pulse one cycle after a rising edge on 'din'""
},
""Logical Operators"": [""$rose"", ""==""],
""Logical Operators Explanation"": {
  ""$rose"": ""detects a rising edge on a signal, i.e. a transition from 0 to 1"",
  ""=="": ""checks for equality between the two operands""
},
""Assertion Explaination"": ""The assertion verifies that when a rising edge is detected on the registered version of 'din' (din_f_q) using the '$rose' operator, the output 'dout' must be equal to the result of this rising edge detection. In other words, whenever 'din_f_q' transitions from 0 to 1, 'dout' should correctly produce a pulse, ensuring the module properly triggers the pulse one cycle after the input rises.""
}
}"
"module Parallel_In_Serial_Out_Shift_Reg #(
	parameter DATA_WIDTH = 16
) 
(
	input clk,
	input resetn,
	input [DATA_WIDTH-1:0] din,
	input                  din_en,
	output logic           dout
);

reg  [DATA_WIDTH-1:0] data_q;
wire [DATA_WIDTH-1:0] data_next;

assign data_next = din_en ? din : data_q >> 1;

always @(posedge clk)
begin
	if( ~resetn) begin
		data_q <= '0;
	end else begin
		data_q <= data_next;
	end
end

assign dout = data_q[0]; 


endmodule","module Parallel_In_Serial_Out_Shift_Reg_sva #(
	parameter DATA_WIDTH = 16
) 
(
	input clk,
	input resetn,
	input [DATA_WIDTH-1:0] din,
	input                  din_en,
	input logic           dout
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~resetn);

reg  v_f_q;
wire v_f_next;
reg  [DATA_WIDTH-1:0] din_f_q;
wire [DATA_WIDTH-1:0] din_f_next;
assign din_f_next = { 1'b0 , din_f_q[7:1] };
assign v_f_next   = resetn & din_en;

always @(posedge clk)
begin
	din_f_q <= ~resetn ? {DATA_WIDTH{1'bx}} : 
					din_en ? din : din_f_next; 
	v_f_q   <= v_f_next;
end

sva_shift_reg : assert property ( ~v_f_q | ( v_f_q & din_f_q[0] == dout )); 

endmodule",https://github.com/Essenceia/formal_experiements/blob/master/7_Parallel_In_Serial_Out_Shift_Reg/model.v,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property ( ~v_f_q | ( v_f_q & din_f_q[0] == dout ) );"",
    ""Signals"": [
      ""v_f_q"",
      ""din_f_q[0]"",
      ""dout""
    ],
    ""Signal Explanations"": {
      ""v_f_q"": ""A flag stored in the SVA module that is set when resetn is high and din_en is asserted, indicating that the input data is valid."",
      ""din_f_q[0]"": ""The least significant bit of the din_f_q register in the SVA module, which tracks the shifted input data mirroring the behavior of the serial output."",
      ""dout"": ""The serial output of the parallel-in serial-out shift register module.""
    },
    ""Logical Operators"": [
      ""~"",
      ""|"",
      ""&"",
      ""==""
    ],
    ""Logical Operators Explanation"": {
      ""~"": ""logical NOT, which inverts the value of its operand"",
      ""|"": ""logical OR, meaning the overall expression is true if at least one operand is true"",
      ""&"": ""logical AND, meaning both operands must be true for the expression to be true"",
      ""=="": ""equality operator, checking if both operands are equal""
    },
    ""Assertion Explaination"": ""The assertion states that either the valid flag (v_f_q) is not set (i.e., ~v_f_q is true), or if the valid flag is set (v_f_q is true), then the least significant bit of the captured input data (din_f_q[0]) must equal the serial output (dout). In other words, when valid data is present, the module's output must correctly reflect the lowest bit of the input data.""
  }
}"
"module Gray_To_Binary #(
	parameter DATA_WIDTH = 3
) 
(
          input clk,
          input rst,
	input [DATA_WIDTH-1:0]        gray,
	output logic [DATA_WIDTH-1:0] bin
);

wire [DATA_WIDTH-1:0] tmp [DATA_WIDTH-1:1]; 
assign tmp[1] = ( gray >> 1 ) ^ gray;

genvar x;
generate
	for( x = 2; x < DATA_WIDTH ; x++) begin
		assign tmp[x] = ( gray >> x ) ^ tmp[x-1];
	end 
endgenerate

assign bin = tmp[DATA_WIDTH-1];

endmodule","module Gray_To_Binary_sva #(
	parameter DATA_WIDTH = 3
) 
(
	input [DATA_WIDTH-1:0]        gray,
	input logic [DATA_WIDTH-1:0] bin,
          input clk,
          input rst
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~rst);

wire [DATA_WIDTH-1:0] gray_f;

// In order to construct our gray code we converter the binary
// gray = bin ^ ( bin >> 1 ) 

assign gray_f = bin ^ ( bin >> 1 );

sva_inv_bin : assert property ( gray_f == gray );

endmodule",https://github.com/Essenceia/formal_experiements/tree/master/11_Gray_To_Binary,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property ( gray_f == gray );"",
    ""Signals"": [""gray_f"", ""gray""],
    ""Signal Explanations"": {
      ""gray_f"": ""The Gray code generated from the binary signal 'bin' using the expression bin ^ (bin >> 1)."",
      ""gray"": ""The input Gray code provided to the module that should match the generated Gray code.""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks if the value on the left-hand side is equal to the value on the right-hand side.""
    },
    ""Assertion Explaination"": ""This assertion verifies that the generated Gray code 'gray_f' (which is calculated from the binary signal 'bin') is equal to the provided input Gray code 'gray'. This ensures the conversion from binary to Gray code is performed correctly.""
  }
}"
"module Programmable_Sequence_Detector 
#(
	parameter SEQ_W = 5
)
(
  input clk,
  input resetn,
  input [SEQ_W-1:0] init,
  input             din,
  input logic      seen
);

reg  [SEQ_W-1:0] seq_q;
wire [SEQ_W-1:0] seq_next;

assign seq_next = { seq_q[SEQ_W-2:0] , din } ;

always @(posedge clk) 
begin
	if ( ~resetn ) begin
		seq_q <= '0;
	end else begin
		seq_q <= seq_next;
	end
end

assign seen = seq_q == init;

endmodule","module Programmable_Sequence_Detector_sva 
#(
	parameter SEQ_W = 5
)
(
  input clk,
  input resetn,
  input [SEQ_W-1:0] init,
  input             din,
  input logic      seen,
  input logic  [SEQ_W-1:0] seq_q
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~resetn);

sva_seen : assert property ( seen == ( seq_q == init ));

endmodule",https://github.com/Essenceia/formal_experiements/tree/master/19_Programmable_Sequence_Detector,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property ( seen == ( seq_q == init ));"",
    ""Signals"": [""seen"", ""seq_q"", ""init""],
    ""Signal Explanations"": {
      ""seen"": ""The output signal that indicates whether the current sequence stored in seq_q matches the programmable sequence specified by init."",
      ""seq_q"": ""The register holding the current sequence of bits that are shifted in on every clock cycle."",
      ""init"": ""The programmable input sequence that the module is designed to detect.""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""The equality operator that compares two values, yielding true if they are identical and false otherwise.""
    },
    ""Assertion Explaination"": ""This assertion ensures that the seen signal is set to true exactly when the register seq_q is equal to the input init. It uses the equality operator to first compare seq_q and init, and then checks that the result of this comparison is equal to the seen signal, thereby confirming that the module correctly detects the programmed sequence.""
  }
}"
"module full_adder 
(
    input a,
    input b,
    input cin,
    output sum,
    output cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (a & cin) | (b & cin);
endmodule

module Ripple_Carry_Adder #(
	parameter DATA_WIDTH=8
)
(
    input [DATA_WIDTH-1:0] a,
    input [DATA_WIDTH-1:0] b,
    input clk,
    input rst,
    output logic [DATA_WIDTH-0:0] sum,
    output logic [DATA_WIDTH-1:0] cout_int
);

logic [DATA_WIDTH:0] carry;
assign carry[0] = 1'b0;

genvar x;
generate
	for( x = 0; x < DATA_WIDTH; x++ ) begin
		// instanciate adder module
		full_adder m_adder(
			.a( a[x] ),
			.b( b[x] ),
			.cin( carry[x]),
			.sum( sum[x] ),
			.cout( carry[x+1] )
		);
	end
endgenerate
// output
assign sum[DATA_WIDTH] = carry[DATA_WIDTH];
assign cout_int        = carry[DATA_WIDTH-1:0];

endmodule","// `include ""full_adder.sv""
module Ripple_Carry_Adder_sva #(
	parameter DATA_WIDTH=8
)
(
    input [DATA_WIDTH-1:0] a,
    input [DATA_WIDTH-1:0] b,
    input clk,
    input rst,
    input logic [DATA_WIDTH-0:0] sum,
    input logic [DATA_WIDTH-1:0] cout_int
);

default clocking cb @(posedge clk);
endclocking
default disable iff (~rst);

logic [DATA_WIDTH:0] res;
assign res = a + b;

sva_adder : assert property ( res == sum );

endmodule",https://github.com/Essenceia/formal_experiements/tree/master/24_Ripple_Carry_Adder,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property ( res == sum );"",
    ""Signals"": [""res"", ""sum""],
    ""Signal Explanations"": {
      ""res"": ""signal representing the expected sum computed by adding the two input vectors a and b"",
      ""sum"": ""signal representing the actual output of the ripple carry adder, which includes all sum bits and the final carry-out""
    },
    ""Logical Operators"": [""==""],
    ""Logical Operators Explanation"": {
      ""=="": ""operator that checks if the value of the left-hand side is equal to the value of the right-hand side""
    },
    ""Assertion Explaination"": ""This assertion compares the expected result (res), computed as a + b, with the actual adder output (sum) to verify that the ripple carry adder functions correctly and produces the correct binary sum.""
  }
}"
"module Flip_Flop_Array #(
	parameter DATA_W = 8,
	parameter ADDR_W = 3,
	parameter DATA_N = 8 // getting non constant error when using $pow(2,ADDR_W)
)
(
    input clk,
    input resetn,

    input [DATA_W-1:0] din,
    input [ADDR_W-1:0] addr,
    input              wr,
    input              rd,

    output logic [DATA_W-1:0] dout,
    output logic              error
);

// register file
reg   [DATA_W-1:0] data_q[DATA_N-1:0];
reg   [DATA_N-1:0] data_v_q;
logic [DATA_W-1:0] data_rd[DATA_N-1:0];
logic [DATA_N-1:0] data_v_next;
logic [DATA_N-1:0] rd_en;
logic [DATA_N-1:0] wr_en;
logic [DATA_N-1:0] addr_v;
logic rd_v;
always @(posedge clk)
begin
	if ( ~resetn ) begin
		data_v_q <= {DATA_N{1'b0}};
	end else begin
		data_v_q <= data_v_next;
	end
end

genvar x;
generate
	for( x=0; x < DATA_N; x++) begin
		assign addr_v[x] = addr == x;
		assign wr_en[x]  = wr & addr_v[x];	
		assign rd_en[x]  = rd & addr_v[x];

		assign data_v_next[x] = wr_en[x];
		assign data_rd[x] = {DATA_W{rd_en[x]}} & data_q[x];
 
		always @(posedge clk) begin
			if ( wr_en[x] ) begin
				data_q[x] <= din;
			end
		end	
	end
endgenerate
// read valid
assign rd_v  = data_v_q & rd_en;

assign error = ( rd & ~|rd_v) |  wr & rd ;

always_comb begin
	for( int i=0; i < DATA_N; i++ ) begin
		if ( 1 << i == rd_v ) dout = data_rd[i];
	end
	dout = {DATA_W{1'b0}};
end

endmodule","module Flip_Flop_Array_sva #(
	parameter DATA_W = 8,
	parameter ADDR_W = 3,
	parameter DATA_N = 8 // getting non constant error when using $pow(2,ADDR_W)
)
(
    input clk,
    input resetn,

    input [DATA_W-1:0] din,
    input [ADDR_W-1:0] addr,
    input              wr,
    input              rd,

    input logic [DATA_W-1:0] dout,
    input logic              error,
    input logic rd_v,
    input logic [DATA_N-1:0] data_v_q,
    input logic [DATA_N-1:0] rd_en
);

sva_collision_err: assert property (@(posedge clk) ~( rd & wr ) | ( rd & wr & error ));
sva_invalid_read : assert property (@(posedge clk) ~(~data_v_q & rd_en )  | (~data_v_q & rd_en & ( dout == '0 )));  
sva_sel_onehot0 : assert property (@(posedge clk) $onehot0(rd_v)); 

endmodule",https://github.com/Essenceia/formal_experiements/tree/master/25_Flip-Flop_Array,"{
""Assertion 1"": {
""Assertion"": ""assert property (@(posedge clk) ~( rd & wr ) | ( rd & wr & error ));"",
""Signals"": [""rd"", ""wr"", ""error""],
""Signal Explanations"": {
  ""rd"": ""read control signal that triggers a read operation"",
  ""wr"": ""write control signal that triggers a write operation"",
  ""error"": ""error flag output that indicates a collision or conflict condition""
},
""Logical Operators"": [""~"", ""&"", ""|""],
""Logical Operators Explanation"": {
  ""~"": ""logical negation; inverts the condition that follows"",
  ""&"": ""logical AND; true only when both operands are true"",
  ""|"": ""logical OR; true when at least one of the operands is true""
},
""Assertion Explaination"": ""This assertion ensures that if both the read (rd) and write (wr) control signals are asserted simultaneously (i.e. rd & wr is true), then the error signal must also be asserted. Alternatively, when not both operations occur together (~(rd & wr) is true), the assertion holds automatically, preventing the possibility of an unflagged collision.""
},
""Assertion 2"": {
""Assertion"": ""assert property (@(posedge clk) ~(~data_v_q & rd_en )  | (~data_v_q & rd_en & ( dout == '0 )));"",
""Signals"": [""data_v_q"", ""rd_en"", ""dout""],
""Signal Explanations"": {
  ""data_v_q"": ""vector of data valid flags for each register, indicating whether data in each location is valid"",
  ""rd_en"": ""vector of read enable signals corresponding to each register location, activated when a read is targeted"",
  ""dout"": ""data output bus that returns the read data from the register file""
},
""Logical Operators"": [""~"", ""&"", ""|"", ""==""],
""Logical Operators Explanation"": {
  ""~"": ""logical negation; inverts the condition or signal value"",
  ""&"": ""logical AND; yields true when all operands are true"",
  ""|"": ""logical OR; yields true when at least one operand is true"",
  ""=="": ""equality operator; verifies that two operands are equal""
},
""Assertion Explaination"": ""This assertion checks that if a read is attempted on a register location that has not been written to (indicated by ~data_v_q being true for that location in conjunction with rd_en), then the data output (dout) must be zero. In essence, when trying to read from an invalid or uninitialized register, the output must explicitly indicate a zero value.""
},
""Assertion 3"": {
""Assertion"": ""assert property (@(posedge clk) $onehot0(rd_v));"",
""Signals"": [""rd_v""],
""Signal Explanations"": {
  ""rd_v"": ""read valid signal that indicates which register from the array is being read; it is expected to be one-hot encoded""
},
""Logical Operators"": [""$onehot0""],
""Logical Operators Explanation"": {
  ""$onehot0"": ""a built-in SVA function that verifies the vector has at most one high bit (or is all zeros), ensuring one-hot encoding""
},
""Assertion Explaination"": ""This assertion ensures that the read valid signal (rd_v) is one-hot encoded, meaning that at most one bit is set to high. This confirms that only one register is providing valid data at any given time.""
}
}"
"module PWM #(parameter CBITS = 10) 
(input clk, input rst, input [3:0] sw, output reg pulse);
  
  wire [CBITS-1:0] pulse_wide;
  assign pulse_wide = {1'b0, sw[3:1], 6'd0};     // (CBTIS-4)

  reg [CBITS-1:0] cntR;

  always @(posedge clk) begin
    cntR <= cntR + 1;
    
    if (cntR < pulse_wide)
      pulse = 1'b1;
    else
      pulse = 1'b0;
  end

endmodule","module PWM_sva #(parameter CBITS = 10) 
(
          input clk,
          input rst, 
          input [3:0] sw, 
          input logic pulse
);

p1: assert property (@(posedge clk) (1 |-> s_eventually(~pulse)));

endmodule
",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/PWM_1.sv,"{
""Assertion 1"": {
""Assertion"": ""assert property (@(posedge clk) (1 |-> s_eventually(~pulse)));"",
""Signals"": [""clk"", ""pulse""],
""Signal Explanations"": {
  ""clk"": ""the clock signal used to synchronize the operations in the PWM module"",
  ""pulse"": ""the output pulse signal generated by the PWM module which represents the PWM output""
},
""Logical Operators"": [""|->"", ""s_eventually"", ""~""],
""Logical Operators Explanation"": {
  ""|->"": ""the strong implication operator; if the antecedent is true, then the consequent must eventually hold"",
  ""s_eventually"": ""the sequential eventually operator; it specifies that a particular condition will be true at some point in the future"",
  ""~"": ""the logical negation operator; it inverts the boolean value (so ~pulse means the pulse is low)""
},
""Assertion Explaination"": ""On every rising edge of the clock (clk), since the antecedent is the constant true (1), the assertion requires that eventually the negated pulse (~pulse), meaning the PWM output goes low, will be observed, ensuring that the pulse signal does not remain high indefinitely.""
}
}"
"module Delay 
#(
          parameter N = 750, 
          parameter CBITS = 10
) 
(input clk, input rst, output reg sig);
  reg [CBITS-1 :0] cnt;
  always @(posedge clk) begin
    if (rst) cnt = 0;
    else cnt = cnt + 1;
    if (cnt > N) begin sig = 1;
      cnt = 0; end
    else sig = 0;
  end

endmodule","module Delay_sva
#(
          parameter N = 750, 
          parameter CBITS = 10
) 
(input clk, input rst, input logic sig);

p1: assert property (@(posedge clk) s_eventually (rst || sig == 1)) ;
endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/delay_1.sv,"{
""Assertion 1"": {
""Assertion"": ""assert property (@(posedge clk) s_eventually (rst || sig == 1));"",
""Signals"": [""clk"", ""rst"", ""sig""],
""Signal Explanations"": {
  ""clk"": ""clock signal driving the sequential logic in the module"",
  ""rst"": ""reset signal that initializes the counter to zero"",
  ""sig"": ""output signal that is set to 1 when the counter exceeds the parameter N, then resets the counter""
},
""Logical Operators"": [""s_eventually"", ""||"", ""==""],
""Logical Operators Explanation"": {
  ""s_eventually"": ""a temporal operator indicating that eventually (sometime in the future) the enclosed condition must hold true"",
  ""||"": ""logical OR operator meaning that at least one of the connected conditions must be true"",
  ""=="": ""equality operator that checks if two values are equal""
},
""Assertion Explaination"": ""At every positive edge of the clock, the assertion guarantees that eventually either the reset signal is active or the output signal becomes equal to 1. In other words, following each clock event, the system will reach a state where either rst is asserted or sig is set to 1, enforcing the intended delay and reset behavior of the module.""
}
}"
"module gray #(parameter CBITS = 8) (input clk, input rst, output reg [CBITS-1:0] gray_cnt, output reg sig);
  reg [CBITS-1:0] cnt;
  always@(posedge clk, posedge rst) begin
    if (rst) begin
      cnt = 0;
    end
    else begin
      cnt = cnt + 1;
      gray_cnt = (cnt) ^ ((cnt) >> 1);
      if(gray_cnt == 0)
        sig = 1;
      else
        sig = 0;
    end
  end
  // F G (rst = F) -> G F (sig = T)
endmodule","module gray_sva #(parameter CBITS = 8) (input clk, input rst, input logic [CBITS-1:0] gray_cnt, input logic sig);

  p1: assert property (@(posedge clk) s_eventually (rst || sig == 1));
  // F G (rst = F) -> G F (sig = T)
endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/gray_1.sv,"{
""Assertion 1"": {
""Assertion"": ""assert property (@(posedge clk) s_eventually (rst || sig == 1));"",
""Signals"": [""clk"", ""rst"", ""sig""],
""Signal Explanations"": {
  ""clk"": ""The clock input signal that triggers sequential logic operations at each rising edge."",
  ""rst"": ""The reset signal; when high, it resets the internal counter to 0."",
  ""sig"": ""An output signal that is set to 1 when the Gray code counter (gray_cnt) evaluates to 0.""
},
""Logical Operators"": [""s_eventually"", ""||"", ""==""],
""Logical Operators Explanation"": {
  ""s_eventually"": ""A temporal operator that specifies that eventually the condition it precedes must hold true."",
  ""||"": ""Logical OR operator that yields true when at least one of its operands is true."",
  ""=="": ""Equality operator used here to compare the sig signal against the constant value 1.""
},
""Assertion Explaination"": ""At each rising edge of the clock, the assertion specifies that eventually either the reset signal is active or the sig output equals 1. In other words, if the reset (rst) is not high continuously, then it is expected that at some future clock cycle the sig output (which is set to 1 when the Gray code counter becomes 0) will go high. This aligns with the design intent that once reset is not active, the system must eventually assert sig.""
}
}"
"module i2c #(parameter divider = 125, parameter CBITS = 9) (input clk, input rst, input scl_not_ena, output reg data_clk);
	reg [CBITS - 1:0] cnt;	//0 to 4*divider
	reg scl_clk;
	reg stretch;
	always @(posedge clk) begin
		if(rst == 1) begin
			stretch = 0;
			cnt = 0;
		end
		if(cnt >= divider*4 - 1)
			cnt = 0;
		else if(stretch == 0)
			cnt = cnt + 1;

		if( cnt <= divider - 1) begin
			scl_clk = 0;
			data_clk = 0;
		end
		else if( divider <= cnt && cnt <= 2*divider - 1) begin
			scl_clk = 0;
			data_clk = 1;
		end
		else if( 2*divider <= cnt && cnt <= 3*divider - 1) begin
			if(scl_clk == 0 & scl_not_ena == 0)
				stretch = 1;
			else
				stretch = 0;
			scl_clk = 1;
			data_clk = 1;
		end
		else begin
			scl_clk = 1;
			data_clk = 0;
		end
	end

endmodule","module i2c_sva #(parameter divider = 125, parameter CBITS = 9) (input clk, input rst, input scl_not_ena, input logic data_clk, input logic stretch);

	p1: assert property (@(posedge clk) s_eventually rst == 1 || scl_not_ena == 1 || stretch == 1);

endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/i2c_1.sv,"{
""Assertion 1"": {
""Assertion"": ""assert property (@(posedge clk) s_eventually rst == 1 || scl_not_ena == 1 || stretch == 1);"",
""Signals"": [""rst"", ""scl_not_ena"", ""stretch""],
""Signal Explanations"": {
  ""rst"": ""reset signal that, when asserted (1), resets internal counters and clears the clock stretching control"",
  ""scl_not_ena"": ""input signal indicating that the SCL (clock line) is not enabled, used in determining when to engage clock stretching"",
  ""stretch"": ""signal that indicates whether a clock stretching condition is active in the I2C module""
},
""Logical Operators"": [""s_eventually"", ""=="", ""||""],
""Logical Operators Explanation"": {
  ""s_eventually"": ""a temporal operator specifying that eventually the condition will hold true in future clock cycles"",
  ""=="": ""equality operator which checks that a signal’s value is exactly equal to a given value"",
  ""||"": ""logical OR operator, meaning the overall expression is true if at least one of its operands is true""
},
""Assertion Explaination"": ""At every positive clock edge, it is guaranteed that eventually one of the following will occur: the reset signal is asserted (rst == 1), or the SCL not enable signal is asserted (scl_not_ena == 1), or the clock stretching signal is asserted (stretch == 1). This ensures that within the temporal window monitored by the assertion, at least one key control condition in the I2C module will become true.""
}
}"
"module lcd #(parameter clk_freq = 1, parameter CBITS = 9) (input rst, input clk, input [6:0] in_data, input lcd_enable, input [9:0] lcd_bus, output reg e, output reg[7:0] lcd_data, output reg rw, output reg rs, output reg busy);
	reg [CBITS - 1:0] cnt;			// 0 to 500*clk_freg
	reg [1:0] state;

	always @(posedge clk) begin
		rw = 0;
		rs = 0;
		busy = 0;
		lcd_data = 0;
		e = 0;
		if(state == 0) begin
			busy = 1;
			if(cnt < 500*clk_freq)				// wait 500
				cnt = cnt + 1;
			else begin							// power-up completed
				cnt = 0;
				rs = 0;
				rw = 0;
				lcd_data = 8'b00110000;
				state = 1;
			end
		end
		if(state == 1) begin
			busy = 1;
			cnt = cnt + 1;
			if(cnt < (10*clk_freq))begin			//function set
				lcd_data = {4'b0011, in_data[6], in_data[5], 2'b00};
				e = 1;
			end
			else if(cnt < (60*clk_freq))begin		// wait 50
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (70*clk_freq))begin		//display on/off control
				lcd_data = {5'b00001, in_data[4], in_data[3], in_data[2]};
				e = 1;
			end
			else if(cnt < (120*clk_freq))begin		// wait 50
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (130*clk_freq))begin		// display clear
				lcd_data = 8'b00000001;
				e = 1;
			end
			else if(cnt < (330*clk_freq))begin		// wait 200
				lcd_data = 8'b00000000;
				e = 0;
			end
			else if(cnt < (340*clk_freq))begin		// entry mode set
				lcd_data = {6'b000001, in_data[1], in_data[0]};
				e = 1;
			end
			else if(cnt < (440*clk_freq))begin		// wait 100
				lcd_data = 8'b00000000;
				e = 0;
			end
			else begin								// initialization complete
				cnt = 0;
				busy = 0;
				state = 2;
			end
		end
		if(state == 2) begin
			if(lcd_enable == 1) begin
				busy = 1;
				rs = lcd_bus[9];
				rw = lcd_bus[8];
				lcd_data = lcd_bus[7:0];
				cnt = 0;
				state = 3;
			end
			else begin
				busy = 0;
				rs = 0;
				rw = 0;
				lcd_data = 8'b00000000;
				cnt = 0;
			end
		end
		if(state == 3) begin
			if(cnt < 50* clk_freq) begin 		// do not exit for 50
				if(cnt < clk_freq)
					e = 0;
				else if(cnt < 14*clk_freq)		// positive enable half-cycle
					e = 1;
				else if(cnt < 27*clk_freq)		// negative enable half-cycle
					e = 0;
				cnt = cnt + 1;
			end
			else begin
				cnt = 0;
				state = 2;
			end
		end
	end

endmodule","module lcd_sva #(parameter clk_freq = 1, parameter CBITS = 9) (input clk, input [6:0] in_data, input lcd_enable, input [9:0] lcd_bus, input logic e, input logic[7:0] lcd_data, input logic rw, input logic rs, input logic busy, input logic [1:0] state);
	p1: assert property (@(posedge clk) s_eventually (lcd_enable == 0 || state == 2));
endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/lcd_1.sv,"{
""Assertion 1"": {
""Assertion"": ""assert property (@(posedge clk) s_eventually (lcd_enable == 0 || state == 2));"",
""Signals"": [""clk"", ""lcd_enable"", ""state""],
""Signal Explanations"": {
  ""clk"": ""clock input for the module that synchronizes all operations"",
  ""lcd_enable"": ""input signal that triggers an LCD command operation; if high, the module processes new LCD commands"",
  ""state"": ""internal register representing the current operational phase of the LCD module (with state 2 meaning ready/idle after initialization)""
},
""Logical Operators"": [""s_eventually"", ""=="", ""||""],
""Logical Operators Explanation"": {
  ""s_eventually"": ""a temporal operator indicating that eventually (in some future clock cycle) the condition inside will hold true"",
  ""=="": ""equality operator that compares two values"",
  ""||"": ""logical OR operator meaning that if either of the compared conditions is true then the overall expression is true""
},
""Assertion Explaination"": ""On every rising edge of the clock, this assertion eventually requires that either the lcd_enable signal is deasserted (i.e., equals 0) or the internal state register equals 2. In other words, the system is guaranteed to eventually reach a condition where no new LCD command is being enabled, or the LCD module has completed its initialization and is in the ready (state 2) state.""
}
}"
"module SEVEN #(parameter freq = 250, parameter CBITS = 8) (input clk, input rst, input [13:0] both7seg, output reg[6:0] segment);
	reg [CBITS-1:0] cnt;
	reg digit_select;

	always @(posedge clk) begin
		if(rst == 1) begin
			cnt = 0;
			digit_select = 0;
			segment = 0;
		end
		if(cnt < freq)
			cnt = cnt + 1;
		else begin
			cnt = 0;
			if(digit_select == 0) begin
				digit_select = 1;
				segment = both7seg[13:7];
			end
			else begin
				digit_select = 0;
				segment = both7seg[6:0];
			end
		end
	end
endmodule","module SEVEN_sva #(parameter freq = 250, parameter CBITS = 8) (input clk, input rst, input [13:0] both7seg, input logic[6:0] segment, input logic digit_select);
	p1: assert property (@(posedge clk) s_eventually rst == 1 || digit_select == 1);
	p2: assert property (@(posedge clk) s_eventually rst == 1 || digit_select == 0);
endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/seven_seg_1.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (@(posedge clk) s_eventually rst == 1 || digit_select == 1);"",
    ""Signals"": [""clk"", ""rst"", ""digit_select""],
    ""Signal Explanations"": {
      ""clk"": ""Clock input signal driving the sequential logic in the module."",
      ""rst"": ""Reset signal that initializes the counter (cnt), digit_select, and segment registers."",
      ""digit_select"": ""Register that selects which part of the 7-segment display is driven; it toggles between 0 and 1 to choose the lower or upper 7 bits of both7seg.""
    },
    ""Logical Operators"": [""s_eventually"", ""||"", ""==""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""A temporal operator indicating that eventually, in some future clock cycle, the condition will be met."",
      ""||"": ""Logical OR operator meaning that at least one of the adjacent conditions must be true."",
      ""=="": ""Equality operator used to check if a signal is equal to a specific value.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, the assertion checks that eventually either the reset signal becomes asserted (rst equals 1) or the digit_select signal becomes 1. This ensures that unless a reset occurs, the module eventually drives the upper portion (both7seg[13:7]) of the display by setting digit_select to 1.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property (@(posedge clk) s_eventually rst == 1 || digit_select == 0);"",
    ""Signals"": [""clk"", ""rst"", ""digit_select""],
    ""Signal Explanations"": {
      ""clk"": ""Clock input signal driving the sequential logic in the module."",
      ""rst"": ""Reset signal that initializes the counter (cnt), digit_select, and segment registers."",
      ""digit_select"": ""Register that selects which part of the 7-segment display is driven; it toggles between 0 and 1 to choose the lower or upper 7 bits of both7seg.""
    },
    ""Logical Operators"": [""s_eventually"", ""||"", ""==""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""A temporal operator indicating that eventually, in some future clock cycle, the condition will be met."",
      ""||"": ""Logical OR operator meaning that at least one of the adjacent conditions must be true."",
      ""=="": ""Equality operator used to check if a signal is equal to a specific value.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, this assertion requires that eventually either the reset signal becomes asserted (rst equals 1) or the digit_select signal becomes 0. This guarantees that in the absence of a reset, the module eventually drives the lower portion (both7seg[6:0]) of the 7-segment display by setting digit_select to 0.""
  }
}"
"module uart_transmit #(localparam d_width = 4, localparam c_width = 3) (input clk, input rst, input tx_ena, input [d_width - 1: 0] tx_data, output reg tx, output reg tx_busy);
	reg [c_width-1:0] tx_cnt;
	reg tx_state;
	reg [d_width+1:0] tx_buffer;

	always @(posedge clk) begin
		if(rst == 1) begin
			tx_cnt = 0;
			tx = 1;
			tx_busy = 0;
			tx_state = 0;
		end
		if(tx_state == 0) begin
			if(tx_ena == 1) begin
				tx_buffer = {tx_data, 2'b01};
				tx_busy = 1;
				tx_cnt = 0;
				tx_state = 1;
			end
			else
				tx_busy = 0;
		end
		else if(tx_state == 1) begin
			if(tx_cnt < d_width+3) begin
				tx_state = 1;
				tx_cnt = tx_cnt + 1;
				tx_buffer = {1'b1, tx_buffer[d_width+1:1]};
			end
			else begin
				tx_cnt = 0;
				tx_state = 0;
			end
		end
		tx = tx_buffer[0];
	end
endmodule","module uart_transmit_sva #(localparam d_width = 4, localparam c_width = 3) (input clk, input rst, input tx_ena, input [d_width - 1: 0] tx_data, input reg tx, input reg tx_busy, input reg tx_state);
	
	p1: assert property (@(posedge clk) s_eventually rst == 1 ||  tx_state == 0);
  	// F G (rst = FALSE) -> G F (tx_state = FALSE)
endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/uart_transmit_1.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property (@(posedge clk) s_eventually rst == 1 ||  tx_state == 0);"",
    ""Signals"": [""clk"", ""rst"", ""tx_state""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal that triggers events on every rising edge in the UART module"",
      ""rst"": ""The reset signal that, when asserted, resets the internal registers such as the transmitter state (tx_state) and buffer"",
      ""tx_state"": ""The internal state register indicating if the transmitter is active (1) or idle (0)""
    },
    ""Logical Operators"": [""s_eventually"", ""||"", ""==""],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""A temporal operator indicating that eventually (at some future clock cycle) the given condition will hold true"",
      ""||"": ""Logical OR operator, meaning that at least one of the conditions must be satisfied"",
      ""=="": ""Equality operator used for comparing a signal with a constant value""
    },
    ""Assertion Explaination"": ""At every rising edge of the clock, the property asserts that eventually either the reset signal (rst) will be asserted (i.e., equal to 1) or the transmitter will be idle (tx_state equal to 0). This means that in the long run, if the reset is not active to continuously override, then the transmitter is expected to return to its idle state.""
  }
}"
"module VGA #(localparam  size = 1, localparam h_bits = 7, localparam v_bits = 5) (input clk, input rst, output reg disp_ena, output reg n_blank, output reg n_sync, output reg [h_bits-1:0] col, output reg [v_bits-1:0] row);

	localparam h_pixels = 50*size;
	localparam h_pulse = 5*size;
	localparam h_bp = 8*size;
	localparam h_fp = 3*size;
	localparam h_pol = 0;

	localparam v_pixels =  25*size;
	localparam v_pulse = size;
	localparam v_bp = 1*size;
	localparam v_fp = size;
	localparam v_pol = 1;

	localparam h_period = h_pulse + h_bp + h_pixels + h_fp;
	localparam v_period = v_pulse + v_bp + v_pixels + v_fp;

	reg [h_bits-1:0] h_cnt;
	reg [v_bits-1:0] v_cnt;
	reg h_sync;
	reg v_sync;
	always @(posedge clk) begin
		if(rst == 1) begin
			h_cnt = 0;
			v_cnt = 0;
			h_sync = ~h_sync;
			v_sync = ~v_sync;
			disp_ena = 0;
			col = 0;
			row = 0;
		end
		else begin
			if(h_cnt < h_period - 1)
				h_cnt = h_cnt + 1;
			else begin
				h_cnt = 0;
				if(v_cnt < v_period - 1)
					v_cnt = v_cnt + 1;
				else
					v_cnt = 0;
			end
			if((h_cnt < (h_pixels + h_fp)) | (h_cnt >= (h_pixels + h_fp + h_pulse)))
				h_sync = ~h_sync;
			else
				h_sync = h_pol;

			if((v_cnt < (v_pixels + v_fp)) | (v_cnt >= (v_pixels + v_fp + v_pulse)))
				v_sync = ~v_sync;
			else
				v_sync = v_pol;

			if(h_cnt < h_pixels)
				col = h_cnt;

			if(v_cnt < v_pixels)
				row = v_cnt;

			if(h_cnt < h_pixels & v_cnt < v_pixels)
				disp_ena = 1;
			else
				disp_ena = 0;
		end
	end
endmodule","module VGA_sva #(localparam  size = 1, localparam h_bits = 7, localparam v_bits = 5) (input clk, input rst, input reg disp_ena, input reg n_blank, input reg n_sync, input reg [h_bits-1:0] col, input reg [v_bits-1:0] row);

	
	p1: assert property  (@(posedge clk) s_eventually rst == 1 || disp_ena == 1);
  	// F G !rst -> G F disp_ena
endmodule",https://github.com/diffblue/hw-cbmc/blob/main/examples/Benchmarks/vga_1.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property  (@(posedge clk) s_eventually rst == 1 || disp_ena == 1);"",
    ""Signals"": [
      ""clk"",
      ""rst"",
      ""disp_ena""
    ],
    ""Signal Explanations"": {
      ""clk"": ""clock signal used to trigger the property evaluation on its rising edge"",
      ""rst"": ""reset signal that initializes counters and synchronization signals in the VGA module"",
      ""disp_ena"": ""display enable signal that becomes active when the horizontal and vertical counters are within active pixel ranges""
    },
    ""Logical Operators"": [
      ""s_eventually"",
      ""=="",
      ""||""
    ],
    ""Logical Operators Explanation"": {
      ""s_eventually"": ""eventually, meaning that the condition following this operator will hold true at some point in the future"",
      ""=="": ""equality operator to test if a signal equals a given value"",
      ""||"": ""logical OR operator indicating that at least one of the connected conditions must be true""
    },
    ""Assertion Explaination"": ""At every rising edge of the clock, it is eventually the case that either the reset signal is high (equal to 1) or the display enable signal is high. In other words, if reset is not asserted indefinitely, the module will eventually assert disp_ena.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""F G !rst -> G F disp_ena"",
    ""Signals"": [
      ""rst"",
      ""disp_ena""
    ],
    ""Signal Explanations"": {
      ""rst"": ""reset signal that initializes and controls the state of the VGA module"",
      ""disp_ena"": ""display enable signal which indicates when the pixel display region is active""
    },
    ""Logical Operators"": [
      ""F"",
      ""G"",
      ""!"",
      ""->""
    ],
    ""Logical Operators Explanation"": {
      ""F"": ""eventually operator, meaning that a condition will occur at some point in the future"",
      ""G"": ""globally operator, meaning that a condition holds at all times in the specified interval"",
      ""!"": ""logical NOT operator, which inverts the condition of the signal"",
      ""->"": ""implication operator, meaning that if the antecedent is true then the consequent must be true""
    },
    ""Assertion Explaination"": ""This assertion states that if, eventually, it becomes true that reset remains de-asserted continuously (i.e. always not rst), then it must always subsequently be the case that, eventually, the display enable signal is asserted. In other words, following a period where reset stays inactive, disp_ena will keep recurring as an active condition.""
  }
}"
"module arb2(clk, rst, req1, req2, gnt1, gnt2);

input clk, rst;
input req1, req2;
output gnt1, gnt2;

reg state;
reg gnt1, gnt2;

always @ (posedge clk or posedge rst)
	if (rst)
		state <= 0;
	else
		state <= gnt1;

always @ (*)
	if (state)
	begin
		gnt1 = req1 & ~req2;
		gnt2 = req2;
	end
	else
	begin
		gnt1 = req1;
		gnt2 = req2 & ~req1;
	end

endmodule","module arb2_sva(
input gnt1, gnt2,
input state,
input clk, rst,
input req1,
input req2
);


property a3;
@(posedge clk) (state == 1 & req2 == 1) |-> (gnt1 == 0);
endproperty
assert_a3: assert property(a3);

property a1;
@(posedge clk) (req1 == 1 & state == 0) |-> (gnt1 == 1);
endproperty
assert_a1: assert property(a1);

property a2;
@(posedge clk) (req1 == 0) |-> (gnt1 == 0);
endproperty
assert_a2: assert property(a2);

property a0;
@(posedge clk) (req1 == 1 & req2 == 0) |-> (gnt1 == 1);
endproperty
assert_a0: assert property(a0);

property a5;
@(posedge clk) (req1 == 1 & state == 0) |-> (gnt2 == 0);
endproperty
assert_a5: assert property(a5);

property a7;
@(posedge clk) (req2 == 1 & state == 1) |-> (gnt2 == 1);
endproperty
assert_a7: assert property(a7);

property a4;
@(posedge clk) (req2 == 0) |-> (gnt2 == 0);
endproperty
assert_a4: assert property(a4);

property a6;
@(posedge clk) (req2 == 1 & req1 == 0) |-> (gnt2 == 1);
endproperty
assert_a6: assert property(a6);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/tree/NIPS_2024/Jasper_results/Arbiter,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property(a3);  where a3: @(posedge clk) (state == 1 & req2 == 1) |-> (gnt1 == 0)"",
    ""Signals"": [""state"", ""req2"", ""gnt1""],
    ""Signal Explanations"": {
      ""state"": ""internal register indicating the arbiter's current state (0 or 1) which affects how requests are granted"",
      ""req2"": ""the second input request signal to the arbiter"",
      ""gnt1"": ""the grant output signal for the first request""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the left-hand side is equal to the right-hand side"",
      ""&"": ""logical AND operator that requires both operands to be true"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent is true at a clock edge, then the consequent must hold""
    },
    ""Assertion Explaination"": ""If the internal state equals 1 and the second request signal is asserted, then, by the logical AND and equality checks, the first grant output must be deasserted (equal to 0).""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property(a1);  where a1: @(posedge clk) (req1 == 1 & state == 0) |-> (gnt1 == 1)"",
    ""Signals"": [""req1"", ""state"", ""gnt1""],
    ""Signal Explanations"": {
      ""req1"": ""the first input request signal to the arbiter"",
      ""state"": ""internal register indicating the arbiter's current state (0 or 1) affecting the grant logic"",
      ""gnt1"": ""the grant output signal for the first request""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the left-hand side is equal to the right-hand side"",
      ""&"": ""logical AND operator ensuring both conditions are met"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent is true at a clock edge, then the consequent must hold""
    },
    ""Assertion Explaination"": ""When the first request signal is asserted and the arbiter is in state 0, the equality and AND operations ensure that the first grant output is asserted (equal to 1).""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property(a2);  where a2: @(posedge clk) (req1 == 0) |-> (gnt1 == 0)"",
    ""Signals"": [""req1"", ""gnt1""],
    ""Signal Explanations"": {
      ""req1"": ""the first input request signal to the arbiter"",
      ""gnt1"": ""the grant output signal for the first request""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality between the left-hand side and the right-hand side"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent is true at a clock edge, then the consequent must hold""
    },
    ""Assertion Explaination"": ""If the first request signal is not asserted (equals 0), then the first grant output must also be deasserted (equal to 0).""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property(a0);  where a0: @(posedge clk) (req1 == 1 & req2 == 0) |-> (gnt1 == 1)"",
    ""Signals"": [""req1"", ""req2"", ""gnt1""],
    ""Signal Explanations"": {
      ""req1"": ""the first input request signal to the arbiter"",
      ""req2"": ""the second input request signal to the arbiter"",
      ""gnt1"": ""the grant output signal for the first request""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if two values are equal"",
      ""&"": ""logical AND operator that evaluates true when both operands are true"",
      ""|->"": ""non-overlapping implication that specifies if the antecedent is met at a clock edge, then the consequent must hold""
    },
    ""Assertion Explaination"": ""When the first request is asserted and the second request is not asserted, the combination of equality and AND ensures that the first grant output is provided (equal to 1).""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property(a5);  where a5: @(posedge clk) (req1 == 1 & state == 0) |-> (gnt2 == 0)"",
    ""Signals"": [""req1"", ""state"", ""gnt2""],
    ""Signal Explanations"": {
      ""req1"": ""the first input request signal to the arbiter"",
      ""state"": ""internal register controlling the arbiter's behavior"",
      ""gnt2"": ""the grant output signal for the second request""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between signals"",
      ""&"": ""logical AND that requires both conditions to be satisfied"",
      ""|->"": ""non-overlapping implication meaning if the antecedent holds at a clock edge, then the consequent must hold""
    },
    ""Assertion Explaination"": ""If the first request is asserted and the arbiter is in state 0, then according to the logical conditions the second grant output must be deasserted (equal to 0), preventing simultaneous grants.""
  },
  ""Assertion 6"": {
    ""Assertion"": ""assert property(a7);  where a7: @(posedge clk) (req2 == 1 & state == 1) |-> (gnt2 == 1)"",
    ""Signals"": [""req2"", ""state"", ""gnt2""],
    ""Signal Explanations"": {
      ""req2"": ""the second input request signal to the arbiter"",
      ""state"": ""internal register indicating the arbiter's state; here state 1 favors the second request"",
      ""gnt2"": ""the grant output signal for the second request""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""&"": ""logical AND operator that combines the conditions"",
      ""|->"": ""non-overlapping implication specifying that if the antecedent holds, then the consequent must hold at the clock edge""
    },
    ""Assertion Explaination"": ""When the second request is asserted and the arbiter is in state 1, the combined conditions ensure that the second grant output is asserted (equal to 1).""
  },
  ""Assertion 7"": {
    ""Assertion"": ""assert property(a4);  where a4: @(posedge clk) (req2 == 0) |-> (gnt2 == 0)"",
    ""Signals"": [""req2"", ""gnt2""],
    ""Signal Explanations"": {
      ""req2"": ""the second input request signal to the arbiter"",
      ""gnt2"": ""the grant output signal for the second request""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""tests whether the signals are equal"",
      ""|->"": ""non-overlapping implication meaning that if the antecedent is true at a clock edge, then the consequent must be true""
    },
    ""Assertion Explaination"": ""If the second request signal is deasserted (equals 0), the consequent condition ensures that the second grant output is also deasserted (equal to 0).""
  },
  ""Assertion 8"": {
    ""Assertion"": ""assert property(a6);  where a6: @(posedge clk) (req2 == 1 & req1 == 0) |-> (gnt2 == 1)"",
    ""Signals"": [""req2"", ""req1"", ""gnt2""],
    ""Signal Explanations"": {
      ""req2"": ""the second input request signal to the arbiter"",
      ""req1"": ""the first input request signal to the arbiter"",
      ""gnt2"": ""the grant output signal for the second request""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the operands are equal"",
      ""&"": ""logical AND operator that requires both conditions to be met"",
      ""|->"": ""non-overlapping implication that specifies if the antecedent is true at a clock edge, then the consequent must hold""
    },
    ""Assertion Explaination"": ""If the second request is asserted while the first request is not (req2 equals 1 and req1 equals 0), then the logical conditions ensure that the second grant output is asserted (equals 1).""
  }
}"
"//////////////////////////////////////////////////////////////////
////
////
//// 	AES CORE BLOCK
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// aes128_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Julio Cesar 
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////
module control_unit
(
	output reg [ 2:0] sbox_sel,
	output reg [ 1:0] rk_sel,
	output reg [ 1:0] key_out_sel,
	output reg [ 1:0] col_sel,
	output reg [ 3:0] key_en,
	output reg [ 3:0] col_en,
	output     [ 3:0] round,
	output reg bypass_rk,
	output reg bypass_key_en,
	output reg key_sel,
	output reg iv_cnt_en,
	output reg iv_cnt_sel,
	output reg key_derivation_en,
	output end_comp,
	output key_init,
	output key_gen,
	output mode_ctr,
	output mode_cbc,
	output last_round,
  output encrypt_decrypt,	
	input [1:0] operation_mode,
	input [1:0] aes_mode,
	input start,
	input disable_core,
	input clk,
	input rst_n
);
//`include ""include/host_interface.vh""
//`include ""include/control_unit_params.vh""

//=====================================================================================
// Memory Mapped Registers Address
//=====================================================================================
localparam AES_CR    = 4'd00;
localparam AES_SR    = 4'd01;
localparam AES_DINR  = 4'd02;
localparam AES_DOUTR = 4'd03;
localparam AES_KEYR0 = 4'd04;
localparam AES_KEYR1 = 4'd05;
localparam AES_KEYR2 = 4'd06;
localparam AES_KEYR3 = 4'd07;
localparam AES_IVR0  = 4'd08;
localparam AES_IVR1  = 4'd09;
localparam AES_IVR2  = 4'd10;
localparam AES_IVR3  = 4'd11;

//=============================================================================
// Operation Modes
//=============================================================================
localparam ENCRYPTION     = 2'b00;
localparam KEY_DERIVATION = 2'b01;
localparam DECRYPTION     = 2'b10;
localparam DECRYP_W_DERIV = 2'b11;

//=============================================================================
// AES Modes
//=============================================================================
localparam ECB = 2'b00;
localparam CBC = 2'b01;
localparam CTR = 2'b10;

//=============================================================================
// SBOX SEL
//=============================================================================
localparam COL_0 = 3'b000;
localparam COL_1 = 3'b001;
localparam COL_2 = 3'b010;
localparam COL_3 = 3'b011;
localparam G_FUNCTION = 3'b100;

//=============================================================================
// RK_SEL
//=============================================================================
localparam COL        = 2'b00;
localparam MIXCOL_IN  = 2'b01;
localparam MIXCOL_OUT = 2'b10;

//=============================================================================
// KEY_OUT_SEL
//=============================================================================
localparam KEY_0 = 2'b00;
localparam KEY_1 = 2'b01;
localparam KEY_2 = 2'b10;
localparam KEY_3 = 2'b11;

//=============================================================================
// COL_SEL
//=============================================================================
localparam SHIFT_ROWS = 2'b00;
localparam ADD_RK_OUT = 2'b01;
localparam INPUT      = 2'b10;

//=============================================================================
// KEY_SEL
//=============================================================================
localparam KEY_HOST = 1'b0;
localparam KEY_OUT  = 1'b1;

//=============================================================================
// KEY_EN
//=============================================================================
localparam KEY_DIS  = 4'b0000;
localparam EN_KEY_0 = 4'b0001;
localparam EN_KEY_1 = 4'b0010;
localparam EN_KEY_2 = 4'b0100;
localparam EN_KEY_3 = 4'b1000;
localparam KEY_ALL  = 4'b1111;

//=============================================================================
// COL_EN
//=============================================================================
localparam COL_DIS  = 4'b0000;
localparam EN_COL_0 = 4'b0001;
localparam EN_COL_1 = 4'b0010;
localparam EN_COL_2 = 4'b0100;
localparam EN_COL_3 = 4'b1000;
localparam COL_ALL  = 4'b1111;

//=============================================================================
// IV_CNT_SEL
//=============================================================================
localparam IV_CNT = 1'b1;
localparam IV_BUS = 1'b0;

//=============================================================================
// ENABLES
//=============================================================================
localparam ENABLE = 1'b1;
localparam DISABLE = 1'b0;

localparam NUMBER_ROUND      = 4'd10;
localparam NUMBER_ROUND_INC  = 4'd11;
localparam INITIAL_ROUND     = 4'd00;

//=============================================================================
// FSM STATES
//=============================================================================
localparam IDLE        = 4'd00;
localparam ROUND0_COL0 = 4'd01;
localparam ROUND0_COL1 = 4'd02;
localparam ROUND0_COL2 = 4'd03;
localparam ROUND0_COL3 = 4'd04;
localparam ROUND_KEY0  = 4'd05;
localparam ROUND_COL0  = 4'd06;
localparam ROUND_COL1  = 4'd07;
localparam ROUND_COL2  = 4'd08;
localparam ROUND_COL3  = 4'd09;
localparam READY       = 4'd10;
localparam GEN_KEY0    = 4'd11;
localparam GEN_KEY1    = 4'd12;
localparam GEN_KEY2    = 4'd13;
localparam GEN_KEY3    = 4'd14;
localparam NOP         = 4'd15;

reg [3:0] state, next_state;
reg [3:0] rd_count;

reg rd_count_en;
//reg end_aes_pp1, end_aes_pp2;
wire op_key_derivation;
wire first_round;
wire [1:0] op_mode;
wire enc_dec;

// State Flops Definition
always @(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			state <= IDLE;
		else
			if(disable_core)
				state <= IDLE;
			else
				state <= next_state;
	end

assign encrypt_decrypt = (op_mode == ENCRYPTION || op_mode == KEY_DERIVATION || state == GEN_KEY0   
			  ||   state == GEN_KEY1       ||state == GEN_KEY2   ||   state == GEN_KEY3       );

assign enc_dec = encrypt_decrypt | mode_ctr;
assign key_gen = (state == ROUND_KEY0);

assign op_key_derivation = (op_mode == KEY_DERIVATION);

assign mode_ctr = (aes_mode == CTR);
assign mode_cbc = (aes_mode == CBC);

assign key_init = start;

assign op_mode = (mode_ctr) ? ENCRYPTION : operation_mode;

// Next State Logic
always @(*)
	begin
		next_state = state;
		case(state)
			IDLE:
				begin
					if(!start)
						next_state = IDLE;
					else
						case(op_mode)
							ENCRYPTION    : next_state = ROUND0_COL0;
							DECRYPTION    : next_state = ROUND0_COL3;
							KEY_DERIVATION: next_state = GEN_KEY0;
							DECRYP_W_DERIV: next_state = GEN_KEY0;
							default       : next_state = IDLE;
						endcase
				end
			ROUND0_COL0:
				begin
					next_state = (enc_dec) ? ROUND0_COL1 : ROUND_KEY0; 
				end
			ROUND0_COL1:
				begin
					next_state = (enc_dec) ? ROUND0_COL2 : ROUND0_COL0;
				end
			ROUND0_COL2:
				begin
					next_state = (enc_dec) ? ROUND0_COL3 : ROUND0_COL1;
				end
			ROUND0_COL3:
				begin
					next_state = (enc_dec) ? ROUND_KEY0 : ROUND0_COL2;
				end
			ROUND_KEY0 :
				begin
					if(!first_round)
						begin
							next_state = (last_round) ? READY : NOP;
						end
					else
						begin
							next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;
						end
				end
			NOP        :
				begin
					next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;
				end
			ROUND_COL0 :
				begin
					next_state = (enc_dec) ? ROUND_COL1 : ROUND_KEY0;
				end
			ROUND_COL1 :
				begin
					next_state = (enc_dec) ? ROUND_COL2 : ROUND_COL0;
				end
			ROUND_COL2 :
				begin
					next_state = (enc_dec) ? ROUND_COL3 : ROUND_COL1;
				end
			ROUND_COL3 :
				begin
					if(last_round && enc_dec)
						next_state = READY;
					else
					next_state = (enc_dec) ? ROUND_KEY0 : ROUND_COL2;
				end
			GEN_KEY0   :
				begin
					next_state = GEN_KEY1;
				end
			GEN_KEY1   :
				begin
					next_state = GEN_KEY2;
				end
			GEN_KEY2   :
				begin
					next_state = GEN_KEY3;
				end
			GEN_KEY3   :
				begin
					if(last_round)
						next_state = (op_key_derivation) ? READY : ROUND0_COL3;
					else
						next_state = GEN_KEY0;
				end
			READY      :
				begin
					next_state = IDLE;
				end
		endcase
	end
 
       
// Output Logic
assign end_comp = (state == READY)?ENABLE:DISABLE;

/*
always @(posedge clk, negedge rst_n)
begin
		if(!rst_n)
		begin
			end_aes_pp1 <= 1'b0;
			end_aes_pp2 <= 1'b0; 
			end_comp <= 1'b0;
		end
		else
			if(state == READY)
			begin
				end_aes_pp1 <= ENABLE;
				//end_aes_pp2 <= end_aes_pp1;
				end_comp <= end_aes_pp1 ;
			end
			else
			begin
				end_aes_pp1 <= DISABLE;
				//end_aes_pp2 <= end_aes_pp1;
				end_comp <= end_aes_pp1 ;
			end

end
*/
always @(*)
	begin
		sbox_sel = COL_0;
		rk_sel = COL;
		bypass_rk = DISABLE;
		key_out_sel = KEY_0;
		col_sel = INPUT;
		key_sel = KEY_HOST;
		key_en = KEY_DIS;
		col_en = COL_DIS;
		rd_count_en = DISABLE;
		iv_cnt_en = DISABLE;
		iv_cnt_sel = IV_BUS;
		bypass_key_en = DISABLE;
		key_derivation_en = DISABLE;
		//end_comp = DISABLE;
		case(state)
			ROUND0_COL0:
				begin
					sbox_sel = COL_0;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_0;
					col_sel = (enc_dec) ? ADD_RK_OUT : SHIFT_ROWS;
					col_en =  (enc_dec) ? EN_COL_0 : COL_ALL;
				end
			ROUND0_COL1:
				begin
					sbox_sel = COL_1;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_1;
					col_sel = ADD_RK_OUT;
					col_en = EN_COL_1;
					if(!enc_dec)
						begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_1;
						end
				end
			ROUND0_COL2:
				begin
					sbox_sel = COL_2;
					rk_sel   = COL;
					bypass_rk = ENABLE;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_2;
					col_sel = ADD_RK_OUT;
					col_en = EN_COL_2;
					if(!enc_dec)
						begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_2;
						end
				end
			ROUND0_COL3:
				begin
					sbox_sel = COL_3;
					rk_sel   = COL;
					bypass_key_en = ENABLE;
					key_out_sel = KEY_3;
					col_sel = (enc_dec) ? SHIFT_ROWS : ADD_RK_OUT;
					col_en =  (enc_dec) ? COL_ALL : EN_COL_3;
					bypass_rk = ENABLE;
					if(!enc_dec)
					begin
							key_sel = KEY_OUT;
							key_en =  EN_KEY_3;
					end
				end
			ROUND_KEY0:
				begin
					sbox_sel = G_FUNCTION;
					key_sel = KEY_OUT;
					key_en = EN_KEY_0;
					rd_count_en = ENABLE;
				end
			ROUND_COL0:
				begin
					sbox_sel = COL_0;
					rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_0;
					key_sel = KEY_OUT;

					if(enc_dec)
						key_en = EN_KEY_1;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						begin
							if(!enc_dec)
								col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;
							else
								col_sel = ADD_RK_OUT;
						end
					if(enc_dec)
						col_en = EN_COL_0;
					else
						col_en = (last_round) ? EN_COL_0 : COL_ALL;
				end
			ROUND_COL1:
				begin
					sbox_sel = COL_1;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_1;
					key_sel = KEY_OUT;
					if(enc_dec)
						key_en = EN_KEY_2;
					else
						key_en = EN_KEY_1;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						col_sel = ADD_RK_OUT;
					col_en = EN_COL_1;
				end
			ROUND_COL2:
				begin
					sbox_sel = COL_2;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_2;
					key_sel = KEY_OUT;
					if(enc_dec)
						key_en = EN_KEY_3;
					else
						key_en = EN_KEY_2;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						col_sel = ADD_RK_OUT;
					col_en = EN_COL_2;
				end
			ROUND_COL3:
				begin
					sbox_sel = COL_3;
					rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;
					key_out_sel = KEY_3;
					key_sel = KEY_OUT;
					if(!enc_dec)
						key_en = EN_KEY_3;
					if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))
						col_sel = INPUT;
					else
						begin
							if(enc_dec)
								col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;
							else
								col_sel = ADD_RK_OUT;
						end
					if(enc_dec)
						col_en = (last_round) ? EN_COL_3 : COL_ALL;
					else
						col_en = EN_COL_3;
					if(mode_ctr && last_round)
						begin
							iv_cnt_en = ENABLE;
							iv_cnt_sel = IV_CNT;
						end
				end
			GEN_KEY0:
				begin
					sbox_sel = G_FUNCTION;
					rd_count_en = ENABLE;
				end
			GEN_KEY1:
				begin
					key_en = EN_KEY_1 | EN_KEY_0; //Enable key 0 AND key 1
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			GEN_KEY2:
				begin
					key_en = EN_KEY_2;
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			GEN_KEY3:
				begin
					key_en = EN_KEY_3;
					key_sel = KEY_OUT;
					bypass_key_en = ENABLE;
				end
			READY:
				begin
					//end_comp = ENABLE;
					if(op_mode == KEY_DERIVATION)
						key_derivation_en = ENABLE;
				end
		endcase
	end

// Round Counter
always @(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			rd_count <= INITIAL_ROUND;
		else
			if(state == IDLE || (state == GEN_KEY3 && last_round))
				rd_count <= INITIAL_ROUND;
			else 
				if(rd_count_en)
					rd_count <= rd_count + 1'b1;
	end

assign round = rd_count;
assign first_round = (rd_count == INITIAL_ROUND);
assign last_round  = (rd_count == NUMBER_ROUND || rd_count == NUMBER_ROUND_INC);

endmodule","
module control_unit_sva(
        input  [2:0] sbox_sel,
        input  [1:0] rk_sel,
        input  [1:0] key_out_sel,
        input  [1:0] col_sel,
        input  [3:0] key_en,
        input  [3:0] col_en,
        input  [3:0] round,
        input  bypass_rk,
        input  bypass_key_en,
        input  key_sel,
        input  iv_cnt_en,
        input  iv_cnt_sel,
        input  key_derivation_en,
        input end_comp,
        input key_init,
        input key_gen,
        input mode_ctr,
        input mode_cbc,
        input last_round,
  	input encrypt_decrypt,
        input [1:0] operation_mode,
        input [1:0] aes_mode,
        input start,
        input disable_core,
        input clk,
        input rst_n,
	input first_round,
	input state,
	input op_mode,
	input rd_count_en,
	input next_state,
	input rd_count,
	input op_key_derivation,
	input enc_dec
);
property a3;
@(posedge clk) (aes_mode[0] == 1) |-> (mode_ctr == 0);
endproperty
assert_a3: assert property(a3);

property a2;
@(posedge clk) (aes_mode[0] == 0) |-> (mode_cbc == 0);
endproperty
assert_a2: assert property(a2);

property a1;
@(posedge clk) (start == 0) |-> (key_init == 0);
endproperty
assert_a1: assert property(a1);

property a0;
@(posedge clk) (start == 1) |-> (key_init == 1);
endproperty
assert_a0: assert property(a0);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/NIPS_2024/Jasper_results/arithmetic_core_aes128/control_unit/FPV_control_unit.tcl,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property((aes_mode[0] == 1) |-> (mode_ctr == 0));"",
    ""Signals"": [
      ""aes_mode"",
      ""mode_ctr""
    ],
    ""Signal Explanations"": {
      ""aes_mode"": ""Input signal selecting the AES mode. It is a 2-bit signal where the different bit patterns correspond to different modes (ECB, CBC, CTR)."",
      ""mode_ctr"": ""Output signal that indicates if the AES operation is in CTR mode. It is driven high when aes_mode equals the CTR mode (which is defined as 2'b10).""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks equality between the signal and the specified constant value."",
      ""|->"": ""Non-overlapping implication, meaning if the antecedent (left side) is true at a clock edge then the consequent (right side) must be true at that clock edge.""
    },
    ""Assertion Explaination"": ""This assertion verifies that if the least significant bit of aes_mode is 1 (i.e. (aes_mode[0] == 1)), then mode_ctr must be 0. In other words, when the lower bit of the AES mode selection is 1, the core must not be configured for CTR mode, since CTR mode requires a specific bit pattern with a 0 in that bit position.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property((aes_mode[0] == 0) |-> (mode_cbc == 0));"",
    ""Signals"": [
      ""aes_mode"",
      ""mode_cbc""
    ],
    ""Signal Explanations"": {
      ""aes_mode"": ""Input signal selecting the AES mode, where its 2-bit value determines if the operation is ECB, CBC or CTR."",
      ""mode_cbc"": ""Output signal that indicates if the AES core is operating in CBC mode. It is set to high only when aes_mode exactly equals the CBC mode (2'b01).""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks equality between the given signal and the specified value."",
      ""|->"": ""Non-overlapping implication, meaning if the antecedent holds true at a clock edge then the consequent must also hold true at that clock edge.""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the least significant bit of aes_mode is 0 (i.e. (aes_mode[0] == 0)), then mode_cbc must be 0. This means that when the lower bit is 0 – which would not match the expected pattern for CBC (CBC is 2'b01) – then the AES core must not be in CBC mode.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property((start == 0) |-> (key_init == 0));"",
    ""Signals"": [
      ""start"",
      ""key_init""
    ],
    ""Signal Explanations"": {
      ""start"": ""Input signal that initiates the AES operation. It triggers the sequence for key initialization and other computation steps."",
      ""key_init"": ""Output signal that indicates the initialization of the key. In the code it is directly assigned from the start signal.""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks whether the signal equals the given constant value (0 in this case)."",
      ""|->"": ""Non-overlapping implication, meaning that if the condition on the left (antecedent) is true at a clock edge, then the condition on the right (consequent) must also be true at that clock edge.""
    },
    ""Assertion Explaination"": ""This assertion confirms that if the start signal is low (0), then key_init must also be low (0). This maintains a direct correspondence between the start command and the key initialization state – no start means no key initialization.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property((start == 1) |-> (key_init == 1));"",
    ""Signals"": [
      ""start"",
      ""key_init""
    ],
    ""Signal Explanations"": {
      ""start"": ""Input signal that initiates the AES operation. A high value indicates that the operation should begin."",
      ""key_init"": ""Output signal that signifies the initialization of the key. It is directly driven by the start signal in the module.""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks for equality between the signal and the specified value (1 in this instance)."",
      ""|->"": ""Non-overlapping implication, meaning if the condition on the left side (antecedent) is true at a clock edge then the condition on the right side (consequent) must also be true at that clock edge.""
    },
    ""Assertion Explaination"": ""This assertion verifies that if the start signal is high (1), then key_init must also be high (1). This ensures that when an operation is initiated (start asserted), the key initialization occurs as expected.""
  }
}"
"//////////////////////////////////////////////////////////////////
////
////
//// 	CRCAHB CORE BLOCK
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// crcahb IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): -  Julio Cesar 
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////
module host_interface
(
	//OUTPUTS
	output [31:0] HRDATA,
	output HREADYOUT,
	output HRESP,
	output [31:0] bus_wr,
	output [ 1:0] crc_poly_size,
	output [ 1:0] bus_size,
	output [ 1:0] rev_in_type,
	output rev_out_type,
	output crc_init_en,
	output crc_idr_en,
	output crc_poly_en,
	output buffer_write_en,
	output reset_chain,
	//INPUTS
	input [31:0] HWDATA,
	input [31:0] HADDR,
	input [ 2:0] HSIZE,
	input [ 1:0] HTRANS,
	input HWRITE,
	input HSElx,
	input HREADY,
	input HRESETn,
	input HCLK,
	input [31:0] crc_poly_out,
	input [31:0] crc_out,
	input [31:0] crc_init_out,
	input [ 7:0] crc_idr_out,
	input buffer_full,
	input reset_pending,
	input read_wait
);

//Reset Values
localparam RESET_CRC_CR = 6'h00;

//CRC Register Map
localparam CRC_DR   = 3'h0;
localparam CRC_IDR  = 3'h1;
localparam CRC_CR   = 3'h2;
localparam CRC_INIT = 3'h4;
localparam CRC_POL  = 3'h5;

//Transfer Type Encoding
localparam IDLE    = 2'b00;
localparam BUSY    = 2'b01;
localparam NON_SEQ = 2'b10;
localparam SEQ     = 2'b11;

//HRESP Encoding
localparam OK    = 1'b0;
localparam ERROR = 1'b1;

//Pipeline flops
reg [2:0] haddr_pp;
reg [2:0] hsize_pp;
reg [1:0] htrans_pp;
reg hwrite_pp;
reg hselx_pp;

//Flops
reg [4:0] crc_cr_ff;

//Internal Signals
wire [31:0] crc_cr_rd;
wire crc_dr_sel;
wire crc_init_sel;
wire crc_idr_sel;
wire crc_poly_sel;
wire crc_cr_sel;
wire ahb_enable;
wire write_en;
wire read_en;
wire crc_cr_en;
wire sample_bus;
wire buffer_read_en;

//Pipeline Registers for Address Phase of AHB Protocol
always @(posedge HCLK)
	begin
		if(!HRESETn)
			begin
				hselx_pp <= 1'b0;
			end
		else
			if(sample_bus)
				begin
					haddr_pp  <= HADDR[4:2];
					hsize_pp  <= HSIZE;
					htrans_pp <= HTRANS;
					hwrite_pp <= HWRITE;
					hselx_pp  <= HSElx;
				end
	end

//Enable Signals
assign ahb_enable = (htrans_pp == NON_SEQ);
assign write_en = hselx_pp &&  hwrite_pp && ahb_enable;
assign read_en  = hselx_pp && !hwrite_pp && ahb_enable;

//Registers decoding
assign crc_dr_sel   = (haddr_pp == CRC_DR  );
assign crc_init_sel = (haddr_pp == CRC_INIT);
assign crc_idr_sel  = (haddr_pp == CRC_IDR );
assign crc_poly_sel = (haddr_pp == CRC_POL );
assign crc_cr_sel   = (haddr_pp == CRC_CR  );

//Write Esnables Signals for Registers
assign buffer_write_en = crc_dr_sel   && write_en;
assign crc_init_en     = crc_init_sel && write_en;
assign crc_idr_en      = crc_idr_sel  && write_en;
assign crc_poly_en     = crc_poly_sel && write_en;
assign crc_cr_en       = crc_cr_sel   && write_en;

//Indicates reading operation request to crc_dr register
assign buffer_read_en = crc_dr_sel && read_en;

//Bus Size is the output of HSIZE pipeline register
assign bus_size = hsize_pp;

//The Write Bus is not pipelined
assign bus_wr = HWDATA;

//HREADY Signal outputed to Master
assign HREADYOUT = !((buffer_write_en && buffer_full   ) ||
                     (buffer_read_en  && read_wait     ) ||
                     (crc_init_en     && reset_pending ) );

//Signal to control sampling of bus
assign sample_bus = HREADYOUT && HREADY;

//HRESP Signal outputed to Master
//This implementation never signalize bus error to master
assign HRESP = OK;

//CRC_CR Data Read
assign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0};

//Mux to HRDATA
assign HRDATA = ({32{crc_dr_sel  }} & crc_out             ) |
                ({32{crc_init_sel}} & crc_init_out        ) |
                ({32{crc_idr_sel }} & {24'h0, crc_idr_out}) |
                ({32{crc_poly_sel}} & crc_poly_out        ) |
                ({32{crc_cr_sel  }} & crc_cr_rd           ) ;

//Control Register
always @(posedge HCLK)
	begin
		if(!HRESETn)
			crc_cr_ff <= RESET_CRC_CR;
		else
			if(crc_cr_en)
				crc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]};
	end

//Configuration Signals
assign reset_chain   = (crc_cr_en && HWDATA[0]);
assign crc_poly_size = crc_cr_ff[1:0];
assign rev_in_type   = crc_cr_ff[3:2];
assign rev_out_type  = crc_cr_ff[4];

endmodule","
module host_interface_sva(
	input HSElx,
	input buffer_write_en,
	input HREADYOUT,
	input HRESP,
	input rev_out_type,
	input [31:0] HRDATA,
	input [31:0] crc_poly_out,
	input buffer_full,
	input read_wait,
input crc_idr_sel,
input crc_poly_sel,
	input [31:0] HADDR,
	input HCLK,
	input [ 1:0] crc_poly_size,
input buffer_read_en,
input crc_cr_sel,
input ahb_enable,
input write_en,
	input [31:0] crc_init_out,
	input crc_poly_en,
	input reset_pending,
	input [ 1:0] bus_size,
input crc_init_sel,
	input [ 1:0] rev_in_type,
input [2:0] hsize_pp,
input sample_bus,
	input [ 7:0] crc_idr_out,
	input [31:0] HWDATA,
input crc_dr_sel,
	input HREADY,
	input [31:0] bus_wr,
	input [ 2:0] HSIZE,
	input [31:0] crc_out,
	input crc_idr_en,
	input crc_init_en,
	input HRESETn,
input hselx_pp,
input read_en,
input [4:0] crc_cr_ff,
input [1:0] htrans_pp,
	input [ 1:0] HTRANS,
input [2:0] haddr_pp,
input hwrite_pp,
	input HWRITE,
	input reset_chain,
input crc_cr_en,
input DEFAULT_CLOCK,
input DEFAULT_RESET,
input [31:0] crc_cr_rd
);



property a1;
@(posedge DEFAULT_CLOCK) (buffer_read_en == 0) |-> (HREADYOUT == 1);
endproperty
// assert_a1: assert property(a1);

property a3;
@(posedge DEFAULT_CLOCK) (sample_bus == 1) |-> (HREADYOUT == 1);
endproperty
assert_a3: assert property(a3);

property a5;
@(posedge DEFAULT_CLOCK) (buffer_read_en == 1 & read_wait == 1) |-> (HREADYOUT == 0);
endproperty
assert_a5: assert property(a5);

property a2;
@(posedge DEFAULT_CLOCK) (reset_pending == 0) |-> (HREADYOUT == 1);
endproperty
// assert_a2: assert property(a2);

property a4;
@(posedge DEFAULT_CLOCK) (read_wait == 0) |-> (HREADYOUT == 1);
endproperty
// assert_a4: assert property(a4);

property a0;
@(posedge DEFAULT_CLOCK) (ahb_enable == 0) |-> (HREADYOUT == 1);
endproperty
assert_a0: assert property(a0);

property a8;
@(posedge DEFAULT_CLOCK) (write_en == 0) |-> (crc_idr_en == 0);
endproperty
assert_a8: assert property(a8);

property a11;
@(posedge DEFAULT_CLOCK) (write_en == 1 & crc_idr_sel == 1) |-> (crc_idr_en == 1);
endproperty
assert_a11: assert property(a11);

property a10;
@(posedge DEFAULT_CLOCK) (crc_idr_sel == 0) |-> (crc_idr_en == 0);
endproperty
assert_a10: assert property(a10);

property a13;
@(posedge DEFAULT_CLOCK) (hselx_pp == 0) |-> (crc_idr_en == 0);
endproperty
assert_a13: assert property(a13);

property a12;
@(posedge DEFAULT_CLOCK) (hwrite_pp == 0) |-> (crc_idr_en == 0);
endproperty
assert_a12: assert property(a12);

property a9;
@(posedge DEFAULT_CLOCK) (haddr_pp[1] == 0) |-> (crc_idr_en == 0);
endproperty
// assert_a9: assert property(a9);

property a16;
@(posedge DEFAULT_CLOCK) (write_en == 0) |-> (crc_poly_en == 0);
endproperty
assert_a16: assert property(a16);

property a18;
@(posedge DEFAULT_CLOCK) (write_en == 1 & haddr_pp[1] == 0) |-> (crc_poly_en == 1);
endproperty
// assert_a18: assert property(a18);

property a15;
@(posedge DEFAULT_CLOCK) (hselx_pp == 0) |-> (crc_poly_en == 0);
endproperty
assert_a15: assert property(a15);

property a14;
@(posedge DEFAULT_CLOCK) (hwrite_pp == 0) |-> (crc_poly_en == 0);
endproperty
assert_a14: assert property(a14);

property a17;
@(posedge DEFAULT_CLOCK) (haddr_pp[1] == 1) |-> (crc_poly_en == 0);
endproperty
assert_a17: assert property(a17);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/NIPS_2024/Jasper_results/arithmetic_core_crcahb/host_interface/property_goldmine.sva,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property((buffer_read_en == 0) |-> (HREADYOUT == 1));"",
    ""Signals"": [
      ""buffer_read_en"",
      ""HREADYOUT""
    ],
    ""Signal Explanations"": {
      ""buffer_read_en"": ""Signal indicating that a read operation request to the CRC_DR register is active (true when both crc_dr_sel and read_en are asserted)"",
      ""HREADYOUT"": ""AHB bus ready output signal provided to the master; it is high (1) when the slave is ready to complete the transfer""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks equality between the signal and the specified value"",
      ""|->"": ""Non-overlapping implication: if the antecedent is true in the current cycle then the consequent must be true in the same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the signal buffer_read_en equals 0 (meaning no read request to the CRC_DR register is active), then HREADYOUT must be equal to 1, ensuring that the bus is ready.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property((sample_bus == 1) |-> (HREADYOUT == 1));"",
    ""Signals"": [
      ""sample_bus"",
      ""HREADYOUT""
    ],
    ""Signal Explanations"": {
      ""sample_bus"": ""Signal used to control the sampling of the bus; it is asserted when both HREADYOUT and HREADY are high."",
      ""HREADYOUT"": ""AHB bus ready output signal to the master indicating that the transfer can complete""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks that the signal equals the given value"",
      ""|->"": ""Non-overlapping implication: if the left-hand side is true, then the right-hand side must also be true in that clock cycle""
    },
    ""Assertion Explaination"": ""This assertion specifies that whenever sample_bus is asserted (equals 1), the HREADYOUT signal must also be asserted (equal 1) to indicate readiness of the bus.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property((buffer_read_en == 1 & read_wait == 1) |-> (HREADYOUT == 0));"",
    ""Signals"": [
      ""buffer_read_en"",
      ""read_wait"",
      ""HREADYOUT""
    ],
    ""Signal Explanations"": {
      ""buffer_read_en"": ""Signal indicating a read operation request to the CRC_DR register is active"",
      ""read_wait"": ""Signal indicating that the read operation is in a wait state (the read has to wait before completing)"",
      ""HREADYOUT"": ""AHB bus ready output signal which should be low (0) when the read operation is waiting and cannot complete immediately""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Compares a signal to a specified value for equality"",
      ""&"": ""Logical AND operator ensuring both conditions are met"",
      ""|->"": ""Non-overlapping implication: if the left-hand side is true then the right-hand side must be true in that same cycle""
    },
    ""Assertion Explaination"": ""This assertion requires that if both buffer_read_en and read_wait are asserted (each equal to 1), then HREADYOUT must be 0, indicating that the bus is not ready due to the pending read wait.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property((reset_pending == 0) |-> (HREADYOUT == 1));"",
    ""Signals"": [
      ""reset_pending"",
      ""HREADYOUT""
    ],
    ""Signal Explanations"": {
      ""reset_pending"": ""Signal indicating whether a reset is still pending in the chain"",
      ""HREADYOUT"": ""AHB bus ready output signal which should be high (1) when no reset is pending""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks that the signal is equal to a specified value"",
      ""|->"": ""Implies that if the antecedent is true, then the consequent must be true within the same clock cycle""
    },
    ""Assertion Explaination"": ""This assertion specifies that if reset_pending is 0 (no reset pending), then HREADYOUT must be 1, meaning the bus is ready.""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property((read_wait == 0) |-> (HREADYOUT == 1));"",
    ""Signals"": [
      ""read_wait"",
      ""HREADYOUT""
    ],
    ""Signal Explanations"": {
      ""read_wait"": ""Signal that indicates whether a read operation is waiting"",
      ""HREADYOUT"": ""AHB bus ready output signal, which should be high (1) if there is no read wait condition""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Tests for equality between the signal value and the given constant"",
      ""|->"": ""Indicates that when the condition on the left holds, the condition on the right must hold in the same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if read_wait is 0 (no delay waiting for a read), then HREADYOUT must be 1, ensuring that the bus transfer can complete.""
  },
  ""Assertion 6"": {
    ""Assertion"": ""assert property((ahb_enable == 0) |-> (HREADYOUT == 1));"",
    ""Signals"": [
      ""ahb_enable"",
      ""HREADYOUT""
    ],
    ""Signal Explanations"": {
      ""ahb_enable"": ""Signal derived from the pipelined HTRANS; it is high when the transfer type is NON_SEQ, enabling a valid AHB transfer"",
      ""HREADYOUT"": ""Indicates whether the slave is ready to complete the current transfer""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Determines if a signal is equal to a certain value"",
      ""|->"": ""Implication operator requiring that if the antecedent is true then the consequent must be true in that cycle""
    },
    ""Assertion Explaination"": ""This assertion ensures that if ahb_enable is not active (equals 0), then HREADYOUT must be 1, indicating that the interface is ready by default when no valid transfer is taking place.""
  },
  ""Assertion 7"": {
    ""Assertion"": ""assert property((write_en == 0) |-> (crc_idr_en == 0));"",
    ""Signals"": [
      ""write_en"",
      ""crc_idr_en""
    ],
    ""Signal Explanations"": {
      ""write_en"": ""Signal indicating that a write operation is taking place, derived from HSElx, HWRITE, and the AHB enable condition"",
      ""crc_idr_en"": ""Enable signal for writing to the CRC_IDR register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Verifies equality of a signal to a specified value"",
      ""|->"": ""Non-overlapping implication that if the antecedent holds then the consequent must hold in that same clock cycle""
    },
    ""Assertion Explaination"": ""This assertion mandates that if write_en is not asserted (equals 0), then the enable for writing to the CRC_IDR register (crc_idr_en) must also be 0.""
  },
  ""Assertion 8"": {
    ""Assertion"": ""assert property((write_en == 1 & crc_idr_sel == 1) |-> (crc_idr_en == 1));"",
    ""Signals"": [
      ""write_en"",
      ""crc_idr_sel"",
      ""crc_idr_en""
    ],
    ""Signal Explanations"": {
      ""write_en"": ""Indicates that a write operation is active"",
      ""crc_idr_sel"": ""Decoded signal that indicates if the current register address corresponds to the CRC_IDR register"",
      ""crc_idr_en"": ""Signal that enables writing to the CRC_IDR register""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks that a signal equals a given constant"",
      ""&"": ""Logical AND operator which requires both conditions to be true"",
      ""|->"": ""Implies that when the left-hand side is true, the right-hand side must be true as well""
    },
    ""Assertion Explaination"": ""This assertion states that if write_en is set to 1 and the CRC_IDR register is selected (crc_idr_sel equals 1), then the write enable signal for the CRC_IDR (crc_idr_en) must be asserted (1).""
  },
  ""Assertion 9"": {
    ""Assertion"": ""assert property((crc_idr_sel == 0) |-> (crc_idr_en == 0));"",
    ""Signals"": [
      ""crc_idr_sel"",
      ""crc_idr_en""
    ],
    ""Signal Explanations"": {
      ""crc_idr_sel"": ""Signal that is asserted when the address being accessed corresponds to the CRC_IDR register"",
      ""crc_idr_en"": ""Enable signal for writing to the CRC_IDR register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Tests if the signal is equal to the provided value"",
      ""|->"": ""Indicates that if the left-hand condition holds, then the right-hand condition must also hold during the same clock cycle""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the CRC_IDR register is not selected (crc_idr_sel equals 0), then the write enable for the CRC_IDR register (crc_idr_en) must not be asserted (equals 0).""
  },
  ""Assertion 10"": {
    ""Assertion"": ""assert property((hselx_pp == 0) |-> (crc_idr_en == 0));"",
    ""Signals"": [
      ""hselx_pp"",
      ""crc_idr_en""
    ],
    ""Signal Explanations"": {
      ""hselx_pp"": ""Pipelined version of the HSElx signal indicating if the slave is selected"",
      ""crc_idr_en"": ""Enable signal for writing to the CRC_IDR register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Determines equality between a signal and a constant value"",
      ""|->"": ""Implies that if the condition on the left is true then the condition on the right must also be true in the current cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the pipelined slave select signal (hselx_pp) is not active (equals 0), then the CRC_IDR register should not be enabled for writing (crc_idr_en equals 0).""
  },
  ""Assertion 11"": {
    ""Assertion"": ""assert property((hwrite_pp == 0) |-> (crc_idr_en == 0));"",
    ""Signals"": [
      ""hwrite_pp"",
      ""crc_idr_en""
    ],
    ""Signal Explanations"": {
      ""hwrite_pp"": ""Pipelined version of the HWRITE signal indicating whether the current transfer is a write"",
      ""crc_idr_en"": ""Write enable for the CRC_IDR register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Tests equality between the signal and a specified value"",
      ""|->"": ""Implies that if the left-hand side is true, then the right-hand side must also be true simultaneously""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the pipelined write signal (hwrite_pp) is not active (equals 0), then the enable for CRC_IDR writing (crc_idr_en) must be 0.""
  },
  ""Assertion 12"": {
    ""Assertion"": ""assert property((haddr_pp[1] == 0) |-> (crc_idr_en == 0));"",
    ""Signals"": [
      ""haddr_pp[1]"",
      ""crc_idr_en""
    ],
    ""Signal Explanations"": {
      ""haddr_pp[1]"": ""The second bit of the pipelined address (HADDR) used for register decoding; helps determine which register is addressed"",
      ""crc_idr_en"": ""Enable signal for writing to the CRC_IDR register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Evaluates if a signal equals a specified value"",
      ""|->"": ""Non-overlapping implication asserting that if the left-hand condition holds then the right-hand condition must hold in that cycle""
    },
    ""Assertion Explaination"": ""This assertion specifies that if bit 1 of the pipelined address (haddr_pp[1]) is 0 – indicating that the accessed register is not the one assigned by that bit – then the CRC_IDR write enable (crc_idr_en) must be 0.""
  },
  ""Assertion 13"": {
    ""Assertion"": ""assert property((write_en == 0) |-> (crc_poly_en == 0));"",
    ""Signals"": [
      ""write_en"",
      ""crc_poly_en""
    ],
    ""Signal Explanations"": {
      ""write_en"": ""Signal indicating that a write operation is in progress"",
      ""crc_poly_en"": ""Enable signal for writing to the CRC_POL register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Test for equality"",
      ""|->"": ""Implies that if the left-hand side condition is true then the right-hand side must be true in that same cycle""
    },
    ""Assertion Explaination"": ""This assertion requires that if no write operation is occurring (write_en is 0), then the write enable for the CRC_POL register (crc_poly_en) must also be 0.""
  },
  ""Assertion 14"": {
    ""Assertion"": ""assert property((write_en == 1 & haddr_pp[1] == 0) |-> (crc_poly_en == 1));"",
    ""Signals"": [
      ""write_en"",
      ""haddr_pp[1]"",
      ""crc_poly_en""
    ],
    ""Signal Explanations"": {
      ""write_en"": ""Indicates an active write operation"",
      ""haddr_pp[1]"": ""The second bit from the pipelined address, used in decoding the address to determine which register is being accessed"",
      ""crc_poly_en"": ""Enable signal for writing to the CRC_POL register""
    },
    ""Logical Operators"": [
      ""=="",
      ""&"",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks for equality"",
      ""&"": ""Logical AND ensuring both conditions hold"",
      ""|->"": ""Implies that if the combined antecedent is true then the consequent must be true in the same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if a write operation is active (write_en equals 1) and the pipelined address bit haddr_pp[1] is 0 (indicating the CRC_POL register is addressed), then the enable signal for CRC_POL writing (crc_poly_en) must be asserted (1).""
  },
  ""Assertion 15"": {
    ""Assertion"": ""assert property((hselx_pp == 0) |-> (crc_poly_en == 0));"",
    ""Signals"": [
      ""hselx_pp"",
      ""crc_poly_en""
    ],
    ""Signal Explanations"": {
      ""hselx_pp"": ""Pipelined version of the slave select signal (HSElx) indicating whether the device is selected"",
      ""crc_poly_en"": ""Write enable signal for the CRC_POL register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks equality of a signal with a constant"",
      ""|->"": ""Non-overlapping implication which requires that if the antecedent is true then the consequent is true in that same clock cycle""
    },
    ""Assertion Explaination"": ""This assertion ensures that if the pipelined slave select signal (hselx_pp) is not active (equals 0), then the write enable for the CRC_POL register (crc_poly_en) must be deasserted (0).""
  },
  ""Assertion 16"": {
    ""Assertion"": ""assert property((hwrite_pp == 0) |-> (crc_poly_en == 0));"",
    ""Signals"": [
      ""hwrite_pp"",
      ""crc_poly_en""
    ],
    ""Signal Explanations"": {
      ""hwrite_pp"": ""Pipelined version of the HWRITE signal showing whether the current transaction is a write"",
      ""crc_poly_en"": ""Enable signal for writing to the CRC_POL register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Tests equality between a signal and a constant value"",
      ""|->"": ""Implies that if the left-hand condition is satisfied then the right-hand condition must be satisfied in the same cycle""
    },
    ""Assertion Explaination"": ""This assertion indicates that if the pipelined write signal (hwrite_pp) is not asserted (equals 0), then the CRC_POL register write enable (crc_poly_en) must also be 0.""
  },
  ""Assertion 17"": {
    ""Assertion"": ""assert property((haddr_pp[1] == 1) |-> (crc_poly_en == 0));"",
    ""Signals"": [
      ""haddr_pp[1]"",
      ""crc_poly_en""
    ],
    ""Signal Explanations"": {
      ""haddr_pp[1]"": ""The second bit of the pipelined address used in register decoding to select the proper register"",
      ""crc_poly_en"": ""Signal that enables writing to the CRC_POL register""
    },
    ""Logical Operators"": [
      ""=="",
      ""|->""
    ],
    ""Logical Operators Explanation"": {
      ""=="": ""Evaluates equality of a signal against a constant"",
      ""|->"": ""Non-overlapping implication requiring that if the left-hand side condition holds, then the right-hand side condition must also hold within the same clock cycle""
    },
    ""Assertion Explaination"": ""This assertion specifies that if the pipelined address bit haddr_pp[1] is 1 (implying that a register other than CRC_POL is addressed), then the CRC_POL write enable (crc_poly_en) must be 0.""
  }
}"
"`timescale 1ns / 1ps
//=============================================================================
//	(C) 2007,2012  Robert Finch
//  robfinch<remove>@opencores.org
//	All rights reserved.
//
//	PSGBusArb.v
//
// This source file is free software: you can redistribute it and/or modify 
// it under the terms of the GNU Lesser General Public License as published 
// by the Free Software Foundation, either version 3 of the License, or     
// (at your option) any later version.                                      
//                                                                          
// This source file is distributed in the hope that it will be useful,      
// but WITHOUT ANY WARRANTY; without even the implied warranty of           
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
// GNU General Public License for more details.                             
//                                                                          
// You should have received a copy of the GNU General Public License        
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
//
//		Arbitrates access to the system bus among up to eight
//	wave table channels for the PSG. This arbitrator is part
//	of a tree that ends up looking like a single arbitration
//	request to the system.
//
//	Spartan3
//	19 LUTs / 11 slices
//=============================================================================

module PSGBusArb(rst, clk, ce, ack,
	req0, req1, req2, req3, req4, req5, req6, req7,
	sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7, seln);
input rst;		// reset
input clk;		// clock (eg 100MHz)
input ce;		// clock enable (eg 25MHz)
input ack;		// bus transfer completed
input req0;		// requester 0 wants the bus
input req1;		// requester 1 wants the bus
input req2;		// ...
input req3;
input req4;
input req5;
input req6;
input req7;
output sel0;	// requester 0 granted the bus
reg sel0;
output sel1;
reg sel1;
output sel2;
reg sel2;
output sel3;
reg sel3;
output sel4;
reg sel4;
output sel5;
reg sel5;
output sel6;
reg sel6;
output sel7;
reg sel7;
output [2:0] seln;	// who has the bus
reg [2:0] seln;

always @(posedge clk) begin
	if (rst) begin
		sel0 <= 1'b0;
		sel1 <= 1'b0;
		sel2 <= 1'b0;
		sel3 <= 1'b0;
		sel4 <= 1'b0;
		sel5 <= 1'b0;
		sel6 <= 1'b0;
		sel7 <= 1'b0;
		seln <= 3'd0;
	end
	else begin
		if (ce&ack) begin
			if (req0) begin
				sel0 <= 1'b1;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd0;
			end
			else if (req1) begin
				sel1 <= 1'b1;
				sel0 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd1;
			end
			else if (req2) begin
				sel2 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd2;
			end
			else if (req3) begin
				sel3 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd3;
			end
			else if (req4) begin
				sel4 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd4;
			end
			else if (req5) begin
				sel5 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel6 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd5;
			end
			else if (req6) begin
				sel6 <= 1'b1;
				sel0 <= 1'b0;+A29
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel7 <= 1'b0;
				seln <= 3'd6;
			end
			else if (req7) begin
				sel7 <= 1'b1;
				sel0 <= 1'b0;
				sel1 <= 1'b0;
				sel2 <= 1'b0;
				sel3 <= 1'b0;
				sel4 <= 1'b0;
				sel5 <= 1'b0;
				sel6 <= 1'b0;
				seln <= 3'd7;
			end
			// otherwise, hold onto last owner
			else begin
				sel0 <= sel0;
				sel1 <= sel1;
				sel2 <= sel2;
				sel3 <= sel3;
				sel4 <= sel4;
				sel5 <= sel5;
				sel6 <= sel6;
				sel7 <= sel7;
				seln <= seln;
			end
		end
	end
end

endmodule","module PSGBusArb_sva(
input req3,
input sel4,
input sel3,
input sel6,
input sel1,
input req4,
input req2,		// ...
input req6,
input ack,		// bus transfer completed
input req1,		// requester 1 wants the bus
input sel7,
input req0,		// requester 0 wants the bus
input sel2,
input req5,
input rst,		// reset
input req7,
input ce,		// clock enable (eg 25MHz)
input clk,		// clock (eg 100MHz)
input sel5,
input [2:0] seln,
input sel0
);

property a10;
@(posedge clk) (ce == 1 & req1 == 1) |=> (sel7 == 0);
endproperty
// assert_a10: assert property(a10);

property a0;
@(posedge clk) (req4 == 1 & req1 == 1) |=> (sel7 == 0);
endproperty
// assert_a0: assert property(a0);

property a5;
@(posedge clk) (req4 == 1 & ce == 1) |=> (sel7 == 0);
endproperty
// assert_a5: assert property(a5);

property a14;
@(posedge clk) (req2 == 0 & req6 == 0 & req4 == 0 & req0 == 0 & ack == 1 & ce == 1 & req5 == 0 & req1 == 0 & req7 == 1) |=> (sel7 == 1);
endproperty
// assert_a14: assert property(a14);

property a7;
@(posedge clk) (sel7 == 0 & req0 == 1) |=> (sel7 == 0);
endproperty
assert_a7: assert property(a7);

property a1;
@(posedge clk) (sel7 == 0 & req1 == 1) |=> (sel7 == 0);
endproperty
assert_a1: assert property(a1);

property a13;
@(posedge clk) (sel7 == 1 & ack == 0) |=> (sel7 == 1);
endproperty
assert_a13: assert property(a13);

property a12;
@(posedge clk) (sel7 == 1 & ce == 0) |=> (sel7 == 1);
endproperty
assert_a12: assert property(a12);

property a3;
@(posedge clk) (sel7 == 0 & ack == 0) |=> (sel7 == 0);
endproperty
assert_a3: assert property(a3);

property a2;
@(posedge clk) (sel7 == 0 & ce == 0) |=> (sel7 == 0);
endproperty
// assert_a2: assert property(a2);

property a4;
@(posedge clk) (sel7 == 0 & req2 == 1) |=> (sel7 == 0);
endproperty
assert_a4: assert property(a4);

property a6;
@(posedge clk) (sel7 == 0 & req3 == 1) |=> (sel7 == 0);
endproperty
assert_a6: assert property(a6);

property a11;
@(posedge clk) (sel7 == 0 & req5 == 1) |=> (sel7 == 0);
endproperty
assert_a11: assert property(a11);

property a8;
@(posedge clk) (sel7 == 0 & req6 == 1) |=> (sel7 == 0);
endproperty
assert_a8: assert property(a8);

property a19;
@(posedge clk) (sel5 == 0 & req0 == 1) |=> (sel5 == 0);
endproperty
assert_a19: assert property(a19);

property a20;
@(posedge clk) (sel5 == 0 & req1 == 1) |=> (sel5 == 0);
endproperty
assert_a20: assert property(a20);

property a26;
@(posedge clk) (sel5 == 1 & ce == 0) |=> (sel5 == 1);
endproperty
assert_a26: assert property(a26);

property a27;
@(posedge clk) (sel5 == 1 & ack == 0) |=> (sel5 == 1);
endproperty
assert_a27: assert property(a27);

property a16;
@(posedge clk) (sel5 == 0 & ack == 0) |=> (sel5 == 0);
endproperty
assert_a16: assert property(a16);

property a15;
@(posedge clk) (sel5 == 0 & ce == 0) |=> (sel5 == 0);
endproperty
assert_a15: assert property(a15);

property a18;
@(posedge clk) (sel5 == 0 & req2 == 1) |=> (sel5 == 0);
endproperty
assert_a18: assert property(a18);

property a17;
@(posedge clk) (sel5 == 0 & req3 == 1) |=> (sel5 == 0);
endproperty
assert_a17: assert property(a17);

property a21;
@(posedge clk) (sel5 == 0 & req4 == 1) |=> (sel5 == 0);
endproperty
assert_a21: assert property(a21);

property a23;
@(posedge clk) (sel5 == 0 & req5 == 0) |=> (sel5 == 0);
endproperty
assert_a23: assert property(a23);

property a35;
@(posedge clk) (sel4 == 0 & req1 == 1) |=> (sel4 == 0);
endproperty
assert_a35: assert property(a35);

property a40;
@(posedge clk) (sel4 == 1 & ack == 0) |=> (sel4 == 1);
endproperty
assert_a40: assert property(a40);

property a31;
@(posedge clk) (sel4 == 0 & ack == 0) |=> (sel4 == 0);
endproperty
assert_a31: assert property(a31);

property a30;
@(posedge clk) (sel4 == 0 & ce == 0) |=> (sel4 == 0);
endproperty
assert_a30: assert property(a30);

property a39;
@(posedge clk) (sel4 == 1 & ce == 0) |=> (sel4 == 1);
endproperty
assert_a39: assert property(a39);

property a32;
@(posedge clk) (sel4 == 0 & req2 == 1) |=> (sel4 == 0);
endproperty
assert_a32: assert property(a32);

property a33;
@(posedge clk) (sel4 == 0 & req3 == 1) |=> (sel4 == 0);
endproperty
assert_a33: assert property(a33);

property a37;
@(posedge clk) (sel4 == 0 & req4 == 0) |=> (sel4 == 0);
endproperty
assert_a37: assert property(a37);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/tree/NIPS_2024/Jasper_results/arithmetic_core_common_files/PSGBusArb,"{
  ""Assertion 1"": {
    ""Assertion"": ""@(posedge clk) (ce == 1 & req1 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""ce"", ""req1"", ""sel7""],
    ""Signal Explanations"": {
      ""ce"": ""clock enable signal that permits the bus arbiter to update its state"",
      ""req1"": ""bus request signal from requester 1"",
      ""sel7"": ""bus select signal indicating whether requester 7 is granted the bus""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality of two operands"",
      ""&"": ""logical AND operator which is true if both operands are true"",
      ""|=>"": ""non-overlapping implication: if the antecedent holds in the current cycle, then the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""If the clock enable is asserted (ce == 1) and the bus request from requester 1 is active (req1 == 1), then in the next cycle the bus select signal for requester 7 will remain deasserted (sel7 == 0).""
  },
  ""Assertion 2"": {
    ""Assertion"": ""@(posedge clk) (req4 == 1 & req1 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""req4"", ""req1"", ""sel7""],
    ""Signal Explanations"": {
      ""req4"": ""bus request signal from requester 4"",
      ""req1"": ""bus request signal from requester 1"",
      ""sel7"": ""bus select signal indicating whether requester 7 is granted the bus""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality of two operands"",
      ""&"": ""logical AND operator which is true if both operands are true"",
      ""|=>"": ""non-overlapping implication that requires the consequent in the next cycle if the antecedent is true in the current cycle""
    },
    ""Assertion Explaination"": ""If both requester 4 and requester 1 are actively requesting the bus (req4 == 1 and req1 == 1), then in the next cycle the bus will not be granted to requester 7 (sel7 == 0).""
  },
  ""Assertion 3"": {
    ""Assertion"": ""@(posedge clk) (req4 == 1 & ce == 1) |=> (sel7 == 0);"",
    ""Signals"": [""req4"", ""ce"", ""sel7""],
    ""Signal Explanations"": {
      ""req4"": ""bus request signal from requester 4"",
      ""ce"": ""clock enable signal that allows state updates"",
      ""sel7"": ""bus select signal indicating whether requester 7 is granted the bus""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures the compared signals have the specified value"",
      ""&"": ""logical AND operator ensuring both conditions are met"",
      ""|=>"": ""non-overlapping implication that imposes the consequent in the next cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""When requester 4 is requesting the bus (req4 == 1) and the clock enable is active (ce == 1), then in the subsequent cycle requester 7 must not be granted the bus (sel7 == 0).""
  },
  ""Assertion 4"": {
    ""Assertion"": ""@(posedge clk) (req2 == 0 & req6 == 0 & req4 == 0 & req0 == 0 & ack == 1 & ce == 1 & req5 == 0 & req1 == 0 & req7 == 1) |=> (sel7 == 1);"",
    ""Signals"": [""req2"", ""req6"", ""req4"", ""req0"", ""ack"", ""ce"", ""req5"", ""req1"", ""req7"", ""sel7""],
    ""Signal Explanations"": {
      ""req2"": ""bus request signal from requester 2"",
      ""req6"": ""bus request signal from requester 6"",
      ""req4"": ""bus request signal from requester 4"",
      ""req0"": ""bus request signal from requester 0"",
      ""ack"": ""acknowledgment signal indicating the bus transfer is completed"",
      ""ce"": ""clock enable signal that allows state updates"",
      ""req5"": ""bus request signal from requester 5"",
      ""req1"": ""bus request signal from requester 1"",
      ""req7"": ""bus request signal from requester 7"",
      ""sel7"": ""bus select signal indicating whether requester 7 is granted the bus""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the signal equals the specified value"",
      ""&"": ""logical AND operator used to combine multiple conditions"",
      ""|=>"": ""non-overlapping implication operator that mandates the consequent in the next cycle if the antecedent is true""
    },
    ""Assertion Explaination"": ""If none of requesters 2, 6, 4, 0, 5, and 1 are requesting the bus (all equal 0), the bus transfer is complete (ack == 1), clock enable is active (ce == 1), and requester 7 is requesting the bus (req7 == 1), then in the next cycle requester 7 must be granted the bus (sel7 == 1).""
  },
  ""Assertion 5"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & req0 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""req0""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal indicating whether requester 7 is granted the bus"",
      ""req0"": ""bus request signal from requester 0""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality of a signal with a value"",
      ""&"": ""logical AND operator ensuring both conditions are satisfied"",
      ""|=>"": ""non-overlapping implication that enforces the consequent in the next cycle after the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 7 is not currently granted the bus (sel7 == 0) and requester 0 is requesting the bus (req0 == 1), then in the next cycle requester 7 must continue to not be granted the bus (sel7 == 0).""
  },
  ""Assertion 6"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & req1 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""req1""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""req1"": ""bus request signal from requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies that a signal has a specific value"",
      ""&"": ""logical AND operator indicating both conditions must be true"",
      ""|=>"": ""non-overlapping implication operator meaning if the antecedent holds now, the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""If the bus is not granted to requester 7 (sel7 == 0) and requester 1 is requesting the bus (req1 == 1), then in the following cycle the bus grant for requester 7 remains off (sel7 == 0).""
  },
  ""Assertion 7"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 1 & ack == 0) |=> (sel7 == 1);"",
    ""Signals"": [""sel7"", ""ack""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""ack"": ""acknowledgment signal indicating that a bus transfer has completed""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures that a signal equals a given value"",
      ""&"": ""logical AND operator requiring both conditions to be true"",
      ""|=>"": ""non-overlapping implication that if the antecedent is true now, then the consequent must hold in the next clock cycle""
    },
    ""Assertion Explaination"": ""If requester 7 is currently granted the bus (sel7 == 1) and the bus transfer is not complete (ack == 0), then in the next cycle requester 7 must remain granted the bus (sel7 == 1).""
  },
  ""Assertion 8"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 1 & ce == 0) |=> (sel7 == 1);"",
    ""Signals"": [""sel7"", ""ce""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""ce"": ""clock enable signal that controls when state updates occur""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares a signal to a specific value"",
      ""&"": ""logical AND operator that combines conditions"",
      ""|=>"": ""non-overlapping implication which means the consequent must hold in the next clock cycle if the antecedent is true""
    },
    ""Assertion Explaination"": ""If requester 7 is granted the bus (sel7 == 1) but the clock enable is not active (ce == 0), then in the next cycle requester 7 continues to hold the bus (sel7 == 1).""
  },
  ""Assertion 9"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & ack == 0) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""ack""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""ack"": ""acknowledgment signal that indicates whether the bus transfer is complete""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies equality of a signal with a value"",
      ""&"": ""logical AND operator that requires both conditions to be true"",
      ""|=>"": ""non-overlapping implication operator indicating that if the current condition holds, the consequence must hold in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 7 is not currently granted the bus (sel7 == 0) and the bus transfer is still pending (ack == 0), then in the next cycle requester 7 remains not granted (sel7 == 0).""
  },
  ""Assertion 10"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & ce == 0) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""ce""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""ce"": ""clock enable signal that allows updates to occur when active""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the signal has a specific value"",
      ""&"": ""logical AND operator ensuring both conditions are met"",
      ""|=>"": ""non-overlapping implication that mandates the consequent on the next clock cycle if the antecedent is true in the current cycle""
    },
    ""Assertion Explaination"": ""If requester 7 is not granted the bus (sel7 == 0) and the clock enable is inactive (ce == 0), then the bus grant for requester 7 will continue to be deasserted in the next cycle (sel7 == 0).""
  },
  ""Assertion 11"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & req2 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""req2""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""req2"": ""bus request signal from requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures that a signal is equal to a given value"",
      ""&"": ""logical AND operator that combines both conditions"",
      ""|=>"": ""non-overlapping implication operator meaning the consequent is evaluated in the next cycle if the antecedent holds now""
    },
    ""Assertion Explaination"": ""If requester 7 is not granted the bus (sel7 == 0) and requester 2 is actively requesting (req2 == 1), then in the next cycle requester 7 remains not granted (sel7 == 0).""
  },
  ""Assertion 12"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & req3 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""req3""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""req3"": ""bus request signal from requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies equality of operand with a value"",
      ""&"": ""logical AND operator that requires both conditions to be simultaneously true"",
      ""|=>"": ""non-overlapping implication operator indicating that if the antecedent is true now, then the consequent must be true in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 7 is not granted the bus (sel7 == 0) and requester 3 is requesting the bus (req3 == 1), then in the next cycle the bus select signal for requester 7 remains off (sel7 == 0).""
  },
  ""Assertion 13"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & req5 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""req5""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""req5"": ""bus request signal from requester 5""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares a signal with a value for equality"",
      ""&"": ""logical AND operator to combine the conditions"",
      ""|=>"": ""non-overlapping implication operator that ensures the consequent holds in the cycle following the antecedent""
    },
    ""Assertion Explaination"": ""If requester 7 is not granted the bus (sel7 == 0) and requester 5 is asserting a bus request (req5 == 1), then in the next cycle requester 7 continues to not be granted the bus (sel7 == 0).""
  },
  ""Assertion 14"": {
    ""Assertion"": ""@(posedge clk) (sel7 == 0 & req6 == 1) |=> (sel7 == 0);"",
    ""Signals"": [""sel7"", ""req6""],
    ""Signal Explanations"": {
      ""sel7"": ""bus select signal for requester 7"",
      ""req6"": ""bus request signal from requester 6""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""&"": ""logical AND operator requiring both conditions to be true"",
      ""|=>"": ""non-overlapping implication which evaluates the consequent in the next cycle if the antecedent is true""
    },
    ""Assertion Explaination"": ""If the bus is not granted to requester 7 (sel7 == 0) and requester 6 is requesting the bus (req6 == 1), then in the next clock cycle requester 7 will remain not granted (sel7 == 0).""
  },
  ""Assertion 15"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & req0 == 1) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""req0""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""req0"": ""bus request signal from requester 0""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies equality"",
      ""&"": ""logical AND operator which confirms both conditions are met"",
      ""|=>"": ""non-overlapping implication operator that applies the consequent in the next cycle upon the antecedent's truth""
    },
    ""Assertion Explaination"": ""If requester 5 is not currently granted the bus (sel5 == 0) and requester 0 is requesting the bus (req0 == 1), then in the next cycle requester 5 remains not granted (sel5 == 0).""
  },
  ""Assertion 16"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & req1 == 1) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""req1""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""req1"": ""bus request signal from requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures the signal equals a specified value"",
      ""&"": ""logical AND operator that requires both conditions to be simultaneously true"",
      ""|=>"": ""non-overlapping implication operator meaning that if the antecedent is true now, the consequent must be true in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 5 is not granted the bus (sel5 == 0) and requester 1 is actively requesting the bus (req1 == 1), then in the following cycle requester 5 remains not granted (sel5 == 0).""
  },
  ""Assertion 17"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 1 & ce == 0) |=> (sel5 == 1);"",
    ""Signals"": [""sel5"", ""ce""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""ce"": ""clock enable signal that allows the state to update when active""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality of a signal with the given value"",
      ""&"": ""logical AND operator ensuring both conditions hold"",
      ""|=>"": ""non-overlapping implication operator that requires the consequent in the next cycle if the current condition holds""
    },
    ""Assertion Explaination"": ""If requester 5 is granted the bus (sel5 == 1) and the clock enable is inactive (ce == 0), then in the next cycle requester 5 continues to be granted the bus (sel5 == 1).""
  },
  ""Assertion 18"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 1 & ack == 0) |=> (sel5 == 1);"",
    ""Signals"": [""sel5"", ""ack""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""ack"": ""acknowledgment signal indicating that the bus transfer is complete""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies that a signal equals a particular value"",
      ""&"": ""logical AND operator that combines the two conditions"",
      ""|=>"": ""non-overlapping implication which means that if the antecedent is true in the current cycle, the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 5 is currently granted the bus (sel5 == 1) and the bus transfer is not yet complete (ack == 0), then in the next cycle requester 5 remains granted the bus (sel5 == 1).""
  },
  ""Assertion 19"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & ack == 0) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""ack""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""ack"": ""acknowledgment signal that indicates whether the bus transfer has been completed""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures the signal matches the specified value"",
      ""&"": ""logical AND operator which confirms both conditions are met"",
      ""|=>"": ""non-overlapping implication operator requiring the consequent in the subsequent cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 5 is not granted the bus (sel5 == 0) and the bus transfer is still pending (ack == 0), then in the next cycle requester 5 remains not granted (sel5 == 0).""
  },
  ""Assertion 20"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & ce == 0) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""ce""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""ce"": ""clock enable signal that controls the update of the state""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality with a given value"",
      ""&"": ""logical AND operator requiring that both conditions are satisfied"",
      ""|=>"": ""non-overlapping implication operator indicating the consequent must hold in the next cycle if the antecedent does""
    },
    ""Assertion Explaination"": ""When requester 5 is not granted the bus (sel5 == 0) and the clock enable is inactive (ce == 0), then in the next cycle requester 5 continues to not be granted (sel5 == 0).""
  },
  ""Assertion 21"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & req2 == 1) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""req2""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""req2"": ""bus request signal from requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies that signals have the specified values"",
      ""&"": ""logical AND operator so that both conditions must be true"",
      ""|=>"": ""non-overlapping implication operator that applies the consequent in the next cycle when the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 5 is not granted the bus (sel5 == 0) and requester 2 initiates a bus request (req2 == 1), then in the following cycle requester 5 will still not be granted the bus (sel5 == 0).""
  },
  ""Assertion 22"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & req3 == 1) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""req3""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""req3"": ""bus request signal from requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures a signal equals a given value"",
      ""&"": ""logical AND operator confirming both conditions are true"",
      ""|=>"": ""non-overlapping implication operator which requires that if the antecedent holds, the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 5 is not granted the bus (sel5 == 0) and requester 3 is requesting the bus (req3 == 1), then in the next clock cycle requester 5 continues to be not granted (sel5 == 0).""
  },
  ""Assertion 23"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & req4 == 1) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""req4""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""req4"": ""bus request signal from requester 4""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares a signal's value for equality"",
      ""&"": ""logical AND operator that combines both conditions"",
      ""|=>"": ""non-overlapping implication operator meaning that if the antecedent is true, the consequent must follow in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 5 is not currently granted the bus (sel5 == 0) and requester 4 is requesting the bus (req4 == 1), then in the next cycle requester 5 remains not granted (sel5 == 0).""
  },
  ""Assertion 24"": {
    ""Assertion"": ""@(posedge clk) (sel5 == 0 & req5 == 0) |=> (sel5 == 0);"",
    ""Signals"": [""sel5"", ""req5""],
    ""Signal Explanations"": {
      ""sel5"": ""bus select signal for requester 5"",
      ""req5"": ""bus request signal from requester 5""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures that a signal is equal to a specified value"",
      ""&"": ""logical AND operator that confirms both conditions hold"",
      ""|=>"": ""non-overlapping implication operator that enforces the consequent in the next cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 5 is not granted the bus (sel5 == 0) and requester 5 is also not requesting the bus (req5 == 0), then in the next cycle requester 5 will remain not granted (sel5 == 0).""
  },
  ""Assertion 25"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 0 & req1 == 1) |=> (sel4 == 0);"",
    ""Signals"": [""sel4"", ""req1""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""req1"": ""bus request signal from requester 1""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality of a signal with a literal value"",
      ""&"": ""logical AND operator that requires both conditions to be true"",
      ""|=>"": ""non-overlapping implication operator that applies the consequent in the next cycle when the antecedent is satisfied""
    },
    ""Assertion Explaination"": ""If requester 4 is not granted the bus (sel4 == 0) and requester 1 is requesting the bus (req1 == 1), then in the ensuing cycle requester 4 remains not granted (sel4 == 0).""
  },
  ""Assertion 26"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 1 & ack == 0) |=> (sel4 == 1);"",
    ""Signals"": [""sel4"", ""ack""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""ack"": ""acknowledgment signal indicating that a bus transfer is complete""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures the operand equals the specified value"",
      ""&"": ""logical AND operator combining the conditions"",
      ""|=>"": ""non-overlapping implication operator which means the consequent follows in the next cycle if the antecedent is true""
    },
    ""Assertion Explaination"": ""If requester 4 is granted the bus (sel4 == 1) and the bus transfer is not yet complete (ack == 0), then in the next cycle requester 4 must remain granted the bus (sel4 == 1).""
  },
  ""Assertion 27"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 0 & ack == 0) |=> (sel4 == 0);"",
    ""Signals"": [""sel4"", ""ack""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""ack"": ""acknowledgment signal indicating whether the bus transfer has completed""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares a signal to a specific value"",
      ""&"": ""logical AND operator requiring both conditions to be met"",
      ""|=>"": ""non-overlapping implication operator that enforces the consequent in the following clock cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 4 is not granted the bus (sel4 == 0) and the bus transfer is still pending (ack == 0), then in the next cycle requester 4 remains not granted (sel4 == 0).""
  },
  ""Assertion 28"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 0 & ce == 0) |=> (sel4 == 0);"",
    ""Signals"": [""sel4"", ""ce""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""ce"": ""clock enable signal that controls state updates""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks equality with a given value"",
      ""&"": ""logical AND operator that requires both conditions to be true"",
      ""|=>"": ""non-overlapping implication operator meaning that the consequent must hold in the cycle following the antecedent if it is true""
    },
    ""Assertion Explaination"": ""If requester 4 is not granted the bus (sel4 == 0) and the clock enable is inactive (ce == 0), then in the next cycle requester 4 remains not granted (sel4 == 0).""
  },
  ""Assertion 29"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 1 & ce == 0) |=> (sel4 == 1);"",
    ""Signals"": [""sel4"", ""ce""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""ce"": ""clock enable signal that allows state changes when active""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""compares signals for equality"",
      ""&"": ""logical AND operator that confirms both conditions"",
      ""|=>"": ""non-overlapping implication operator that requires the consequent in the next cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 4 is granted the bus (sel4 == 1) while the clock enable is inactive (ce == 0), then in the subsequent cycle requester 4 continues to be granted the bus (sel4 == 1).""
  },
  ""Assertion 30"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 0 & req2 == 1) |=> (sel4 == 0);"",
    ""Signals"": [""sel4"", ""req2""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""req2"": ""bus request signal from requester 2""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""ensures a signal is equal to a specified value"",
      ""&"": ""logical AND operator verifying that both conditions are met"",
      ""|=>"": ""non-overlapping implication operator that applies the consequent in the following clock cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 4 is not granted the bus (sel4 == 0) and requester 2 is requesting the bus (req2 == 1), then in the next cycle requester 4 remains not granted (sel4 == 0).""
  },
  ""Assertion 31"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 0 & req3 == 1) |=> (sel4 == 0);"",
    ""Signals"": [""sel4"", ""req3""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""req3"": ""bus request signal from requester 3""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks if the signal equals the given value"",
      ""&"": ""logical AND operator that confirms both conditions are true"",
      ""|=>"": ""non-overlapping implication operator that ensures the consequent in the next cycle if the antecedent holds""
    },
    ""Assertion Explaination"": ""If requester 4 is not granted the bus (sel4 == 0) and requester 3 requests the bus (req3 == 1), then in the next clock cycle requester 4 remains not granted (sel4 == 0).""
  },
  ""Assertion 32"": {
    ""Assertion"": ""@(posedge clk) (sel4 == 0 & req4 == 0) |=> (sel4 == 0);"",
    ""Signals"": [""sel4"", ""req4""],
    ""Signal Explanations"": {
      ""sel4"": ""bus select signal for requester 4"",
      ""req4"": ""bus request signal from requester 4""
    },
    ""Logical Operators"": [""=="", ""&"", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""verifies equality with a given value"",
      ""&"": ""logical AND operator combining both conditions"",
      ""|=>"": ""non-overlapping implication operator meaning that if the antecedent holds in the current cycle, the consequent must hold in the next cycle""
    },
    ""Assertion Explaination"": ""If requester 4 is not granted the bus (sel4 == 0) and requester 4 is not even requesting the bus (req4 == 0), then in the next cycle requester 4 remains not granted (sel4 == 0).""
  }
}"
"module simple_req_ack (
	input  clk,
	input  rst_n,

	input  req,
	output ack
);
	logic req_ff, ack_ff;

	always_ff @(negedge rst_n, posedge clk)
		if (!rst_n)
			req_ff <= '0;
		else
			if (req_ff)
				req_ff <= '0;
			else
				req_ff <= req;

	always_ff @(negedge rst_n, posedge clk)
		if (!rst_n)
			ack_ff <= '0;
		else
		if (ack_ff)
			ack_ff <= '0;
		else
		if (req_ff)
			ack_ff <= '1;

	assign ack = ack_ff;

endmodule","module simple_req_ack_sva (input clk, rst_n, req, ack);

	// PROPERTY 
	property sva_req_ack1 (clk, rst_n, req, ack);
		@(posedge clk) disable iff(!rst_n)
		req |-> ##2 ack;
	endproperty

	property sva_req_ack2 (clk, rst_n, req, ack);
		@(posedge clk) disable iff(!rst_n)
		$rose(req) |-> ##2 $rose(ack);
	endproperty

	property sva_req_ack3 (clk, rst_n, req, ack);
		@(posedge clk) disable iff(!rst_n)
		$rose(req) |-> ##1 $fell(req) ##1 $rose(ack) ##1 $fell(ack);
	endproperty

	property sva_req_ack4 (clk, rst_n, req, ack);
		@(posedge clk) disable iff(!rst_n)
		$rose(req) |->
			!ack ##1 ($fell(req) & !ack) ##1 ($rose(ack) & !req) ##1 ($fell(ack) & !req);
	endproperty

	// ASSERT PROPERTY
	// assert_sva_req_ack1 : assert property( sva_req_ack1(clk, rst_n, req, ack) );
	assert_sva_req_ack2 : assert property( sva_req_ack2(clk, rst_n, req, ack) );
	// assert_sva_req_ack3 : assert property( sva_req_ack3(clk, rst_n, req, ack) );
	// assert_sva_req_ack4 : assert property( sva_req_ack4(clk, rst_n, req, ack) );

endmodule",https://github.com/hassyy/systemverilog-assertion/blob/master/simple-req-ack/sva_req_ack.sv,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property( sva_req_ack1(clk, rst_n, req, ack) );"",
    ""Signals"": [""clk"", ""rst_n"", ""req"", ""ack""],
    ""Signal Explanations"": {
      ""clk"": ""clock input"",
      ""rst_n"": ""active low reset signal"",
      ""req"": ""request input signal that indicates a request when high"",
      ""ack"": ""acknowledgement output signal indicating that the request has been serviced""
    },
    ""Logical Operators"": [""posedge"", ""!"", ""disable iff"", ""|->"", ""##2""],
    ""Logical Operators Explanation"": {
      ""posedge"": ""triggered on the rising edge of the clock"",
      ""!"": ""logical NOT operator, used here to detect that reset is not active (i.e., rst_n is 0)"",
      ""disable iff"": ""disables the assertion check when the condition (here, !rst_n) is true"",
      ""|->"": ""non-overlapping implication operator; if the antecedent is true in the current cycle, then the consequent must hold starting from a specified delay"",
      ""##2"": ""a delay operator specifying that the consequent should be true exactly two clock cycles later""
    },
    ""Assertion Explaination"": ""At every rising edge of the clock, if the reset is not active, whenever the request signal is high, it implies that two clock cycles later the acknowledgement signal must be asserted.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property( sva_req_ack2(clk, rst_n, req, ack) );"",
    ""Signals"": [""clk"", ""rst_n"", ""req"", ""ack""],
    ""Signal Explanations"": {
      ""clk"": ""clock input"",
      ""rst_n"": ""active low reset signal"",
      ""req"": ""request input signal where a rising edge indicates a new request"",
      ""ack"": ""acknowledgement output signal that confirms the request has been serviced""
    },
    ""Logical Operators"": [""posedge"", ""!"", ""disable iff"", ""$rose"", ""|->"", ""##2""],
    ""Logical Operators Explanation"": {
      ""posedge"": ""triggered on the rising edge of the clock"",
      ""!"": ""logical NOT operator, used here for checking that reset is inactive"",
      ""disable iff"": ""disables the assertion check when the reset (rst_n) is not active"",
      ""$rose"": ""detects a rising edge on a signal (i.e., a transition from 0 to 1)"",
      ""|->"": ""non-overlapping implication operator; when the antecedent occurs this cycle, the consequent must occur after the specified delay"",
      ""##2"": ""a delay of two clock cycles before checking the consequent condition""
    },
    ""Assertion Explaination"": ""On every rising clock edge, if reset is inactive and a rising edge is detected on the request signal, it implies that a rising edge on the acknowledgement signal must occur exactly two clock cycles later.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property( sva_req_ack3(clk, rst_n, req, ack) );"",
    ""Signals"": [""clk"", ""rst_n"", ""req"", ""ack""],
    ""Signal Explanations"": {
      ""clk"": ""clock input"",
      ""rst_n"": ""active low reset signal"",
      ""req"": ""request input signal that initiates the handshake sequence"",
      ""ack"": ""acknowledgement output signal that responds to the request""
    },
    ""Logical Operators"": [""posedge"", ""!"", ""disable iff"", ""$rose"", ""$fell"", ""|->"", ""##1""],
    ""Logical Operators Explanation"": {
      ""posedge"": ""triggered on the rising edge of the clock"",
      ""!"": ""logical NOT operator, indicating the negated condition of a signal"",
      ""disable iff"": ""disables the assertion check when the reset is inactive (i.e., rst_n is low)"",
      ""$rose"": ""detects a rising edge on a signal (transition from 0 to 1)"",
      ""$fell"": ""detects a falling edge on a signal (transition from 1 to 0)"",
      ""|->"": ""non-overlapping implication operator that sequences events following the triggering condition"",
      ""##1"": ""a delay of one clock cycle between sequential events""
    },
    ""Assertion Explaination"": ""At each rising edge of the clock when reset is inactive, if a rising edge is detected on the request signal, then one clock cycle later the request signal must fall, followed by one clock cycle later a rising edge on the acknowledgement signal, and then one more clock cycle later the acknowledgement signal must fall. This defines a precise sequence of transitions for a complete handshake.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property( sva_req_ack4(clk, rst_n, req, ack) );"",
    ""Signals"": [""clk"", ""rst_n"", ""req"", ""ack""],
    ""Signal Explanations"": {
      ""clk"": ""clock input"",
      ""rst_n"": ""active low reset signal"",
      ""req"": ""request input signal that starts the handshake"",
      ""ack"": ""acknowledgement output signal that confirms servicing the request""
    },
    ""Logical Operators"": [""posedge"", ""!"", ""disable iff"", ""$rose"", ""|->"", ""##1"", ""$fell"", ""&"", ""$rose""],
    ""Logical Operators Explanation"": {
      ""posedge"": ""triggered on the rising edge of the clock"",
      ""!"": ""logical NOT operator, indicating the signal should be low"",
      ""disable iff"": ""disables the assertion when reset is low (inactive)"",
      ""$rose"": ""detects a rising edge on a signal (transition from 0 to 1)"",
      ""|->"": ""non-overlapping implication operator that triggers a sequence once the antecedent condition is met"",
      ""##1"": ""a one clock cycle delay between sequential events"",
      ""$fell"": ""detects a falling edge on a signal (transition from 1 to 0)"",
      ""&"": ""logical AND operator, used to require that multiple conditions are simultaneously true""
    },
    ""Assertion Explaination"": ""At every rising clock edge with reset inactive, a rising edge on the request signal triggers a sequence: immediately the acknowledgement signal must be low; one cycle later the request must fall while the acknowledgement remains low; one cycle after that the acknowledgement must rise while the request remains low; and finally, one cycle later the acknowledgement must fall while the request continues to be low. This enforces a tightly controlled four-phase handshake sequence.""
  }
}"
"//////////////////////////////////////////////////////////////////
////
////
//// 	APB module to I2C Core
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// apbi2c_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Ronal Dario Celaya
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////

`timescale 1ns/1ps //timescale 

module apb(
			//standard ARM
	    		input PCLK,
			input PRESETn,
			input PSELx,
			input PWRITE,
			input PENABLE,
			input [31:0] PADDR,
			input [31:0] PWDATA,

			//internal pin
			input [31:0] READ_DATA_ON_RX,
			input ERROR,
			input TX_EMPTY,
			input RX_EMPTY,
			
			//external pin
			output [31:0] PRDATA,

			//internal pin 
			output reg [13:0] INTERNAL_I2C_REGISTER_CONFIG,
			output reg [13:0] INTERNAL_I2C_REGISTER_TIMEOUT,
			output [31:0] WRITE_DATA_ON_TX,
			output  WR_ENA,
			output  RD_ENA,
			
			//outside port 
			output PREADY,
			output PSLVERR,

			//interruption
			output INT_RX,
			output INT_TX
	   

	  );

//ENABLE WRITE ON TX FIFO
assign WR_ENA = (PWRITE == 1'b1 & PENABLE == 1'b1 & PADDR == 32'd0 & PSELx == 1'b1)?  1'b1:1'b0;

//ENABLE READ ON RX FIFO
assign RD_ENA = (PWRITE == 1'b0 & PENABLE == 1'b1  & PADDR == 32'd4 & PSELx == 1'b1)?  1'b1:1'b0;

//WRITE ON I2C MODULE
assign PREADY = ((WR_ENA == 1'b1 | RD_ENA == 1'b1 | PADDR == 32'd8 | PADDR == 32'd12) &  (PENABLE == 1'b1 & PSELx == 1'b1))? 1'b1:1'b0;

//INPUT TO WRITE ON TX FIFO
assign WRITE_DATA_ON_TX = (PADDR == 32'd0)? PWDATA:PWDATA;

//OUTPUT DATA FROM RX TO PRDATA
assign PRDATA = (PADDR == 32'd4)? READ_DATA_ON_RX:READ_DATA_ON_RX;

//ERROR FROM I2C CORE
assign PSLVERR = ERROR; 

//INTERRUPTION FROM I2C
assign INT_TX = TX_EMPTY;

//INTERRUPTION FROM I2C
assign INT_RX = RX_EMPTY;

//This is sequential logic used only to register configuration
always@(posedge PCLK)
begin

	if(!PRESETn)
	begin
		INTERNAL_I2C_REGISTER_CONFIG <= 14'd0;
		INTERNAL_I2C_REGISTER_TIMEOUT <= 14'd0;
	end
	else
	begin

		// Set configuration to i2c
		if(PADDR == 32'd8 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1)
		begin
			INTERNAL_I2C_REGISTER_CONFIG <= PWDATA[13:0];
		end
		else if(PADDR == 32'd12 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1)
		begin
			INTERNAL_I2C_REGISTER_TIMEOUT <= PWDATA[13:0];
		end
		else
		begin
			INTERNAL_I2C_REGISTER_CONFIG <= INTERNAL_I2C_REGISTER_CONFIG;
		end
		
	end

end 


endmodule","module apb_sva(
			input PRESETn,
			input [31:0] READ_DATA_ON_RX,
			input ERROR,
	    		input PCLK,
			input [13:0] INTERNAL_I2C_REGISTER_TIMEOUT,
			input [31:0] PWDATA,
			input INT_TX,
			input [31:0] WRITE_DATA_ON_TX,
			input  WR_ENA,
			input [31:0] PRDATA,
			input  RD_ENA,
			input [13:0] INTERNAL_I2C_REGISTER_CONFIG,
			input RX_EMPTY,
			input PREADY,
			input [31:0] PADDR,
			input PWRITE,
			input PENABLE,
			input INT_RX,
			input PSELx,
			input TX_EMPTY,
			input PSLVERR
);
property a5;
@(posedge PCLK) (ERROR == 0) |-> (PSLVERR == 0);
endproperty
assert_a5: assert property(a5);

property a4;
@(posedge PCLK) (ERROR == 1) |-> (PSLVERR == 1);
endproperty
assert_a4: assert property(a4);
property a3;
@(posedge PCLK) (TX_EMPTY == 1) |-> (INT_TX == 1);
endproperty
assert_a3: assert property(a3);

property a2;
@(posedge PCLK) (TX_EMPTY == 0) |-> (INT_TX == 0);
endproperty
assert_a2: assert property(a2);

property a1;
@(posedge PCLK) (RX_EMPTY == 0) |-> (INT_RX == 0);
endproperty
assert_a1: assert property(a1);

property a0;
@(posedge PCLK) (RX_EMPTY == 1) |-> (INT_RX == 1);
endproperty
assert_a0: assert property(a0);


endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/NIPS_2024/Jasper_results/communication_controller_apb_to_i2c/apb/FPV_apb.tcl,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property((ERROR == 0) |-> (PSLVERR == 0));"",
    ""Signals"": [""ERROR"", ""PSLVERR""],
    ""Signal Explanations"": {
      ""ERROR"": ""input error signal coming from the I2C core indicating an error condition"",
      ""PSLVERR"": ""slave error output signal of the APB module which mirrors the ERROR signal""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""|->"": ""non-overlapping implication operator indicating that if the antecedent is true in the current clock cycle, then the consequent must be true in that cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the error signal (ERROR) is 0 (indicating no error), then the slave error signal (PSLVERR) must also be 0.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property((ERROR == 1) |-> (PSLVERR == 1));"",
    ""Signals"": [""ERROR"", ""PSLVERR""],
    ""Signal Explanations"": {
      ""ERROR"": ""input error signal coming from the I2C core indicating an error condition"",
      ""PSLVERR"": ""slave error output signal of the APB module which mirrors the ERROR signal""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""|->"": ""non-overlapping implication operator meaning that if the antecedent is true in the current clock cycle, then the consequent must be true in that cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the error signal (ERROR) is 1 (indicating an error), then the slave error signal (PSLVERR) must also be 1.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property((TX_EMPTY == 1) |-> (INT_TX == 1));"",
    ""Signals"": [""TX_EMPTY"", ""INT_TX""],
    ""Signal Explanations"": {
      ""TX_EMPTY"": ""input signal indicating that the transmit FIFO is empty"",
      ""INT_TX"": ""transmit interrupt signal which is driven by the status of TX_EMPTY""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""|->"": ""non-overlapping implication operator meaning that if the antecedent is true on the current clock cycle, the consequent must be true in that same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the transmit FIFO empty indicator (TX_EMPTY) is 1 (empty), then the transmit interrupt signal (INT_TX) should also be 1 (asserted).""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property((TX_EMPTY == 0) |-> (INT_TX == 0));"",
    ""Signals"": [""TX_EMPTY"", ""INT_TX""],
    ""Signal Explanations"": {
      ""TX_EMPTY"": ""input signal indicating that the transmit FIFO is empty"",
      ""INT_TX"": ""transmit interrupt signal which is driven by the status of TX_EMPTY""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""|->"": ""non-overlapping implication operator meaning that if the antecedent is true on the current clock cycle, the consequent must be true in that same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the transmit FIFO empty indicator (TX_EMPTY) is 0 (not empty), then the transmit interrupt signal (INT_TX) should also be 0 (not asserted).""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property((RX_EMPTY == 0) |-> (INT_RX == 0));"",
    ""Signals"": [""RX_EMPTY"", ""INT_RX""],
    ""Signal Explanations"": {
      ""RX_EMPTY"": ""input signal indicating that the receive FIFO is empty"",
      ""INT_RX"": ""receive interrupt signal which is driven by the status of RX_EMPTY""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""|->"": ""non-overlapping implication operator meaning that if the antecedent is true on the current clock cycle, the consequent must be true in that same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the receive FIFO empty indicator (RX_EMPTY) is 0 (not empty), then the receive interrupt signal (INT_RX) should also be 0 (not asserted).""
  },
  ""Assertion 6"": {
    ""Assertion"": ""assert property((RX_EMPTY == 1) |-> (INT_RX == 1));"",
    ""Signals"": [""RX_EMPTY"", ""INT_RX""],
    ""Signal Explanations"": {
      ""RX_EMPTY"": ""input signal indicating that the receive FIFO is empty"",
      ""INT_RX"": ""receive interrupt signal which is driven by the status of RX_EMPTY""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality between operands"",
      ""|->"": ""non-overlapping implication operator meaning that if the antecedent is true on the current clock cycle, the consequent must be true in that same cycle""
    },
    ""Assertion Explaination"": ""This assertion states that if the receive FIFO empty indicator (RX_EMPTY) is 1 (empty), then the receive interrupt signal (INT_RX) should also be 1 (asserted).""
  }
}"
"////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16


module uartTrans (clk, reset, sTick, txDoneTick, din, tx, txStart);

		parameter dataBits = `dataBits;
		parameter sbTick = `sbTick;
		
		input [dataBits-1 :0] din;
		input clk, reset, sTick, txStart;
		output tx, txDoneTick;
		
		reg txDoneTick;
		
/*
should be impleneted as a 4-state FSM : idle, start, data, stop;

*/

	localparam [1:0] idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11;
	
		reg [1:0] stateReg, stateNext;	// current and next states
		reg [3:0] sReg, sNext;		//	counter
		reg [2:0] nReg, nNext;		// counter
		reg [7:0] bReg, bNext;		// perhaps keeps data to be sent
		reg		 txReg, txNext;	// current bit being transferred
		
		
		//	reset and non-reset conditions:
		
		always @ (posedge clk or posedge reset)
		begin
			if (reset)
			begin
				stateReg <= idle;
				sReg <= 1'b0;
				bReg <= 1'b0;
				nReg <= 1'b0;
				txReg <= 1'b1;
			end	// end if
			
			else
			begin
				stateReg <= stateNext;
				sReg <= sNext;
				bReg <= bNext;
				nReg <= nNext;
				txReg <= txNext;
			end	// end else
		
		end	// end always
		
		// FSM:
		
		always @ *
		begin
				stateNext = stateReg;
				sNext = sReg;
				bNext = bReg;
				nNext = nReg;
				txNext = txReg;
				
				txDoneTick = 1'b0;		// not done yet!
				
			case	(stateReg)
			
				idle	:	begin
								txNext = 1'b1;	// start bit '0'; thus, send '1' in idle
								
								if (txStart)
								begin
									txDoneTick = 1'b1;	// generate rd for fifo **
									stateNext = start;	// should go into start state
									sNext = 0;
								end	// end if txStart
							// in idle state unless txStart...
							end	// end idle case
							
				start	:	begin
								txNext = 0;
								txDoneTick = 1'b0;		// **
								bNext = din;		// take din into bReg
								if (sTick)
									if (sReg == 15)
									begin
										stateNext = data;
										sNext = 1'b0;
										nNext = 1'b0;
									end	// end if sReg==15
									
									else
										sNext = sReg + 1;	// keep incrementing sNext (sReg)
										// sReg = sNext on each clk edge !!
							end	// end start case
							
				data	:	begin
								txNext = bReg[0];	// keep sending LSB of bReg
								
								if (sTick)
									if (sReg == 15)
									begin
										sNext = 0;	// reset counter
										bNext = bReg >> 1;	// shift word to be sent
										
										if (nReg == (dataBits-1))
											stateNext = stop;
										else
											nNext = nReg +1;
									end	// end if sReg==15
								else
									sNext = sReg + 1;
				
							end	// end data state
							
				stop	:	begin
								txNext = 1'b1;
								
								if (sTick)
									if (sReg == sbTick-1)
									begin
										stateNext = idle;
										//txDoneTick = 1'b1; it's working as read signal to
										// fifo, so, used at starting . . .
									end //end if sReg==15
									else
										sNext = sReg + 1;
							end	// end stop state
			
			endcase
		
		end	// end always combinatorial

		
		// output bit-stream
		
		assign tx = txReg;

endmodule","
////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16

module uartTrans_sva(
		// input bit-stream
		input [1:0] stateReg, stateNext,	// current and next states
		input [2:0] nReg, nNext,		// counter
		input tx, txDoneTick,
		input		 txReg, txNext,	// current bit being transferred
		input [3:0] sReg, sNext,		//	counter
		input clk, reset, sTick, txStart,
		input [7:0] bReg, bNext,		// perhaps keeps data to be sent
		input [`dataBits-1 :0] din
);
property a10;
@(posedge clk) (txNext == 0) |=> (tx == 0);
endproperty
assert_a10: assert property(a10);

property a9;
@(posedge clk) (txNext == 1) |=> (tx == 1);
endproperty
assert_a9: assert property(a9);


property a6;
@(posedge clk) (stateReg[0] == 1) |-> (txDoneTick == 0);
endproperty
assert_a6: assert property(a6);

property a0;
@(posedge clk) (txStart == 0) |-> (txDoneTick == 0);
endproperty
assert_a0: assert property(a0);
endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/NIPS_2024/Jasper_results/arithmetic_core_8-bit_piepelined_processor/uartTrans/FPV_uartTrans.tcl,"{
""Assertion 1"": {
""Assertion"": ""assert property((txNext == 0) |=> (tx == 0));"",
""Signals"": [""txNext"", ""tx""],
""Signal Explanations"": {
  ""txNext"": ""the next value of the transmission bit generated by the UART FSM"",
  ""tx"": ""the actual output bit being transmitted by the UART module""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""checks equality between the left-hand side and right-hand side signals"",
  ""|=>"": ""if the antecedent condition holds at a given clock cycle, then the consequent must hold in a future cycle""
},
""Assertion Explaination"": ""This assertion states that if the next transmission bit (txNext) is equal to 0, then eventually the actual transmission output (tx) must become 0. In other words, whenever the UART FSM schedules a 0 for transmission, the transmitted bit output will follow as 0.""
},
""Assertion 2"": {
""Assertion"": ""assert property((txNext == 1) |=> (tx == 1));"",
""Signals"": [""txNext"", ""tx""],
""Signal Explanations"": {
  ""txNext"": ""the next value of the transmission bit generated by the UART FSM"",
  ""tx"": ""the actual output bit being transmitted by the UART module""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""checks equality between two signals"",
  ""|=>"": ""if the antecedent is true at a clock edge, then the consequent must eventually be true in a subsequent cycle""
},
""Assertion Explaination"": ""This assertion ensures that if the next transmission bit (txNext) is 1, then in a following evaluation the transmitted output (tx) will be 1. It enforces that the UART’s output bit correctly follows the scheduled transmission value.""
},
""Assertion 3"": {
""Assertion"": ""assert property((stateReg[0] == 1) |-> (txDoneTick == 0));"",
""Signals"": [""stateReg"", ""txDoneTick""],
""Signal Explanations"": {
  ""stateReg"": ""the current state of the UART FSM, with stateReg[0] representing its least significant bit"",
  ""txDoneTick"": ""a flag signal that indicates the completion of a transmission cycle""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""verifies equality between the specified bit or signal and a constant"",
  ""|->"": ""if the antecedent condition holds at the current clock cycle, then the consequent must hold immediately""
},
""Assertion Explaination"": ""This assertion dictates that whenever the least significant bit of the current state (stateReg[0]) is 1, then the transmission done flag (txDoneTick) must be 0 at that same cycle. It enforces that during specific states of operation indicated by stateReg[0] being 1, no transmission completion is signaled.""
},
""Assertion 4"": {
""Assertion"": ""assert property((txStart == 0) |-> (txDoneTick == 0));"",
""Signals"": [""txStart"", ""txDoneTick""],
""Signal Explanations"": {
  ""txStart"": ""the signal that initiates a transmission in the UART module"",
  ""txDoneTick"": ""a flag signal indicating that a transmission cycle has been completed""
},
""Logical Operators"": [""=="", ""|->""],
""Logical Operators Explanation"": {
  ""=="": ""checks for equality between the signal value and the constant"",
  ""|->"": ""if the antecedent condition is true at the clock edge, then the consequent must hold immediately""
},
""Assertion Explaination"": ""This assertion specifies that if the transmission start signal (txStart) is not active (equal to 0), then the transmission done flag (txDoneTick) must also be 0. This ensures that when no new transmission is being started, the module does not erroneously indicate that a transmission cycle has been completed.""
}
}"
"////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16


module uartRec(clk, reset, sTick, rx, rxDoneTick, dOut);

		parameter dataBits = `dataBits;
		parameter sbTick = `sbTick;
		
		input clk, reset, sTick, rx;
		output rxDoneTick;
		output [dataBits-1:0] dOut;
		
		reg rxDoneTick;
		// states:
		
	localparam idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11;
	
		reg [1:0] stateReg, stateNext;	// current and next states
		reg [3:0] sReg, sNext;		//	counter
		reg [2:0] nReg, nNext;		// counter
		reg [7:0] bReg, bNext;		// data recieved in this..
		
		
		always @ (posedge clk or posedge reset)
		begin
			if (reset)
			begin
				stateReg <= idle;
				sReg <= 1'b0;
				bReg <= 1'b0;
				nReg <= 1'b0;
			end	// end if
			
			else
			begin
				stateReg <= stateNext;
				sReg <= sNext;
				bReg <= bNext;
				nReg <= nNext;
			end	// end else
		
		end	// end always
		
		
		
		// FSM next state logic:
		
		always @ *
		begin
		
				stateNext = stateReg;
				sNext = sReg;
				bNext = bReg;
				nNext = nReg;
				rxDoneTick = 1'b0;
				
			case (stateReg)
			
			idle	:	if (~rx)
						begin
							stateNext = start;	// start when rx is activated
							sNext = 0;	// initialize sampling counter
						end	// end if rx
						
			start	:	if (sTick)
							if (sReg == 7)
							begin
								stateNext = data;		// at middle of oversampled start
													// bit, go to data state
								sNext = 0;
								nNext = 0;
							end	// end if sReg==7
							
							else
								sNext = sReg + 1;	// otherwise keep increment sReg upto 7
			
			data	:	if (sTick)
							if (sReg == 15)	// if reached middle of next bit
							begin
								sNext = 0;	// reset counter
								bNext = {rx, bReg[7:1]};	// LSB first, and the
														//data recieved in bReg
								if (nReg == (dataBits-1))	// if all data recvd,
									stateNext = stop;	// go to stop bit(s) state
								else
									nNext = nReg + 1;
							end	// end if sReg==15
							
							else
								sNext = sReg + 1;	// otherwise keep increment sReg upto 15
							
			stop	:	if (sTick)
							if (sReg == (sbTick-1))
							begin
								stateNext = idle;		// done reception, go to idle state
								rxDoneTick = 1'b1;	// raise done tick!
							end	// end if sReg==sbTick-1
							
							else
								sNext = sReg + 1;		// otherwise keep increment sReg 
															//upto (sbTick-1)
			endcase
		
		end	// end always combinatorial
		
		
		// recvd data output
		
		assign dOut = bReg;


endmodule","////////////////////////////////////////////////////////////////////////////////////////////////
////                                                              							////
////                                                              							////
////  	This file is part of the project                 									////
////	""instruction_list_pipelined_processor_with_peripherals""								////
////                                                              							////
////  http://opencores.org/project,instruction_list_pipelined_processor_with_peripherals	////
////                                                              							////
////                                                              							////
//// 				 Author:                                                  				////
////      			- Mahesh Sukhdeo Palve													////
////																						////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////																						////
//// 											                 							////
////                                                              							////
//// 					This source file may be used and distributed without         		////
//// 					restriction provided that this copyright statement is not    		////
//// 					removed from the file and that any derivative work contains  		////
//// 					the original copyright notice and the associated disclaimer. 		////
////                                                              							////
//// 					This source file is free software; you can redistribute it   		////
//// 					and/or modify it under the terms of the GNU Lesser General   		////
//// 					Public License as published by the Free Software Foundation; 		////
////					either version 2.1 of the License, or (at your option) any   		////
//// 					later version.                                               		////
////                                                             							////
//// 					This source is distributed in the hope that it will be       		////
//// 					useful, but WITHOUT ANY WARRANTY; without even the implied   		////
//// 					warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      		////
//// 					PURPOSE.  See the GNU Lesser General Public License for more 		////
//// 					details.                                                     		////
////                                                              							////
//// 					You should have received a copy of the GNU Lesser General    		////
//// 					Public License along with this source; if not, download it   		////
//// 					from http://www.opencores.org/lgpl.shtml                     		////
////                                                              							////
////////////////////////////////////////////////////////////////////////////////////////////////

// 8-bit Pipelined Processor defines

`define		immDataLen			8

// program counter & instruction register
`define		instAddrLen			10			// 10-bit address => 1024 inst in rom
`define		instLen				15			// 15-bit fixed-length instructions
`define		instOpCodeLen		5
`define		instFieldLen		10


// control unit
`define		cuStateLen			4		// max 16 states
`define		END					`instOpCodeLen'b0
`define		JMP					`instOpCodeLen'b1
`define		Ld						`instOpCodeLen'b10
`define		Ldi					`instOpCodeLen'b11
`define		ST						`instOpCodeLen'b100
`define		ADD					`instOpCodeLen'b101
`define		SUB					`instOpCodeLen'b110
`define		MUL					`instOpCodeLen'b111
`define		DIV					`instOpCodeLen'b1000
`define		AND					`instOpCodeLen'b1001
`define		OR						`instOpCodeLen'b1010
`define		XOR					`instOpCodeLen'b1011
`define		GrT					`instOpCodeLen'b1100
`define		GE						`instOpCodeLen'b1101
`define		EQ						`instOpCodeLen'b1110
`define		LE						`instOpCodeLen'b1111
`define		LT						`instOpCodeLen'b10000
`define		PRE					`instOpCodeLen'b10001
`define		ETY					`instOpCodeLen'b10010
`define		RST					`instOpCodeLen'b10011
`define		LdTC					`instOpCodeLen'b10100
`define		LdACC					`instOpCodeLen'b10101
`define		UARTrd				`instOpCodeLen'b10110
`define		UARTwr				`instOpCodeLen'b10111
`define		UARTstat				`instOpCodeLen'b11000
//`define		SPIxFER				`instOpCodeLen'b11001
//`define		SPIstat				`instOpCodeLen'b11010
//`define		SPIwBUF				`instOpCodeLen'b11011
//`define		SPIrBUF				`instOpCodeLen'b11100

// alu opcodes
`define		aluOpcodeLen		4
`define		AND_alu				`aluOpcodeLen'b0
`define		OR_alu				`aluOpcodeLen'b1
`define		XOR_alu				`aluOpcodeLen'b10
`define		GT_alu				`aluOpcodeLen'b11
`define		GE_alu				`aluOpcodeLen'b100
`define		EQ_alu				`aluOpcodeLen'b101
`define		LE_alu				`aluOpcodeLen'b110
`define		LT_alu				`aluOpcodeLen'b111
`define		ADD_alu				`aluOpcodeLen'b1000
`define		SUB_alu				`aluOpcodeLen'b1001
`define		MUL_alu				`aluOpcodeLen'b1010
`define		DIV_alu				`aluOpcodeLen'b1011
`define		LD_data				`aluOpcodeLen'b1100

// bit RAM
`define		bitRamAddrLen		7		// 7-bit address
`define		bitRamDepth			128	// 2^7 = 128 locations

// byte RAM
`define		byteRamLen			8		// 8-bit input
`define		byteRamAddrLen		7		// 7-bit address
`define		byteRamDepth		128	// 2^7 = 128 locations

// input register
`define		inputNumber			128	// 128 inputs
`define		inputAddrLen		7		// 7-bit address

// output register
`define		outputNumber		128	// 128 outputs
`define		outputAddrLen		7		// 7-bit address

// accumulator multiplexer
`define		accMuxSelLen			4		// 2^4 = 16 selections available for accumulator
`define		accMuxSelImmData		`accMuxSelLen'b0
`define		accMuxSelAluOut		`accMuxSelLen'b1
`define		accMuxSelTcLoad		`accMuxSelLen'b10
`define		accMuxSelTcAcc			`accMuxSelLen'b11
`define		accMuxSelUartData		`accMuxSelLen'b100
`define		accMuxSelUartStat		`accMuxSelLen'b101

// operand2 multiplexer
`define		op2MuxSelLen			4		// 2^4 = 16 selections available for op2
`define		op2MuxSelInput			`op2MuxSelLen'b0
`define		op2MuxSelOutput		`op2MuxSelLen'b1
`define		op2MuxSelBitRam		`op2MuxSelLen'b10
`define		op2MuxSelByteRam		`op2MuxSelLen'b11
`define		op2MuxSel4			`op2MuxSelLen'b100
`define		op2MuxSel5			`op2MuxSelLen'b101
`define		op2MuxSel6			`op2MuxSelLen'b110

//-----------------------------------------------------------------------------------------------------

// peripheral defines
`define		timerAndCounter_peripheral
`define		UART_peripheral


//-----------------------------------------------------------------------------------------------------

// Timer-Counter
`define		tcAccLen				8		// 8-bit accumulated value
`define		tcPresetLen			8		// 8-bit preset value
`define		tcAddrLen			4
`define		tcTypeLen			2		// max 4-types
`define		tcNumbers			8		// total 8 modules (4-timers, 4-counters)

`define		timerType1			`tcTypeLen'b0
`define		timerType2			`tcTypeLen'b1
`define		timerType3			`tcTypeLen'b10

`define		counterType1		`tcTypeLen'b1
`define		counterType2		`tcTypeLen'b10


//-----------------------------------------------------------------------------------------------------

// UART
`define		dataBits 			8
`define		sbTick 				16	// ticks for stop bits (16 for 1-stopBit)
`define		fifoWidth 			4
`define 		number_fifo_regs 	16
`define 		fifoCntrWidth 		5
`define 		fifoDepth 			16

module uartRec_sva(
		input [7:0] bReg, bNext,		// data recieved in this..
		// recvd data input
		input [1:0] stateReg, stateNext,	// current and next states
		input rxDoneTick,
		input [3:0] sReg, sNext,		//	counter
		input clk, reset, sTick, rx,
		input [`dataBits-1:0] dOut,
		input [2:0] nReg,
		input [2:0] nNext		// counter
);
property a4;
@(posedge clk) (stateReg[0] == 0) |-> (rxDoneTick == 0);
endproperty
assert_a4: assert property(a4);

property a1;
@(posedge clk) (sReg[2] == 0) |=> (rxDoneTick == 0);
endproperty
assert_a1: assert property(a1);

property a0;
@(posedge clk) (sReg[1] == 0) |=> (rxDoneTick == 0);
endproperty
assert_a0: assert property(a0);

property a3;
@(posedge clk) (nReg[1] == 0) |=> (rxDoneTick == 0);
endproperty
assert_a3: assert property(a3);

property a2;
@(posedge clk) (nReg[0] == 0) |=> (rxDoneTick == 0);
endproperty
assert_a2: assert property(a2);

property a5;
@(posedge clk) (sTick == 0) |-> (rxDoneTick == 0);
endproperty
assert_a5: assert property(a5);

property a6;
@(posedge clk) (sNext[0] == 0) |=> (rxDoneTick == 0);
endproperty
assert_a6: assert property(a6);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/NIPS_2024/Jasper_llama_results/arithmetic_core_8-bit_piepelined_processor/uartRec/FPV_uartRec.tcl,"{
  ""Assertion 1"": {
    ""Assertion"": ""@(posedge clk) (stateReg[0] == 0) |-> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""stateReg"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal driving the synchronous operations in the UART receiver."",
      ""stateReg"": ""The 2‐bit state register of the UART receiver state machine that holds the current state (idle, start, data, stop)."",
      ""rxDoneTick"": ""The output signal that indicates the completion of a UART data reception (done tick).""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks for equality between two values."",
      ""|->"": ""Non-overlapping implication; if the antecedent holds at a clock edge, then the consequent must hold in the cycle immediately following (non overlapping in time).""
    },
    ""Assertion Explaination"": ""At every positive clock edge, if the least significant bit of the state register is 0, then in the next (non overlapping) cycle the rxDoneTick signal must also be 0.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""@(posedge clk) (sReg[2] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""sReg"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal driving the sequential logic in the UART receiver."",
      ""sReg"": ""The 4‐bit sampling counter used to time the sampling instants during bit reception."",
      ""rxDoneTick"": ""The signal that flags the completion of the UART byte reception.""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks if the specified bit is equal to 0."",
      ""|=>"": ""Overlapping implication; if the antecedent is true at a clock edge, the consequent must also hold in the same cycle.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, if bit 2 of the sampling counter is 0, then in that same cycle the rxDoneTick signal must be 0.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""@(posedge clk) (sReg[1] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""sReg"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal for all synchronous processes within the module."",
      ""sReg"": ""The 4‐bit sampling counter that increments during the reception of a UART data bit."",
      ""rxDoneTick"": ""The output signal that indicates when the entire data byte has been received.""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""Evaluates equality of the specific bit to 0."",
      ""|=>"": ""Overlapping implication ensuring that if the antecedent is true at the clock edge, the consequent must be true in the same cycle.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, if bit 1 of the sampling counter is 0, then in that same cycle the rxDoneTick signal must be 0.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""@(posedge clk) (nReg[1] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""nReg"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal driving the FSM and counters of the UART receiver."",
      ""nReg"": ""A 3‐bit counter that tracks the number of data bits that have been received."",
      ""rxDoneTick"": ""The flag signal that is asserted when data reception is complete.""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks that the specified bit of the counter equals 0."",
      ""|=>"": ""Overlapping implication; the consequent must hold in the same cycle as the antecedent if the antecedent is true.""
    },
    ""Assertion Explaination"": ""At each positive clock edge, if bit 1 of the data bit counter is 0, then rxDoneTick must be 0 in that same cycle.""
  },
  ""Assertion 5"": {
    ""Assertion"": ""@(posedge clk) (nReg[0] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""nReg"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal used for synchronous operations in the UART receiver."",
      ""nReg"": ""The 3‐bit counter used to count the number of received data bits."",
      ""rxDoneTick"": ""The signal that indicates the completion of a data byte reception.""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""Evaluates whether the specified bit equals 0."",
      ""|=>"": ""Overlapping implication ensuring that if the antecedent holds at a clock edge, the consequent holds within the same cycle.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, if the least significant bit of the data bit counter is 0, then the rxDoneTick signal must be 0 in that same cycle.""
  },
  ""Assertion 6"": {
    ""Assertion"": ""@(posedge clk) (sTick == 0) |-> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""sTick"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal that synchronizes the operation of the UART reception logic."",
      ""sTick"": ""The tick signal generated for sampling during the UART reception; it indicates whether a sampling event is occurring."",
      ""rxDoneTick"": ""The output pulse that is raised when UART data reception is finished.""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""Checks for equality (in this case, ensuring the signal is 0)."",
      ""|->"": ""Non-overlapping implication; if the antecedent is true at the clock edge, the consequent must hold in the immediately following cycle.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, if the sampling tick (sTick) is 0, then in the next (non overlapping) cycle the rxDoneTick signal must be 0.""
  },
  ""Assertion 7"": {
    ""Assertion"": ""@(posedge clk) (sNext[0] == 0) |=> (rxDoneTick == 0)"",
    ""Signals"": [""clk"", ""sNext"", ""rxDoneTick""],
    ""Signal Explanations"": {
      ""clk"": ""The clock signal that triggers updates in the combinatorial and sequential parts of the design."",
      ""sNext"": ""The combinatorial next-value for the sampling counter (sReg), representing the upcoming value as determined by the FSM logic."",
      ""rxDoneTick"": ""The indicator signal that asserts when a UART reception sequence is completed.""
    },
    ""Logical Operators"": [""=="", ""|=>""],
    ""Logical Operators Explanation"": {
      ""=="": ""Verifies that the targeted bit equals 0."",
      ""|=>"": ""Overlapping implication; if the antecedent is true at the clock edge, then the consequent must be true in that same cycle.""
    },
    ""Assertion Explaination"": ""At every positive clock edge, if the least significant bit of the next sampling counter value is 0, then in that same cycle the rxDoneTick signal must be 0.""
  }
}"
"//////////////////////////////////////////////////////////////////
////
////
//// 	TOP I2C BLOCK to I2C Core
////
////
////
//// This file is part of the APB to I2C project
////
//// http://www.opencores.org/cores/apbi2c/
////
////
////
//// Description
////
//// Implementation of APB IP core according to
////
//// apbi2c_spec IP core specification document.
////
////
////
//// To Do: Things are right here but always all block can suffer changes
////
////
////
////
////
//// Author(s): - Felipe Fernandes Da Costa, fefe2560@gmail.com
////		  Ronal Dario Celaya ,rcelaya.dario@gmail.com
////
///////////////////////////////////////////////////////////////// 
////
////
//// Copyright (C) 2009 Authors and OPENCORES.ORG
////
////
////
//// This source file may be used and distributed without
////
//// restriction provided that this copyright statement is not
////
//// removed from the file and that any derivative work contains
//// the original copyright notice and the associated disclaimer.
////
////
//// This source file is free software; you can redistribute it
////
//// and/or modify it under the terms of the GNU Lesser General
////
//// Public License as published by the Free Software Foundation;
//// either version 2.1 of the License, or (at your option) any
////
//// later version.
////
////
////
//// This source is distributed in the hope that it will be
////
//// useful, but WITHOUT ANY WARRANTY; without even the implied
////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
////
//// PURPOSE. See the GNU Lesser General Public License for more
//// details.
////
////
////
//// You should have received a copy of the GNU Lesser General
////
//// Public License along with this source; if not, download it
////
//// from http://www.opencores.org/lgpl.shtml
////
////
///////////////////////////////////////////////////////////////////


`timescale 1ns/1ps //timescale 

module module_i2c#(
			//THIS IS USED ONLY LIKE PARAMETER TO BEM CONFIGURABLE
			parameter integer DWIDTH = 32,
			parameter integer AWIDTH = 14
		)
		(
		//I2C INTERFACE WITH ANOTHER BLOCKS
		 input PCLK,
		 input PRESETn,
		 
		//INTERFACE WITH FIFO TRANSMISSION
		 input fifo_tx_f_full,
		 input fifo_tx_f_empty,
		 input [DWIDTH-1:0] fifo_tx_data_out,

		//INTERFACE WITH FIFO RECEIVER
		 input fifo_rx_f_full,
		 input fifo_rx_f_empty,
		 output reg fifo_rx_wr_en,
		 output reg [DWIDTH-1:0] fifo_rx_data_in, 

		//INTERFACE WITH REGISTER CONFIGURATION
		 input [AWIDTH-1:0] DATA_CONFIG_REG,
 		 input [AWIDTH-1:0] TIMEOUT_TX,
		
		//INTERFACE TO APB AND READ FOR FIFO   
		 output reg fifo_tx_rd_en,
		 output   TX_EMPTY,
		 output   RX_EMPTY,
		 output ERROR,
		 output ENABLE_SDA,
		 output ENABLE_SCL,

		//I2C BI DIRETIONAL PORTS
		inout SDA,
		inout SCL
		 

		 );

//THIS IS USED TO GENERATE INTERRUPTIONS
assign TX_EMPTY = (fifo_tx_f_empty == 1'b1)? 1'b1:1'b0;
assign RX_EMPTY = (fifo_rx_f_empty == 1'b1)? 1'b1:1'b0;

	//THIS COUNT IS USED TO CONTROL DATA ACCROSS FSM	
	reg [1:0] count_tx;
	reg [1:0] count_rx;
	//CONTROL CLOCK AND COUNTER
	reg [11:0] count_send_data;
	reg [11:0] count_receive_data;
	reg [11:0] count_timeout;
	reg BR_CLK_O;
	reg SDA_OUT;

	reg BR_CLK_O_RX;
	reg SDA_OUT_RX;

	//RESPONSE USED TO HOLD SIGNAL TO ACK OR NACK
	reg RESPONSE;

//    PARAMETERS USED TO STATE MACHINE

localparam [5:0] IDLE = 6'd0, //IDLE

	   START = 6'd1,//START BIT

	     CONTROLIN_1 = 6'd2, //START BYTE
	     CONTROLIN_2 = 6'd3,
	     CONTROLIN_3 = 6'd4,
             CONTROLIN_4 = 6'd5,
	     CONTROLIN_5 = 6'd6,
	     CONTROLIN_6 = 6'd7,
             CONTROLIN_7 = 6'd8,
             CONTROLIN_8 = 6'd9, //END FIRST BYTE

	     RESPONSE_CIN =6'd10, //RESPONSE

	     ADDRESS_1 = 6'd11,//START BYTE
	     ADDRESS_2 = 6'd12,
	     ADDRESS_3 = 6'd13,
             ADDRESS_4 = 6'd14,
	     ADDRESS_5 = 6'd15,
	     ADDRESS_6 = 6'd16,
             ADDRESS_7 = 6'd17,
             ADDRESS_8 = 6'd18,//END FIRST BYTE

	     RESPONSE_ADDRESS =6'd19, //RESPONSE

	     DATA0_1 = 6'd20,//START BYTE
	     DATA0_2 = 6'd21,
	     DATA0_3 = 6'd22,
             DATA0_4 = 6'd23,
	     DATA0_5 = 6'd24,
	     DATA0_6 = 6'd25,
             DATA0_7 = 6'd26,
             DATA0_8 = 6'd27,//END FIRST BYTE

	     RESPONSE_DATA0_1 = 6'd28,  //RESPONSE
	   
	     DATA1_1 = 6'd29,//START BYTE
	     DATA1_2 = 6'd30,
	     DATA1_3 = 6'd31,
             DATA1_4 = 6'd32,
	     DATA1_5 = 6'd33,
	     DATA1_6 = 6'd34,
             DATA1_7 = 6'd35,
             DATA1_8 = 6'd36,//END FIRST BYTE

	     RESPONSE_DATA1_1 = 6'd37,//RESPONSE

	     DELAY_BYTES = 6'd38,//USED ONLY IN ACK TO DELAY BETWEEN
	     NACK = 6'd39,//USED ONLY IN ACK TO DELAY BETWEEN BYTES
	     STOP = 6'd40;//USED TO SEND STOP BIT

	//STATE CONTROL 
	reg [5:0] state_tx;
	reg [5:0] next_state_tx;

//ASSIGN REGISTERS TO BIDIRETIONAL PORTS
assign SDA =(DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b0 & state_tx != RESPONSE_CIN & state_tx != RESPONSE_ADDRESS & state_tx != RESPONSE_DATA0_1 & state_tx != RESPONSE_DATA1_1)?SDA_OUT:SDA_OUT_RX;


assign SCL = (DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b0)?BR_CLK_O:BR_CLK_O_RX;

//STANDARD ERROR
assign ERROR = (DATA_CONFIG_REG[0] == 1'b1 & DATA_CONFIG_REG[1] == 1'b1)?1'b1:1'b0;


//COMBINATIONAL BLOCK TO   
always@(*)
begin

	//THE FUN START HERE :-)
	//COMBINATIONAL UPDATE STATE BE CAREFUL WITH WHAT YOU MAKE HERE
	next_state_tx=state_tx;

	case(state_tx)//state_   IS MORE SECURE CHANGE ONLY IF YOU KNOW WHAT ARE YOU DOING 
	IDLE:
	begin
		//OBEYING SPEC
		if(DATA_CONFIG_REG[0] == 1'b0 && (fifo_tx_f_full == 1'b1 || fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b0)
		begin
			next_state_tx   = IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && (fifo_tx_f_full == 1'b1 || fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b1)
		begin
			next_state_tx   = IDLE;
		end
		else if(DATA_CONFIG_REG[0] == 1'b1 && ((fifo_tx_f_full == 1'b0 && fifo_tx_f_empty == 1'b0) || fifo_tx_f_full == 1'b1) && DATA_CONFIG_REG[1] == 1'b0 && count_timeout < TIMEOUT_TX)
		begin
			next_state_tx   = START;
		end


	end
	START://THIS IS USED TOO ALL STATE MACHINES THE COUNTER_SEND_DATA
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = START;
		end
		else
		begin
			next_state_tx   = CONTROLIN_1;
		end
		
	end
	CONTROLIN_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = CONTROLIN_1;
		end
		else
		begin
			next_state_tx  =  CONTROLIN_2;
		end

	end
	CONTROLIN_2:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = CONTROLIN_2;
		end
		else
		begin
			next_state_tx   = CONTROLIN_3;
		end

	end
	CONTROLIN_3:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  CONTROLIN_3;
		end
		else
		begin
			next_state_tx   = CONTROLIN_4;
		end		
	end
	CONTROLIN_4:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   = CONTROLIN_4;
		end
		else
		begin
			next_state_tx   = CONTROLIN_5;
		end		
	end
	CONTROLIN_5:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_5;
		end
		else
		begin
			next_state_tx = CONTROLIN_6;
		end		
	end
	CONTROLIN_6:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_6;
		end
		else
		begin
			next_state_tx = CONTROLIN_7;
		end		
	end
	CONTROLIN_7:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = CONTROLIN_7;
		end
		else
		begin
			next_state_tx = CONTROLIN_8;
		end		
	end
	CONTROLIN_8:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = CONTROLIN_8;
		end
		else 
		begin
			next_state_tx  = RESPONSE_CIN;
		end		
	end
	RESPONSE_CIN:
	begin

		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = RESPONSE_CIN;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx = DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx = NACK;
		end	
		
	end

	//NOW SENDING ADDRESS
	ADDRESS_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = ADDRESS_1;
		end
		else
		begin
			next_state_tx  =  ADDRESS_2;
		end	
	end
	ADDRESS_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_2;
		end
		else
		begin
			next_state_tx = ADDRESS_3;
		end	
	end
	ADDRESS_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_3;
		end
		else
		begin
			next_state_tx = ADDRESS_4;
		end	
	end
	ADDRESS_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_4;
		end
		else
		begin
			next_state_tx = ADDRESS_5;
		end	
	end
	ADDRESS_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_5;
		end
		else
		begin
			next_state_tx = ADDRESS_6;
		end	
	end
	ADDRESS_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_6;
		end
		else
		begin
			next_state_tx = ADDRESS_7;
		end	
	end
	ADDRESS_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_7;
		end
		else
		begin
			next_state_tx = ADDRESS_8;
		end	
	end
	ADDRESS_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = ADDRESS_8;
		end
		else
		begin
			next_state_tx = RESPONSE_ADDRESS;
		end	
	end
	RESPONSE_ADDRESS:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = RESPONSE_ADDRESS;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx = DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK --> RESTART CONDITION AND BACK TO START BYTE AGAIN
		begin
			next_state_tx = NACK;
		end	
	end
	
	//data in
	DATA0_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_1;
		end
		else
		begin
			next_state_tx = DATA0_2;
		end
	end
	DATA0_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_2;
		end
		else
		begin
			next_state_tx = DATA0_3;
		end
	end
	DATA0_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_3;
		end
		else
		begin
			next_state_tx = DATA0_4;
		end
	end
	DATA0_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_4;
		end
		else
		begin
			next_state_tx = DATA0_5;
		end
	end
	DATA0_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA0_5;
		end
		else
		begin
			next_state_tx   = DATA0_6;
		end
	end
	DATA0_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_6;
		end
		else
		begin
			next_state_tx  = DATA0_7;
		end
	end
	DATA0_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_7;
		end
		else
		begin
			next_state_tx  = DATA0_8;
		end
	end
	DATA0_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA0_8;
		end
		else
		begin
			next_state_tx  =  RESPONSE_DATA0_1;
		end
	end
	RESPONSE_DATA0_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  RESPONSE_DATA0_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx  =   DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx  =   NACK;
		end	
	end

	//second byte
	DATA1_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_1;
		end
		else
		begin
			next_state_tx  = DATA1_2;
		end
	end
	DATA1_2:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_2;
		end
		else
		begin
			next_state_tx = DATA1_3;
		end
	end
	DATA1_3:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_3;
		end
		else
		begin
			next_state_tx  =  DATA1_4;
		end
	end
	DATA1_4:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  = DATA1_4;
		end
		else
		begin
			next_state_tx  = DATA1_5;
		end
	end
	DATA1_5:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_5;
		end
		else
		begin
			next_state_tx = DATA1_6;
		end
	end
	DATA1_6:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx  =  DATA1_6;
		end
		else
		begin
			next_state_tx  =  DATA1_7;
		end
	end
	DATA1_7:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx =  DATA1_7;
		end
		else
		begin
			next_state_tx =  DATA1_8;
		end
	end
	DATA1_8:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = DATA1_8;
		end
		else
		begin
			next_state_tx = RESPONSE_DATA1_1;
		end
	end
	RESPONSE_DATA1_1:
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx   =  RESPONSE_DATA1_1;
		end
		else if(RESPONSE == 1'b0)//ACK
		begin 
			next_state_tx   =  DELAY_BYTES;
		end
		else if(RESPONSE == 1'b1)//NACK
		begin
			next_state_tx   =  NACK;
		end	
	end
	DELAY_BYTES://THIS FORM WORKS 
	begin

		
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx =  DELAY_BYTES;
		end
		else
		begin

			if(count_tx == 2'd0)
			begin
				next_state_tx = ADDRESS_1;
			end
			else if(count_tx   == 2'd1)
			begin
				next_state_tx = DATA0_1;
			end
			else if(count_tx   == 2'd2)
			begin
				next_state_tx = DATA1_1;
			end
			else if(count_tx   == 2'd3)
			begin
				next_state_tx = STOP;
			end
			
		end

	end
	NACK://NOT TESTED YET !!!!
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2]*2'd2)
		begin
			next_state_tx  = NACK;
		end
		else
		begin
			if(count_tx == 2'd0)
			begin
				next_state_tx = CONTROLIN_1;
			end
			else if(count_tx == 2'd1)
			begin
				next_state_tx = ADDRESS_1;
			end
			else if(count_tx  == 2'd2)
			begin
				next_state_tx   = DATA0_1;
			end
			else if(count_tx == 2'd3)
			begin
				next_state_tx = DATA1_1;
			end
		end
	end
	STOP://THIS WORK
	begin
		if(count_send_data != DATA_CONFIG_REG[13:2])
		begin
			next_state_tx = STOP;
		end
		else
		begin
			next_state_tx = IDLE;
		end
	end
	default:
	begin
		next_state_tx =  IDLE;
	end
	endcase


end



//SEQUENTIAL   
always@(posedge PCLK)
begin

	//RESET SYNC
	if(!PRESETn)
	begin
		//SIGNALS MUST BE RESETED
		count_send_data <= 12'd0;
		state_tx   <= IDLE;	
		SDA_OUT<= 1'b1;
		fifo_tx_rd_en <= 1'b0;
		count_tx   <= 2'd0;
		BR_CLK_O <= 1'b1;
		RESPONSE<= 1'b0;	
	end
	else
	begin
		
		// SEQUENTIAL FUN START
		state_tx  <= next_state_tx;

		case(state_tx)
		IDLE:
		begin

			fifo_tx_rd_en <= 1'b0;
			
 
			if(DATA_CONFIG_REG[0] == 1'b0 && (fifo_tx_f_full == 1'b1 ||fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b0)
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b1;
				BR_CLK_O <= 1'b1;
			end
			else if(DATA_CONFIG_REG[0] == 1'b1 && ((fifo_tx_f_empty == 1'b0 && fifo_tx_f_full == 1'b0 )|| fifo_tx_f_full == 1'b1 ) && DATA_CONFIG_REG[1] == 1'b0)
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=1'b0;			
			end
			else if(DATA_CONFIG_REG[0] == 1'b1 && (fifo_tx_f_full == 1'b1 ||fifo_tx_f_empty == 1'b0) && DATA_CONFIG_REG[1] == 1'b1)
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b1;
				BR_CLK_O <= 1'b1;
			end			

		end
		START:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				BR_CLK_O <= 1'b0;
			end
			else
			begin
				count_send_data <= 12'd0;					
			end	

			if(count_send_data == DATA_CONFIG_REG[13:2]- 12'd1)
			begin
				SDA_OUT<=fifo_tx_data_out[0:0];
				count_tx   <= 2'd0;
			end

		end
		CONTROLIN_1:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[0:0];	

								
				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[1:1];
			end

				
		end
		
		CONTROLIN_2:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[1:1];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[2:2];
			end
				
		end

		CONTROLIN_3:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[2:2];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[3:3];
			end	


				
		end
		CONTROLIN_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[3:3];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[4:4];
			end
				
		end

		CONTROLIN_5:
		begin

			

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[4:4];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[5:5];
			end	

		end
		CONTROLIN_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[5:5];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[6:6];
			end	

				
		end

		CONTROLIN_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[6:6];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end	
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[7:7];
			end	

				
		end
		CONTROLIN_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[7:7];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<= 1'b0;
			end

				
		end
		RESPONSE_CIN:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
			end	


		end
		ADDRESS_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[8:8];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[9:9];
			end	
				
		end		
		ADDRESS_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[9:9];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[10:10];
			end	

		end
		ADDRESS_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[10:10];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[11:11];
			end	

		end
		ADDRESS_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[11:11];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[12:12];
			end	
		end
		ADDRESS_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[12:12];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[13:13];
			end	

				
		end
		ADDRESS_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[13:13];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;		
				SDA_OUT<=fifo_tx_data_out[14:14];
			end	
				
		end
		ADDRESS_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[14:14];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[15:15];
			end	

				
		end
		ADDRESS_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[15:15];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_ADDRESS:
		begin
			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
			end

		end
		DATA0_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[16:16];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;				
				SDA_OUT<=fifo_tx_data_out[17:17];
			end	

				
		end
		DATA0_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[17:17];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[18:18];
			end	

				
		end		
		DATA0_3:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[18:18];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[19:19];
			end	
				
		end
		DATA0_4:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[19:19];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[20:20];
			end	
				
		end
		DATA0_5:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[20:20];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[21:21];
			end

		end
		DATA0_6:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[21:21];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end			
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[22:22];
			end
				
		end
		DATA0_7:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[22:22];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[23:23];
			end	
				
		end
		DATA0_8:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[23:23];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end		

			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=1'b0;
			end	
				
		end
		RESPONSE_DATA0_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;

				//LETS TRY USE THIS BUT I DONT THINK IF WORKS  
				RESPONSE<= SDA;

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
			end

		end
		DATA1_1:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[24:24];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK_O <= 1'b1;
				end
				else
				begin
					BR_CLK_O <= 1'b0;
				end				
			end
			else
			begin
				count_send_data <= 12'd0;
				SDA_OUT<=fifo_tx_data_out[25:25];

			end

				
		end
		DATA1_2:
		begin

			if(count_send_data < DATA_CONFIG_REG[13:2])
			begin
				count_send_data <= count_send_data + 12'd1;
				SDA_OUT<=fifo_tx_data_out[25:25];

				if(count_send_data < DATA_CONFIG_REG[13:2]/12'd4)
				begin
					BR_CLK_O <= 1'b0;
				end
				else if(count_send_data >= DATA_CONFIG_REG[13:2]/12'd4 && count_send_data < (DATA_CONFIG_REG[13:2]-(DATA_CONFIG_REG[13:2]/12'd4))-12'd1)
				begin
					BR_CLK","
module module_i2c_sva(PCLK,PRESETn,fifo_tx_f_full,fifo_tx_f_empty,fifo_tx_data_out,fifo_rx_data_in,fifo_rx_f_full,fifo_rx_f_empty,fifo_rx_wr_en,
fifo_tx_rd_en,RX_EMPTY,TX_EMPTY,ERROR,ENABLE_SCL,ENABLE_SDA,SDA,SCL,DATA_CONFIG_REG,TIMEOUT_TX,state_tx,count_receive_data,RESPONSE,SDA_OUT,count_timeout,count_send_data,next_state_rx,BR_CLK_O,next_state_tx, count_tx,count_rx,BR_CLK_O_RX,SDA_OUT_RX,state_rx);

input PCLK;
input PRESETn;

//INTERFACE WITH FIFO TRANSMISSION
input fifo_tx_f_full;
input fifo_tx_f_empty;
input [32-1:0] fifo_tx_data_out;

//INTERFACE WITH FIFO RECEIVER
input fifo_rx_f_full;
input fifo_rx_f_empty;
input fifo_rx_wr_en;
input [32-1:0] fifo_rx_data_in; 

//INTERFACE WITH REGISTER CONFIGURATION
input [14-1:0] DATA_CONFIG_REG;
input [14-1:0] TIMEOUT_TX;

//INTERFACE TO APB AND READ FOR FIFO   
input fifo_tx_rd_en;
input   TX_EMPTY;
input   RX_EMPTY;
input ERROR;
input ENABLE_SDA;
input ENABLE_SCL;


//I2C BI DIRETIONAL PORTS
input SDA;
input SCL;
//registers
input state_tx;
input state_rx;
input count_receive_data;
input SDA_OUT;
input RESPONSE;
input count_timeout;
input count_send_data;
input next_state_rx;
input BR_CLK_O;
input next_state_tx;
input SDA_OUT_RX;
input count_tx;
input count_rx;
input BR_CLK_O_RX;

property a1;
@(posedge PCLK) (fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1);
endproperty
assert_a1: assert property(a1);

property a0;
@(posedge PCLK) (fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0);
endproperty
assert_a0: assert property(a0);

property a3;
@(posedge PCLK) (fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1);
endproperty
assert_a3: assert property(a3);

property a2;
@(posedge PCLK) (fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0);
endproperty
assert_a2: assert property(a2);

property a5;
@(posedge PCLK) (DATA_CONFIG_REG[1] == 0) |-> (ERROR == 0);
endproperty
assert_a5: assert property(a5);

property a4;
@(posedge PCLK) (DATA_CONFIG_REG[0] == 0) |-> (ERROR == 0);
endproperty
assert_a4: assert property(a4);

property a6;
@(posedge PCLK) (DATA_CONFIG_REG[0] == 1 & DATA_CONFIG_REG[1] == 1) |-> (ERROR == 1);
endproperty
assert_a6: assert property(a6);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/NIPS_2024/Jasper_llama_results/communication_controller_apb_to_i2c/module_i2c/FPV_module_i2c.tcl,"{
  ""Assertion 1"": {
    ""Assertion"": ""assert property((fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1));"",
    ""Signals"": [""fifo_rx_f_empty"", ""RX_EMPTY""],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""FIFO receiver empty flag indicating that the receiver FIFO has no data"",
      ""RX_EMPTY"": ""Output signal reflecting the empty state of the receiver FIFO""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|->"": ""non-overlapping implication: if the antecedent is true at a clock edge, then the consequent must hold in the related cycle""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if fifo_rx_f_empty is equal to 1 then RX_EMPTY must be equal to 1.""
  },
  ""Assertion 2"": {
    ""Assertion"": ""assert property((fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0));"",
    ""Signals"": [""fifo_rx_f_empty"", ""RX_EMPTY""],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""FIFO receiver empty flag indicating that the receiver FIFO has no data"",
      ""RX_EMPTY"": ""Output signal reflecting the empty state of the receiver FIFO""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|->"": ""non-overlapping implication: if the antecedent is true at a clock edge, then the consequent must hold in the related cycle""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if fifo_rx_f_empty is equal to 0 then RX_EMPTY must be equal to 0.""
  },
  ""Assertion 3"": {
    ""Assertion"": ""assert property((fifo_rx_f_empty == 1) |-> (RX_EMPTY == 1));"",
    ""Signals"": [""fifo_rx_f_empty"", ""RX_EMPTY""],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""FIFO receiver empty flag indicating that the receiver FIFO has no data"",
      ""RX_EMPTY"": ""Output signal reflecting the empty state of the receiver FIFO""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|->"": ""non-overlapping implication: if the antecedent is true at a clock edge, then the consequent must follow""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if fifo_rx_f_empty is equal to 1 then RX_EMPTY must be equal to 1.""
  },
  ""Assertion 4"": {
    ""Assertion"": ""assert property((fifo_rx_f_empty == 0) |-> (RX_EMPTY == 0));"",
    ""Signals"": [""fifo_rx_f_empty"", ""RX_EMPTY""],
    ""Signal Explanations"": {
      ""fifo_rx_f_empty"": ""FIFO receiver empty flag indicating that the receiver FIFO has no data"",
      ""RX_EMPTY"": ""Output signal reflecting the empty state of the receiver FIFO""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|->"": ""non-overlapping implication: if the antecedent is true at a clock edge, then the consequent must follow""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if fifo_rx_f_empty is equal to 0 then RX_EMPTY must be equal to 0.""
  },
  ""Assertion 5"": {
    ""Assertion"": ""assert property((DATA_CONFIG_REG[1] == 0) |-> (ERROR == 0));"",
    ""Signals"": [""DATA_CONFIG_REG[1]"", ""ERROR""],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[1]"": ""Second bit of the configuration register used to set operating modes"",
      ""ERROR"": ""Error flag output of the module""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|->"": ""non-overlapping implication that links the antecedent to the consequent across clock cycles""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if the second bit of DATA_CONFIG_REG is equal to 0 then ERROR must be equal to 0.""
  },
  ""Assertion 6"": {
    ""Assertion"": ""assert property((DATA_CONFIG_REG[0] == 0) |-> (ERROR == 0));"",
    ""Signals"": [""DATA_CONFIG_REG[0]"", ""ERROR""],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[0]"": ""First bit of the configuration register used to set operating modes"",
      ""ERROR"": ""Error flag output of the module""
    },
    ""Logical Operators"": [""=="", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""|->"": ""non-overlapping implication indicating that if the antecedent holds then the consequent must hold""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if the first bit of DATA_CONFIG_REG is equal to 0 then ERROR must be equal to 0.""
  },
  ""Assertion 7"": {
    ""Assertion"": ""assert property((DATA_CONFIG_REG[0] == 1 & DATA_CONFIG_REG[1] == 1) |-> (ERROR == 1));"",
    ""Signals"": [""DATA_CONFIG_REG[0]"", ""DATA_CONFIG_REG[1]"", ""ERROR""],
    ""Signal Explanations"": {
      ""DATA_CONFIG_REG[0]"": ""First bit of the configuration register used to set operating modes"",
      ""DATA_CONFIG_REG[1]"": ""Second bit of the configuration register used to set operating modes"",
      ""ERROR"": ""Error flag output of the module""
    },
    ""Logical Operators"": [""=="", ""&"", ""|->""],
    ""Logical Operators Explanation"": {
      ""=="": ""checks for equality"",
      ""&"": ""logical AND operator ensuring both conditions must be true"",
      ""|->"": ""non-overlapping implication indicating that if the antecedent holds then the consequent must follow""
    },
    ""Assertion Explaination"": ""On every rising edge of PCLK, if both the first and second bits of DATA_CONFIG_REG are equal to 1 then ERROR must be equal to 1.""
  }
}"
"//////////////////////////////////////////////////////////////////////
////                                                              ////
////  eth_rxstatem.v                                              ////
////                                                              ////
////  This file is part of the Ethernet IP core project           ////
////  http://www.opencores.org/project,ethmac                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Igor Mohor (igorM@opencores.org)                      ////
////      - Novan Hartadi (novan@vlsi.itb.ac.id)                  ////
////      - Mahmud Galela (mgalela@vlsi.itb.ac.id)                ////
////                                                              ////
////  All additional information is avaliable in the Readme.txt   ////
////  file.                                                       ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2001 Authors                                   ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: not supported by cvs2svn $
// Revision 1.5  2002/01/23 10:28:16  mohor
// Link in the header changed.
//
// Revision 1.4  2001/10/19 08:43:51  mohor
// eth_timescale.v changed to timescale.v This is done because of the
// simulation of the few cores in a one joined project.
//
// Revision 1.3  2001/10/18 12:07:11  mohor
// Status signals changed, Adress decoding changed, interrupt controller
// added.
//
// Revision 1.2  2001/09/11 14:17:00  mohor
// Few little NCSIM warnings fixed.
//
// Revision 1.1  2001/08/06 14:44:29  mohor
// A define FPGA added to select between Artisan RAM (for ASIC) and Block Ram (For Virtex).
// Include files fixed to contain no path.
// File names and module names changed ta have a eth_ prologue in the name.
// File eth_timescale.v is used to define timescale
// All pin names on the top module are changed to contain _I, _O or _OE at the end.
// Bidirectional signal MDIO is changed to three signals (Mdc_O, Mdi_I, Mdo_O
// and Mdo_OE. The bidirectional signal must be created on the top level. This
// is done due to the ASIC tools.
//
// Revision 1.1  2001/07/30 21:23:42  mohor
// Directory structure changed. Files checked and joind together.
//
// Revision 1.2  2001/07/03 12:55:41  mohor
// Minor changes because of the synthesys warnings.
//
//
// Revision 1.1  2001/06/27 21:26:19  mohor
// Initial release of the RxEthMAC module.
//
//
//
//

module eth_rxstatem (MRxClk, Reset, MRxDV, ByteCntEq0, ByteCntGreat2, Transmitting, MRxDEq5, MRxDEqD, 
                     IFGCounterEq24, ByteCntMaxFrame, StateData, StateIdle, StatePreamble, StateSFD, 
                     StateDrop
                    );

input         MRxClk;
input         Reset;
input         MRxDV;
input         ByteCntEq0;
input         ByteCntGreat2;
input         MRxDEq5;
input         Transmitting;
input         MRxDEqD;
input         IFGCounterEq24;
input         ByteCntMaxFrame;

output [1:0]  StateData;
output        StateIdle;
output        StateDrop;
output        StatePreamble;
output        StateSFD;

reg           StateData0;
reg           StateData1;
reg           StateIdle;
reg           StateDrop;
reg           StatePreamble;
reg           StateSFD;

wire          StartIdle;
wire          StartDrop;
wire          StartData0;
wire          StartData1;
wire          StartPreamble;
wire          StartSFD;


// Defining the next state
assign StartIdle = ~MRxDV & (StateDrop | StatePreamble | StateSFD | (|StateData));

assign StartPreamble = MRxDV & ~MRxDEq5 & (StateIdle & ~Transmitting);

assign StartSFD = MRxDV & MRxDEq5 & (StateIdle & ~Transmitting | StatePreamble);

assign StartData0 = MRxDV & (StateSFD & MRxDEqD & IFGCounterEq24 | StateData1);

assign StartData1 = MRxDV & StateData0 & (~ByteCntMaxFrame);

assign StartDrop = MRxDV & (StateIdle & Transmitting | StateSFD & ~IFGCounterEq24 &
                   MRxDEqD |  StateData0 &  ByteCntMaxFrame);

// Rx State Machine
always @ (posedge MRxClk or posedge Reset)
begin
  if(Reset)
    begin
      StateIdle     <=  1'b0;
      StateDrop     <=  1'b1;
      StatePreamble <=  1'b0;
      StateSFD      <=  1'b0;
      StateData0    <=  1'b0;
      StateData1    <=  1'b0;
    end
  else
    begin
      if(StartPreamble | StartSFD | StartDrop)
        StateIdle <=  1'b0;
      else
      if(StartIdle)
        StateIdle <=  1'b1;

      if(StartIdle)
        StateDrop <=  1'b0;
      else
      if(StartDrop)
        StateDrop <=  1'b1;

      if(StartSFD | StartIdle | StartDrop)
        StatePreamble <=  1'b0;
      else
      if(StartPreamble)
        StatePreamble <=  1'b1;

      if(StartPreamble | StartIdle | StartData0 | StartDrop)
        StateSFD <=  1'b0;
      else
      if(StartSFD)
        StateSFD <=  1'b1;

      if(StartIdle | StartData1 | StartDrop)
        StateData0 <=  1'b0;
      else
      if(StartData0)
        StateData0 <=  1'b1;

      if(StartIdle | StartData0 | StartDrop)
        StateData1 <=  1'b0;
      else
      if(StartData1)
        StateData1 <=  1'b1;
    end
end

assign StateData[1:0] = {StateData1, StateData0};

endmodule","
module eth_rxstate_sva(
input         MRxDV,
input        StateDrop,
input         MRxDEqD,
input          StartPreamble,
input         ByteCntMaxFrame,
input           StateData0,
input           StateData1,
input          StartData1,
input         ByteCntGreat2,
input [1:0]  StateData,
input         MRxDEq5,
input         MRxClk,
input           StatePreamble,
input        StateIdle,
input          StartSFD,
input         Transmitting,
input         IFGCounterEq24,
input         ByteCntEq0,
input        StateSFD,
input          StartDrop,
input         Reset,
input          StartData0,
input          StartIdle
);


property a7;
@(posedge MRxClk) (StartPreamble == 1) |=> (StatePreamble == 1);
endproperty
assert_a7: assert property(a7);

property a0;
@(posedge MRxClk) (StartDrop == 1) |=> (StatePreamble == 0);
endproperty
assert_a0: assert property(a0);

property a6;
@(posedge MRxClk) (StateSFD == 1) |=> (StatePreamble == 0);
endproperty
assert_a6: assert property(a6);

property a3;
@(posedge MRxClk) (StateData[0] == 1) |=> (StatePreamble == 0);
endproperty
assert_a3: assert property(a3);

property a2;
@(posedge MRxClk) (StateDrop == 1) |=> (StatePreamble == 0);
endproperty
assert_a2: assert property(a2);

property a5;
@(posedge MRxClk) (StateData1 == 1) |=> (StatePreamble == 0);
endproperty
assert_a5: assert property(a5);

property a8;
@(posedge MRxClk) (StatePreamble == 1 & MRxDEq5 == 0 & MRxDV == 1) |=> (StatePreamble == 1);
endproperty
assert_a8: assert property(a8);

property a1;
@(posedge MRxClk) (MRxDEq5 == 1) |=> (StatePreamble == 0);
endproperty
assert_a1: assert property(a1);

property a4;
@(posedge MRxClk) (MRxDV == 0) |=> (StatePreamble == 0);
endproperty
assert_a4: assert property(a4);


property a17;
@(posedge MRxClk) (StartSFD == 1) |=> (StateSFD == 1);
endproperty
assert_a17: assert property(a17);

property a14;
@(posedge MRxClk) (StartIdle == 1) |=> (StateSFD == 0);
endproperty
assert_a14: assert property(a14);

property a9;
@(posedge MRxClk) (StartDrop == 1) |=> (StateSFD == 0);
endproperty
assert_a9: assert property(a9);

property a12;
@(posedge MRxClk) (StartData0 == 1) |=> (StateSFD == 0);
endproperty
assert_a12: assert property(a12);

property a10;
@(posedge MRxClk) (StartPreamble == 1) |=> (StateSFD == 0);
endproperty
assert_a10: assert property(a10);

property a18;
@(posedge MRxClk) (StateSFD == 1 & StartIdle == 0 & MRxDEqD == 0) |=> (StateSFD == 1);
endproperty
assert_a18: assert property(a18);

property a11;
@(posedge MRxClk) (StateData[0] == 1) |=> (StateSFD == 0);
endproperty
assert_a11: assert property(a11);

property a13;
@(posedge MRxClk) (StateDrop == 1) |=> (StateSFD == 0);
endproperty
assert_a13: assert property(a13);

property a16;
@(posedge MRxClk) (MRxDEq5 == 0 & StatePreamble == 1) |=> (StateSFD == 0);
endproperty
assert_a16: assert property(a16);

property a15;
@(posedge MRxClk) (MRxDV == 0) |=> (StateSFD == 0);
endproperty
assert_a15: assert property(a15);

property a20;
@(posedge MRxClk) (StartIdle == 1) |=> (StateDrop == 0);
endproperty
assert_a20: assert property(a20);

property a26;
@(posedge MRxClk) (StartDrop == 1) |=> (StateDrop == 1);
endproperty
assert_a26: assert property(a26);

property a27;
@(posedge MRxClk) (StateDrop == 1 & StartIdle == 0) |=> (StateDrop == 1);
endproperty
assert_a27: assert property(a27);

property a23;
@(posedge MRxClk) (StateSFD == 1 & StartDrop == 0) |=> (StateDrop == 0);
endproperty
assert_a23: assert property(a23);

property a24;
@(posedge MRxClk) (StateData[0] == 1 & StartDrop == 0) |=> (StateDrop == 0);
endproperty
assert_a24: assert property(a24);

property a28;
@(posedge MRxClk) (StatePreamble == 1) |=> (StateDrop == 0);
endproperty
assert_a28: assert property(a28);

property a21;
@(posedge MRxClk) (StateData1 == 1) |=> (StateDrop == 0);
endproperty
assert_a21: assert property(a21);

property a22;
@(posedge MRxClk) (MRxDV == 0) |=> (StateDrop == 0);
endproperty
assert_a22: assert property(a22);

property a25;
@(posedge MRxClk) (Transmitting == 0 & StateIdle == 1) |=> (StateDrop == 0);
endproperty
assert_a25: assert property(a25);

property a33;
@(posedge MRxClk) (StartIdle == 1) |=> (StateIdle == 1);
endproperty
assert_a33: assert property(a33);

property a29;
@(posedge MRxClk) (StartDrop == 1) |=> (StateIdle == 0);
endproperty
assert_a29: assert property(a29);

property a30;
@(posedge MRxClk) (StartSFD == 1) |=> (StateIdle == 0);
endproperty
assert_a30: assert property(a30);

property a31;
@(posedge MRxClk) (StartPreamble == 1) |=> (StateIdle == 0);
endproperty
assert_a31: assert property(a31);

property a32;
@(posedge MRxClk) (MRxDV == 1) |=> (StateIdle == 0);
endproperty
assert_a32: assert property(a32);

property a34;
@(posedge MRxClk) (MRxDV == 0) |=> (StateIdle == 1);
endproperty
assert_a34: assert property(a34);

endmodule",https://github.com/achieve-lab/assertion_data_for_LLM/blob/66da64e4274e8571ffcdd9d6645ed898a1a23f83/Jasper_results/communication_controller_100_mb-s_ethernet_mac_layer_switch/eth_rxstatem/FPV_eth_rxstatem.tcl,"{
""Assertion 1"": {
""Assertion"": ""@(posedge MRxClk) (StartPreamble == 1) |=> (StatePreamble == 1);"",
""Signals"": [""MRxClk"", ""StartPreamble"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock signal that clocks the state machine."",
  ""StartPreamble"": ""A control signal that initiates a transition into the preamble state."",
  ""StatePreamble"": ""An internal state flag indicating that the receiver is currently processing the preamble.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Tests if two values are equal."",
  ""|=>"": ""If the antecedent condition is true at a clock edge, then the consequent condition must be true in the next cycle.""
},
""Assertion Explaination"": ""On the rising edge of MRxClk, if StartPreamble equals 1 then in the next cycle the state machine must have StatePreamble equal to 1 (i.e. the preamble state is entered).""
},
""Assertion 2"": {
""Assertion"": ""@(posedge MRxClk) (StartDrop == 1) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""StartDrop"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the receive logic."",
  ""StartDrop"": ""A control signal that initiates a transition into the drop state."",
  ""StatePreamble"": ""A flag indicating that the receiver is in the preamble state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks for equality between a signal and a value."",
  ""|=>"": ""Specifies that if the left-hand condition holds at a clock edge, then the right-hand condition must hold in the subsequent cycle.""
},
""Assertion Explaination"": ""At each rising edge of MRxClk, if StartDrop is asserted (1), then the preamble state (StatePreamble) must be 0, ensuring that entering the drop state disables the preamble state.""
},
""Assertion 3"": {
""Assertion"": ""@(posedge MRxClk) (StateSFD == 1) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""StateSFD"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock signal."",
  ""StateSFD"": ""An internal state flag indicating that the state machine is in the Start Frame Delimiter (SFD) state."",
  ""StatePreamble"": ""An internal state flag showing that the state machine is in the preamble state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Compares a signal value to a specified value."",
  ""|=>"": ""Indicates that if the antecedent is true at a clock edge, then the consequent must be true in the following cycle.""
},
""Assertion Explaination"": ""When, on a rising edge of MRxClk, the state machine is in the SFD state (StateSFD equals 1), it must not be in the preamble state (StatePreamble equals 0).""
},
""Assertion 4"": {
""Assertion"": ""@(posedge MRxClk) (StateData[0] == 1) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""StateData[0]"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal used for synchronizing the state machine."",
  ""StateData[0]"": ""The lower bit of the two-bit data state, indicating an active data reception state."",
  ""StatePreamble"": ""The state flag indicating that the preamble is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Verifies that a signal matches a specified value."",
  ""|=>"": ""Specifies an implication such that if the antecedent is true at a clock edge, the consequent will be true in the next cycle.""
},
""Assertion Explaination"": ""At each rising clock edge, if the lower bit of the data state (StateData[0]) is 1 then the preamble state must not be active (StatePreamble equals 0).""
},
""Assertion 5"": {
""Assertion"": ""@(posedge MRxClk) (StateDrop == 1) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""StateDrop"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock that synchronizes the state transitions."",
  ""StateDrop"": ""An internal flag indicating that the state machine has transitioned to the drop state."",
  ""StatePreamble"": ""A flag showing whether the state machine is in the preamble state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks if the specified signal equals a given value."",
  ""|=>"": ""Implies that if the left-hand side condition is met at a clock edge, the right-hand side condition must be met in the next cycle.""
},
""Assertion Explaination"": ""On the rising edge of MRxClk, if the drop state (StateDrop) is active then the preamble state must be deactivated (StatePreamble equals 0).""
},
""Assertion 6"": {
""Assertion"": ""@(posedge MRxClk) (StateData1 == 1) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""StateData1"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the receive logic."",
  ""StateData1"": ""The upper bit of the two-bit data state, indicating a phase of data reception."",
  ""StatePreamble"": ""The state indicator for when the preamble is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Determines if two values are equal."",
  ""|=>"": ""Specifies an implication; if the antecedent holds at a clock edge, then the consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""At every rising edge of MRxClk, if StateData1 is asserted (1) then the preamble state (StatePreamble) must be inactive (0).""
},
""Assertion 7"": {
""Assertion"": ""@(posedge MRxClk) (StatePreamble == 1 & MRxDEq5 == 0 & MRxDV == 1) |=> (StatePreamble == 1);"",
""Signals"": [""MRxClk"", ""StatePreamble"", ""MRxDEq5"", ""MRxDV""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal driving the state machine."",
  ""StatePreamble"": ""An indicator that the state machine is currently in the preamble state."",
  ""MRxDEq5"": ""A signal that is high when the received data equals the value 5, used in preamble detection."",
  ""MRxDV"": ""A flag indicating that the receiver data is valid.""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Verifies equality between a signal and a constant."",
  ""&"": ""Logical AND, used here to combine multiple conditions."",
  ""|=>"": ""Implies that if the combined antecedent condition holds at a clock edge, then the consequent must hold in the following cycle.""
},
""Assertion Explaination"": ""At a rising edge of MRxClk, if the state machine is in the preamble state (StatePreamble equals 1), the received data does not equal 5 (MRxDEq5 equals 0), and data is valid (MRxDV equals 1), then the state machine must remain in the preamble state (StatePreamble remains 1).""
},
""Assertion 8"": {
""Assertion"": ""@(posedge MRxClk) (MRxDEq5 == 1) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""MRxDEq5"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the state transitions."",
  ""MRxDEq5"": ""A signal indicating that the current received data equals 5, which is significant for state decisions."",
  ""StatePreamble"": ""A flag that shows whether the preamble state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks if a signal is equal to a given value."",
  ""|=>"": ""Denotes that if the condition on the left is true at a clock edge, then the condition on the right must be true in the next cycle.""
},
""Assertion Explaination"": ""At the rising edge of MRxClk, if MRxDEq5 is 1 then the preamble state must be turned off (StatePreamble equals 0).""
},
""Assertion 9"": {
""Assertion"": ""@(posedge MRxClk) (MRxDV == 0) |=> (StatePreamble == 0);"",
""Signals"": [""MRxClk"", ""MRxDV"", ""StatePreamble""],
""Signal Explanations"": {
  ""MRxClk"": ""The receiver clock signal."",
  ""MRxDV"": ""The data valid signal that indicates if the receiver is currently processing data."",
  ""StatePreamble"": ""An internal indicator showing if the receiver is in the preamble state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Used to compare a signal against a value."",
  ""|=>"": ""Specifies that if the left-hand side condition holds at a clock edge, then the right-hand side condition will hold in the subsequent cycle.""
},
""Assertion Explaination"": ""At each rising edge of MRxClk, if the data valid signal MRxDV is 0 then the preamble state must be deasserted (StatePreamble equals 0).""
},
""Assertion 10"": {
""Assertion"": ""@(posedge MRxClk) (StartSFD == 1) |=> (StateSFD == 1);"",
""Signals"": [""MRxClk"", ""StartSFD"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal that synchronizes the state machine."",
  ""StartSFD"": ""A control signal that triggers the transition into the Start Frame Delimiter (SFD) state."",
  ""StateSFD"": ""An internal flag that indicates the SFD state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks whether the value of a signal equals a given constant."",
  ""|=>"": ""Implies that if the antecedent holds at a clock edge, then the consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""When a rising edge occurs on MRxClk, if the signal StartSFD is asserted, then in the following cycle the state machine must enter the SFD state (StateSFD becomes 1).""
},
""Assertion 11"": {
""Assertion"": ""@(posedge MRxClk) (StartIdle == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""StartIdle"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock used to time the state transitions."",
  ""StartIdle"": ""A control signal used to initiate the idle state."",
  ""StateSFD"": ""An internal flag that indicates if the state machine is in the SFD state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Determines equality between a signal and a value."",
  ""|=>"": ""Specifies that if the antecedent condition is met at a clock edge, then the consequent must be true in the subsequent cycle.""
},
""Assertion Explaination"": ""At every rising edge of MRxClk, if StartIdle is asserted then the SFD state must be turned off (StateSFD equals 0).""
},
""Assertion 12"": {
""Assertion"": ""@(posedge MRxClk) (StartDrop == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""StartDrop"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal driving the state machine."",
  ""StartDrop"": ""A signal that triggers a transition into the drop state."",
  ""StateSFD"": ""The flag indicating whether the SFD state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks if a given signal is equal to a specified value."",
  ""|=>"": ""Indicates that if the left-hand side is true at a clock edge, then the right-hand side must be true in the next cycle.""
},
""Assertion Explaination"": ""On the rising edge of MRxClk, if StartDrop is asserted then the SFD state must be deactivated (StateSFD becomes 0).""
},
""Assertion 13"": {
""Assertion"": ""@(posedge MRxClk) (StartData0 == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""StartData0"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal that drives the state machine."",
  ""StartData0"": ""A control signal that initiates the transition into the first phase of data reception (data state bit 0)."",
  ""StateSFD"": ""An internal flag indicating whether the SFD state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Tests for equality between operands."",
  ""|=>"": ""Means that if the antecedent condition holds at a clock edge, then the consequent must hold in the next clock cycle.""
},
""Assertion Explaination"": ""At each rising edge of MRxClk, if StartData0 is high then the SFD state must be deactivated (StateSFD equals 0).""
},
""Assertion 14"": {
""Assertion"": ""@(posedge MRxClk) (StartPreamble == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""StartPreamble"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock used for state synchronization."",
  ""StartPreamble"": ""A signal that initiates the preamble state."",
  ""StateSFD"": ""An indicator of whether the SFD state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Determines if a signal equals a designated value."",
  ""|=>"": ""Specifies an implication such that if the antecedent is true at the clock edge, the consequent will be true in the next cycle.""
},
""Assertion Explaination"": ""At the rising edge of MRxClk, if StartPreamble is asserted then the SFD state must be off (StateSFD equals 0).""
},
""Assertion 15"": {
""Assertion"": ""@(posedge MRxClk) (StateSFD == 1 & StartIdle == 0 & MRxDEqD == 0) |=> (StateSFD == 1);"",
""Signals"": [""MRxClk"", ""StateSFD"", ""StartIdle"", ""MRxDEqD""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the system."",
  ""StateSFD"": ""A flag indicating that the state machine is in the SFD state."",
  ""StartIdle"": ""A signal indicating the initiation of an idle state."",
  ""MRxDEqD"": ""A signal that is high when the received data equals the SFD marker (typically 'D').""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks equality between a signal and a value."",
  ""&"": ""Logical AND to combine multiple conditions."",
  ""|=>"": ""Denotes that if the combined antecedent is true at a clock edge, then the consequent must be true in the next cycle.""
},
""Assertion Explaination"": ""At a rising edge of MRxClk, if the SFD state is active, there is no request to enter idle (StartIdle is 0), and the received data does not indicate SFD (MRxDEqD equals 0), then the SFD state must persist (remain 1) in the next cycle.""
},
""Assertion 16"": {
""Assertion"": ""@(posedge MRxClk) (StateData[0] == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""StateData[0]"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock signal for the state transitions."",
  ""StateData[0]"": ""The lower bit of the data state indicating active data acceptance."",
  ""StateSFD"": ""The indicator flag for the SFD state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks if a signal matches a specified value."",
  ""|=>"": ""Implies that if the antecedent condition is met at a clock edge, then the consequent will follow in the next cycle.""
},
""Assertion Explaination"": ""At every rising clock edge, if the lower bit of the data state (StateData[0]) is asserted then the SFD state must not be active (StateSFD equals 0).""
},
""Assertion 17"": {
""Assertion"": ""@(posedge MRxClk) (StateDrop == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""StateDrop"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The synchronization clock for the state machine."",
  ""StateDrop"": ""An internal flag that indicates the state machine is in the drop state."",
  ""StateSFD"": ""A flag indicating whether the SFD state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks equality between operands."",
  ""|=>"": ""Indicates that if the left-hand condition holds at a clock edge, then the right-hand condition must hold in the next cycle.""
},
""Assertion Explaination"": ""On the rising edge of MRxClk, if the state machine is in the drop state (StateDrop equals 1), then it must not be in the SFD state (StateSFD equals 0).""
},
""Assertion 18"": {
""Assertion"": ""@(posedge MRxClk) (MRxDEq5 == 0 & StatePreamble == 1) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""MRxDEq5"", ""StatePreamble"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the state machine."",
  ""MRxDEq5"": ""A signal that indicates when the received data equals 5."",
  ""StatePreamble"": ""The flag indicating whether the preamble state is active."",
  ""StateSFD"": ""The flag that indicates if the SFD state is active.""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Tests if a signal is equal to a constant."",
  ""&"": ""Logical AND used to combine multiple conditions."",
  ""|=>"": ""Implies that if the combined conditions hold at the clock edge, then the specified consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""At the rising edge of MRxClk, if MRxDEq5 is 0 and the state machine is in the preamble state, then the SFD state must remain deasserted (StateSFD equals 0).""
},
""Assertion 19"": {
""Assertion"": ""@(posedge MRxClk) (MRxDV == 0) |=> (StateSFD == 0);"",
""Signals"": [""MRxClk"", ""MRxDV"", ""StateSFD""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the module."",
  ""MRxDV"": ""The receiver data valid signal indicating whether data is present."",
  ""StateSFD"": ""The indicator of whether the SFD state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks equality between a signal and a value."",
  ""|=>"": ""Specifies that if the left-hand condition holds at the clock edge, then the right-hand condition must be true in the next cycle.""
},
""Assertion Explaination"": ""At each rising edge of MRxClk, if MRxDV is 0 (data is not valid), then the SFD state must be off (StateSFD equals 0).""
},
""Assertion 20"": {
""Assertion"": ""@(posedge MRxClk) (StartIdle == 1) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""StartIdle"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal that synchronizes state transitions."",
  ""StartIdle"": ""A signal used to initiate the idle state."",
  ""StateDrop"": ""An internal flag indicating that the drop state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks if the value of the signal equals the provided constant."",
  ""|=>"": ""Implies that if the antecedent condition holds at a given clock edge, then the consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""At the rising edge of MRxClk, if StartIdle is asserted then the drop state must not be active (StateDrop equals 0).""
},
""Assertion 21"": {
""Assertion"": ""@(posedge MRxClk) (StartDrop == 1) |=> (StateDrop == 1);"",
""Signals"": [""MRxClk"", ""StartDrop"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal driving the transitions."",
  ""StartDrop"": ""A control signal that triggers the start of the drop state."",
  ""StateDrop"": ""An internal flag indicating that the drop state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Verifies equality between a signal and a value."",
  ""|=>"": ""Indicates that if the left-hand condition holds at a clock edge, then the right-hand condition is required in the subsequent cycle.""
},
""Assertion Explaination"": ""On the rising edge of MRxClk, if the drop start signal (StartDrop) is 1 then the drop state (StateDrop) will be active (equals 1) in the next cycle.""
},
""Assertion 22"": {
""Assertion"": ""@(posedge MRxClk) (StateDrop == 1 & StartIdle == 0) |=> (StateDrop == 1);"",
""Signals"": [""MRxClk"", ""StateDrop"", ""StartIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock signal."",
  ""StateDrop"": ""The internal flag indicating that the drop state is currently active."",
  ""StartIdle"": ""A control signal that would initiate the idle state.""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Tests equality between a signal and a constant."",
  ""&"": ""Logical AND operator combining conditions."",
  ""|=>"": ""Specifies that if the combined antecedent conditions hold at a clock edge, then the consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""At every rising edge of MRxClk, if the drop state is active and there is no idle start signal (StartIdle equals 0), then the drop state must remain active (StateDrop remains 1).""
},
""Assertion 23"": {
""Assertion"": ""@(posedge MRxClk) (StateSFD == 1 & StartDrop == 0) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""StateSFD"", ""StartDrop"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for synchronizing state transitions."",
  ""StateSFD"": ""The flag indicating if the SFD state is active."",
  ""StartDrop"": ""A control signal that initiates the drop state."",
  ""StateDrop"": ""An internal flag denoting the drop state.""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks for equality between signals and constants."",
  ""&"": ""Logical AND used to combine multiple conditions."",
  ""|=>"": ""Implies that if the antecedent is true at the clock edge, then the consequent must be true in the next cycle.""
},
""Assertion Explaination"": ""On a rising MRxClk edge, if the SFD state is active and the drop state is not being initiated (StartDrop equals 0), then the drop state must remain inactive (StateDrop equals 0).""
},
""Assertion 24"": {
""Assertion"": ""@(posedge MRxClk) (StateData[0] == 1 & StartDrop == 0) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""StateData[0]"", ""StartDrop"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock for the receive state machine."",
  ""StateData[0]"": ""The lower bit of the data state indicating a data reception phase."",
  ""StartDrop"": ""A signal that triggers the drop state."",
  ""StateDrop"": ""A flag indicating whether the drop state is active.""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Determines if two values are equal."",
  ""&"": ""Logical AND operator used to combine conditions."",
  ""|=>"": ""Specifies that if the antecedent condition holds at a clock edge, the consequent will hold in the following cycle.""
},
""Assertion Explaination"": ""At each rising edge of MRxClk, if the data state bit 0 is active and no drop is initiated (StartDrop equals 0), then the drop state must remain off (StateDrop equals 0).""
},
""Assertion 25"": {
""Assertion"": ""@(posedge MRxClk) (StatePreamble == 1) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""StatePreamble"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock signal."",
  ""StatePreamble"": ""An internal flag indicating that the preamble state is active."",
  ""StateDrop"": ""An internal flag indicating whether the drop state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks equality between a signal and a constant."",
  ""|=>"": ""If the left-hand condition holds at a clock edge, then the right-hand condition must hold in the next cycle.""
},
""Assertion Explaination"": ""At a rising edge of MRxClk, if the system is in the preamble state (StatePreamble equals 1), then the drop state must be off (StateDrop equals 0).""
},
""Assertion 26"": {
""Assertion"": ""@(posedge MRxClk) (StateData1 == 1) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""StateData1"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for state transitions."",
  ""StateData1"": ""The upper bit of the data state, indicating a phase of data reception."",
  ""StateDrop"": ""The flag showing whether the drop state is active.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Verifies that a signal equals a specified value."",
  ""|=>"": ""Indicates that if the antecedent is true at a clock edge, then the consequent must be true in the following clock cycle.""
},
""Assertion Explaination"": ""On the rising edge of MRxClk, if the upper bit of the data state (StateData1) is active then the drop state must be deactivated (StateDrop equals 0).""
},
""Assertion 27"": {
""Assertion"": ""@(posedge MRxClk) (MRxDV == 0) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""MRxDV"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the receiver."",
  ""MRxDV"": ""The data valid signal indicating whether data reception is occurring."",
  ""StateDrop"": ""An internal flag indicating the drop state activity.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Tests the equality of a signal with a constant value."",
  ""|=>"": ""Implies that if the left-hand condition holds at a clock edge, then the right-hand condition will hold in the next cycle.""
},
""Assertion Explaination"": ""At every rising clock edge, if MRxDV is 0 (no valid data) then the drop state must be off (StateDrop equals 0).""
},
""Assertion 28"": {
""Assertion"": ""@(posedge MRxClk) (Transmitting == 0 & StateIdle == 1) |=> (StateDrop == 0);"",
""Signals"": [""MRxClk"", ""Transmitting"", ""StateIdle"", ""StateDrop""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock signal."",
  ""Transmitting"": ""A flag indicating that a transmission is in progress."",
  ""StateIdle"": ""An internal state flag indicating the idle state of the receiver."",
  ""StateDrop"": ""A flag showing whether the drop state is active.""
},
""Logical Operators"": [""=="", ""&"", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks if a signal is equal to a given value."",
  ""&"": ""Logical AND used to combine conditions."",
  ""|=>"": ""Specifies that if the combined antecedent holds at a clock edge, then the consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""At each rising edge of MRxClk, if the system is not transmitting (Transmitting equals 0) and is in the idle state (StateIdle equals 1), then the drop state must not be active (StateDrop equals 0).""
},
""Assertion 29"": {
""Assertion"": ""@(posedge MRxClk) (StartIdle == 1) |=> (StateIdle == 1);"",
""Signals"": [""MRxClk"", ""StartIdle"", ""StateIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal that synchronizes the state machine."",
  ""StartIdle"": ""A control signal that triggers the transition to the idle state."",
  ""StateIdle"": ""An internal flag indicating that the receiver is in the idle state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Compares a signal to a constant value."",
  ""|=>"": ""Implies that if the antecedent is true at a clock edge, then the consequent must be true in the next cycle.""
},
""Assertion Explaination"": ""At the rising edge of MRxClk, if the idle start signal (StartIdle) is asserted then the idle state (StateIdle) must be active (equal to 1) in the following cycle.""
},
""Assertion 30"": {
""Assertion"": ""@(posedge MRxClk) (StartDrop == 1) |=> (StateIdle == 0);"",
""Signals"": [""MRxClk"", ""StartDrop"", ""StateIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for synchronization."",
  ""StartDrop"": ""A signal that initiates a transition to the drop state."",
  ""StateIdle"": ""The internal flag indicating whether the receiver is in the idle state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Verifies equality between a signal and a value."",
  ""|=>"": ""Implies that if the antecedent condition holds at a clock edge, the consequent must hold in the next cycle.""
},
""Assertion Explaination"": ""On every rising edge of MRxClk, if StartDrop is asserted then the idle state must be deactivated (StateIdle equals 0).""
},
""Assertion 31"": {
""Assertion"": ""@(posedge MRxClk) (StartSFD == 1) |=> (StateIdle == 0);"",
""Signals"": [""MRxClk"", ""StartSFD"", ""StateIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The receive clock for the state machine."",
  ""StartSFD"": ""A control signal that triggers the SFD state."",
  ""StateIdle"": ""A flag that indicates whether the receiver is in the idle state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks for equality."",
  ""|=>"": ""Specifies that if the left-hand side holds at a clock edge, then the right-hand side must hold in the next cycle.""
},
""Assertion Explaination"": ""At a rising edge of MRxClk, if the SFD start signal (StartSFD) is asserted then the idle state (StateIdle) must be off (equal to 0).""
},
""Assertion 32"": {
""Assertion"": ""@(posedge MRxClk) (StartPreamble == 1) |=> (StateIdle == 0);"",
""Signals"": [""MRxClk"", ""StartPreamble"", ""StateIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for the module."",
  ""StartPreamble"": ""A control signal that initiates the preamble state."",
  ""StateIdle"": ""A flag indicating whether the receiver is in the idle state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Compares a signal’s value with a constant."",
  ""|=>"": ""Indicates that if the antecedent holds on a clock edge, then the consequent must be true in the next cycle.""
},
""Assertion Explaination"": ""At every rising edge of MRxClk, if StartPreamble is asserted then the idle state must be deactivated (StateIdle equals 0).""
},
""Assertion 33"": {
""Assertion"": ""@(posedge MRxClk) (MRxDV == 1) |=> (StateIdle == 0);"",
""Signals"": [""MRxClk"", ""MRxDV"", ""StateIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal for state transitions."",
  ""MRxDV"": ""The receiver data valid signal that indicates active data reception."",
  ""StateIdle"": ""An internal flag showing whether the receiver is in the idle state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Checks equality between two values."",
  ""|=>"": ""Implies that if the left-hand condition holds at a clock edge, then the right-hand condition will hold in the next cycle.""
},
""Assertion Explaination"": ""At a rising edge of MRxClk, if MRxDV is asserted (i.e. data is valid) then the idle state must not be active (StateIdle equals 0).""
},
""Assertion 34"": {
""Assertion"": ""@(posedge MRxClk) (MRxDV == 0) |=> (StateIdle == 1);"",
""Signals"": [""MRxClk"", ""MRxDV"", ""StateIdle""],
""Signal Explanations"": {
  ""MRxClk"": ""The clock signal synchronizing state transitions."",
  ""MRxDV"": ""The receiver data valid signal indicating whether data is being received."",
  ""StateIdle"": ""A flag indicating that the receiver is in the idle state.""
},
""Logical Operators"": [""=="", ""|=>""],
""Logical Operators Explanation"": {
  ""=="": ""Tests for equality between a signal and a constant."",
  ""|=>"": ""Indicates that if the antecedent condition holds on a clock edge, then the consequent must be true in the next cycle.""
},
""Assertion Explaination"": ""At every rising edge of MRxClk, if MRxDV is deasserted (equals 0) then the receiver must be in the idle state (StateIdle equals 1).""
}
}"
