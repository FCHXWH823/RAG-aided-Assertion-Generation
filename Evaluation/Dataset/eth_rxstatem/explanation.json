{
  "Assertion 1": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartPreamble == 1) |=> (StatePreamble == 1)",
    "Signals": ["StartPreamble", "StatePreamble"],
    "Signal Explanations": {
      "StartPreamble": "the condition that initiates the preamble sequence",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the preamble sequence is equal to 1 then the indicator that the preamble sequence is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 2": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartDrop == 1) |=> (StatePreamble == 0)",
    "Signals": ["StartDrop", "StatePreamble"],
    "Signal Explanations": {
      "StartDrop": "the condition that initiates the drop state",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the drop state is equal to 1 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 3": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateSFD == 1) |=> (StatePreamble == 0)",
    "Signals": ["StateSFD", "StatePreamble"],
    "Signal Explanations": {
      "StateSFD": "the indicator that the Start Frame Delimiter state is active",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the Start Frame Delimiter state is active is equal to 1 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 4": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateData[0] == 1) |=> (StatePreamble == 0)",
    "Signals": ["StateData[0]", "StatePreamble"],
    "Signal Explanations": {
      "StateData[0]": "the indicator for the lower data state bit, representing active data reception",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator for the lower data state bit, representing active data reception, is equal to 1 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 5": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateDrop == 1) |=> (StatePreamble == 0)",
    "Signals": ["StateDrop", "StatePreamble"],
    "Signal Explanations": {
      "StateDrop": "the indicator that the drop state is active",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the drop state is active is equal to 1 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 6": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateData1 == 1) |=> (StatePreamble == 0)",
    "Signals": ["StateData1", "StatePreamble"],
    "Signal Explanations": {
      "StateData1": "the indicator for the upper data state bit, representing active data reception",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator for the upper data state bit, representing active data reception, is equal to 1 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 7": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StatePreamble == 1 & MRxDEq5 == 0 & MRxDV == 1) |=> (StatePreamble == 1)",
    "Signals": ["StatePreamble", "MRxDEq5", "MRxDV"],
    "Signal Explanations": {
      "StatePreamble": "the indicator that the preamble sequence is active",
      "MRxDEq5": "the condition that checks if a received value equals 5",
      "MRxDV": "the input signal that denotes receive data valid"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the preamble sequence is active is equal to 1 AND the condition checking if a received value equals 5 is equal to 0 AND the input signal that denotes receive data valid is equal to 1 then the indicator that the preamble sequence is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 8": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDEq5 == 1) |=> (StatePreamble == 0)",
    "Signals": ["MRxDEq5", "StatePreamble"],
    "Signal Explanations": {
      "MRxDEq5": "the condition that checks if a received value equals 5",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that checks if a received value equals 5 is equal to 1 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 9": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDV == 0) |=> (StatePreamble == 0)",
    "Signals": ["MRxDV", "StatePreamble"],
    "Signal Explanations": {
      "MRxDV": "the input signal that denotes receive data valid",
      "StatePreamble": "the indicator that the preamble sequence is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the input signal that denotes receive data valid is equal to 0 then the indicator that the preamble sequence is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 10": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartSFD == 1) |=> (StateSFD == 1)",
    "Signals": ["StartSFD", "StateSFD"],
    "Signal Explanations": {
      "StartSFD": "the condition that initiates the Start Frame Delimiter state",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the Start Frame Delimiter state is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 11": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartIdle == 1) |=> (StateSFD == 0)",
    "Signals": ["StartIdle", "StateSFD"],
    "Signal Explanations": {
      "StartIdle": "the condition that initiates the idle state",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the idle state is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 12": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartDrop == 1) |=> (StateSFD == 0)",
    "Signals": ["StartDrop", "StateSFD"],
    "Signal Explanations": {
      "StartDrop": "the condition that initiates the drop state",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the drop state is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 13": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartData0 == 1) |=> (StateSFD == 0)",
    "Signals": ["StartData0", "StateSFD"],
    "Signal Explanations": {
      "StartData0": "the condition that initiates the first part of the data state",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the first part of the data state is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 14": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartPreamble == 1) |=> (StateSFD == 0)",
    "Signals": ["StartPreamble", "StateSFD"],
    "Signal Explanations": {
      "StartPreamble": "the condition that initiates the preamble sequence",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the preamble sequence is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 15": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateSFD == 1 & StartIdle == 0 & MRxDEqD == 0) |=> (StateSFD == 1)",
    "Signals": ["StateSFD", "StartIdle", "MRxDEqD"],
    "Signal Explanations": {
      "StateSFD": "the indicator that the Start Frame Delimiter state is active",
      "StartIdle": "the condition that initiates the idle state",
      "MRxDEqD": "the condition that checks if a received value equals the delimiter D"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the Start Frame Delimiter state is active is equal to 1 AND the condition that initiates the idle state is equal to 0 AND the condition that checks if a received value equals the delimiter D is equal to 0 then the indicator that the Start Frame Delimiter state is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 16": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateData[0] == 1) |=> (StateSFD == 0)",
    "Signals": ["StateData[0]", "StateSFD"],
    "Signal Explanations": {
      "StateData[0]": "the indicator for the lower data state bit, representing active data reception",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator for the lower data state bit, representing active data reception, is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 17": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateDrop == 1) |=> (StateSFD == 0)",
    "Signals": ["StateDrop", "StateSFD"],
    "Signal Explanations": {
      "StateDrop": "the indicator that the drop state is active",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the drop state is active is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 18": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDEq5 == 0 & StatePreamble == 1) |=> (StateSFD == 0)",
    "Signals": ["MRxDEq5", "StatePreamble", "StateSFD"],
    "Signal Explanations": {
      "MRxDEq5": "the condition that checks if a received value equals 5",
      "StatePreamble": "the indicator that the preamble sequence is active",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the combined condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that checks if a received value equals 5 is equal to 0 AND the indicator that the preamble sequence is active is equal to 1 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 19": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDV == 0) |=> (StateSFD == 0)",
    "Signals": ["MRxDV", "StateSFD"],
    "Signal Explanations": {
      "MRxDV": "the input signal that denotes receive data valid",
      "StateSFD": "the indicator that the Start Frame Delimiter state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the input signal that denotes receive data valid is equal to 0 then the indicator that the Start Frame Delimiter state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 20": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartIdle == 1) |=> (StateDrop == 0)",
    "Signals": ["StartIdle", "StateDrop"],
    "Signal Explanations": {
      "StartIdle": "the condition that initiates the idle state",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the idle state is equal to 1 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 21": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartDrop == 1) |=> (StateDrop == 1)",
    "Signals": ["StartDrop", "StateDrop"],
    "Signal Explanations": {
      "StartDrop": "the condition that initiates the drop state",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the drop state is equal to 1 then the indicator that the drop state is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 22": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateDrop == 1 & StartIdle == 0) |=> (StateDrop == 1)",
    "Signals": ["StateDrop", "StartIdle"],
    "Signal Explanations": {
      "StateDrop": "the indicator that the drop state is active",
      "StartIdle": "the condition that initiates the idle state"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the combined condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the drop state is active is equal to 1 AND the condition that initiates the idle state is equal to 0 then the indicator that the drop state is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 23": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateSFD == 1 & StartDrop == 0) |=> (StateDrop == 0)",
    "Signals": ["StateSFD", "StartDrop", "StateDrop"],
    "Signal Explanations": {
      "StateSFD": "the indicator that the Start Frame Delimiter state is active",
      "StartDrop": "the condition that initiates the drop state",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the combined condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the Start Frame Delimiter state is active is equal to 1 AND the condition that initiates the drop state is equal to 0 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 24": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateData[0] == 1 & StartDrop == 0) |=> (StateDrop == 0)",
    "Signals": ["StateData[0]", "StartDrop", "StateDrop"],
    "Signal Explanations": {
      "StateData[0]": "the indicator for the lower data state bit, representing active data reception",
      "StartDrop": "the condition that initiates the drop state",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the combined condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator for the lower data state bit, representing active data reception, is equal to 1 AND the condition that initiates the drop state is equal to 0 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 25": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StatePreamble == 1) |=> (StateDrop == 0)",
    "Signals": ["StatePreamble", "StateDrop"],
    "Signal Explanations": {
      "StatePreamble": "the indicator that the preamble sequence is active",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator that the preamble sequence is active is equal to 1 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 26": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StateData1 == 1) |=> (StateDrop == 0)",
    "Signals": ["StateData1", "StateDrop"],
    "Signal Explanations": {
      "StateData1": "the indicator for the upper data state bit, representing active data reception",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the indicator for the upper data state bit, representing active data reception, is equal to 1 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 27": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDV == 0) |=> (StateDrop == 0)",
    "Signals": ["MRxDV", "StateDrop"],
    "Signal Explanations": {
      "MRxDV": "the input signal that denotes receive data valid",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the input signal that denotes receive data valid is equal to 0 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 28": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(Transmitting == 0 & StateIdle == 1) |=> (StateDrop == 0)",
    "Signals": ["Transmitting", "StateIdle", "StateDrop"],
    "Signal Explanations": {
      "Transmitting": "the input signal indicating that transmission is in progress",
      "StateIdle": "the indicator that the idle state is active",
      "StateDrop": "the indicator that the drop state is active"
    },
    "Logical Operators": ["==", "&", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "&": "logical AND",
      "|=>": "if the combined condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the input signal indicating that transmission is in progress is equal to 0 AND the indicator that the idle state is active is equal to 1 then the indicator that the drop state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 29": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartIdle == 1) |=> (StateIdle == 1)",
    "Signals": ["StartIdle", "StateIdle"],
    "Signal Explanations": {
      "StartIdle": "the condition that initiates the idle state",
      "StateIdle": "the indicator that the idle state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the idle state is equal to 1 then the indicator that the idle state is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 30": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartDrop == 1) |=> (StateIdle == 0)",
    "Signals": ["StartDrop", "StateIdle"],
    "Signal Explanations": {
      "StartDrop": "the condition that initiates the drop state",
      "StateIdle": "the indicator that the idle state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the drop state is equal to 1 then the indicator that the idle state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 31": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartSFD == 1) |=> (StateIdle == 0)",
    "Signals": ["StartSFD", "StateIdle"],
    "Signal Explanations": {
      "StartSFD": "the condition that initiates the Start Frame Delimiter state",
      "StateIdle": "the indicator that the idle state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the Start Frame Delimiter state is equal to 1 then the indicator that the idle state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 32": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(StartPreamble == 1) |=> (StateIdle == 0)",
    "Signals": ["StartPreamble", "StateIdle"],
    "Signal Explanations": {
      "StartPreamble": "the condition that initiates the preamble sequence",
      "StateIdle": "the indicator that the idle state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the condition that initiates the preamble sequence is equal to 1 then the indicator that the idle state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 33": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDV == 1) |=> (StateIdle == 0)",
    "Signals": ["MRxDV", "StateIdle"],
    "Signal Explanations": {
      "MRxDV": "the input signal that denotes receive data valid",
      "StateIdle": "the indicator that the idle state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the input signal that denotes receive data valid is equal to 1 then the indicator that the idle state is active is equal to 0 SINCE NEXT CLOCK CYCLE"
  },
  "Assertion 34": {
    "clock signal condition": "@(posedge MRxClk)",
    "disable condition": "none",
    "logical expression": "(MRxDV == 0) |=> (StateIdle == 1)",
    "Signals": ["MRxDV", "StateIdle"],
    "Signal Explanations": {
      "MRxDV": "the input signal that denotes receive data valid",
      "StateIdle": "the indicator that the idle state is active"
    },
    "Logical Operators": ["==", "|=>"],
    "Logical Operators Explanation": {
      "==": "equal",
      "|=>": "if the condition on the left holds then the condition on the right must hold SINCE NEXT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the input signal that denotes receive data valid is equal to 0 then the indicator that the idle state is active is equal to 1 SINCE NEXT CLOCK CYCLE"
  }
}