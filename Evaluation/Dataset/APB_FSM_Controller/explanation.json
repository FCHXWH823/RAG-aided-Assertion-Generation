{
  "Assertion 1": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "1 |-> ##2 PRESENT_STATE == $past(NEXT_STATE)",
    "Signals": ["PRESENT_STATE", "NEXT_STATE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "NEXT_STATE": "the computed next state of the finite state machine"
    },
    "Logical Operators": ["|->", "##2", "==", "$past"],
    "Logical Operators Explanation": {
      "|->": "an overlapping implication operator meaning that if the condition on the left is met then the condition on the right must hold SINCE THE CURRENT CLOCK CYCLE",
      "##2": "a delay operator indicating that the condition on the right must be satisfied two clock cycles later",
      "==": "an equality operator ensuring that the two sides are equal",
      "$past": "a function that returns the value of a signal from a previous clock cycle"
    },
    "Assertion Explaination": "since the constant true condition holds, it implies that two clock cycles later the current finite state machine state is equal to the value of the computed next state from the immediately preceding clock cycle"
  },
  "Assertion 2": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "(PRESENT_STATE == ST_IDLE && valid && Hwrite) |-> (NEXT_STATE == ST_WWAIT)",
    "Signals": ["PRESENT_STATE", "ST_IDLE", "valid", "Hwrite", "NEXT_STATE", "ST_WWAIT"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_IDLE": "the idle state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwrite": "the signal indicating that the operation is a write",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WWAIT": "the write-wait state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the idle state and the transfer valid and write signals are asserted, then since the current clock cycle the computed next state must equal the write-wait state"
  },
  "Assertion 3": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_IDLE && valid && !Hwrite |-> NEXT_STATE == ST_READ",
    "Signals": ["PRESENT_STATE", "ST_IDLE", "valid", "Hwrite", "NEXT_STATE", "ST_READ"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_IDLE": "the idle state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwrite": "the signal indicating that the operation is a write",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_READ": "the read state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the idle state and the transfer valid signal is asserted while the write signal is deasserted, then since the current clock cycle the computed next state must equal the read state"
  },
  "Assertion 4": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_IDLE && !valid |-> NEXT_STATE == ST_IDLE",
    "Signals": ["PRESENT_STATE", "ST_IDLE", "valid", "NEXT_STATE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_IDLE": "the idle state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the idle state and the transfer valid signal is deasserted, then since the current clock cycle the computed next state must remain the idle state"
  },
  "Assertion 5": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WWAIT && !valid |-> NEXT_STATE == ST_WRITE",
    "Signals": ["PRESENT_STATE", "ST_WWAIT", "valid", "NEXT_STATE", "ST_WRITE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WWAIT": "the write-wait state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WRITE": "the write state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-wait state and the transfer valid signal is deasserted, then since the current clock cycle the computed next state must equal the write state"
  },
  "Assertion 6": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WWAIT && valid |-> NEXT_STATE == ST_WRITEP",
    "Signals": ["PRESENT_STATE", "ST_WWAIT", "valid", "NEXT_STATE", "ST_WRITEP"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WWAIT": "the write-wait state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WRITEP": "the write precondition state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-wait state and the transfer valid signal is asserted, then since the current clock cycle the computed next state must equal the write precondition state"
  },
  "Assertion 7": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_READ |-> NEXT_STATE == ST_RENABLE",
    "Signals": ["PRESENT_STATE", "ST_READ", "NEXT_STATE", "ST_RENABLE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_READ": "the read state constant of the finite state machine",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_RENABLE": "the read-enable state constant of the finite state machine"
    },
    "Logical Operators": ["==", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the read state then since the current clock cycle the computed next state must equal the read-enable state"
  },
  "Assertion 8": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WRITE && !valid |-> NEXT_STATE == ST_WENABLE",
    "Signals": ["PRESENT_STATE", "ST_WRITE", "valid", "NEXT_STATE", "ST_WENABLE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WRITE": "the write state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WENABLE": "the write-enable state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write state and the transfer valid signal is deasserted, then since the current clock cycle the computed next state must equal the write-enable state"
  },
  "Assertion 9": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WRITE && valid |-> NEXT_STATE == ST_WENABLEP",
    "Signals": ["PRESENT_STATE", "ST_WRITE", "valid", "NEXT_STATE", "ST_WENABLEP"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WRITE": "the write state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WENABLEP": "the write-enable precondition state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write state and the transfer valid signal is asserted, then since the current clock cycle the computed next state must equal the write-enable precondition state"
  },
  "Assertion 10": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WRITEP |-> NEXT_STATE == ST_WENABLEP",
    "Signals": ["PRESENT_STATE", "ST_WRITEP", "NEXT_STATE", "ST_WENABLEP"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WRITEP": "the write precondition state constant of the finite state machine",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WENABLEP": "the write-enable precondition state constant of the finite state machine"
    },
    "Logical Operators": ["==", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write precondition state, then since the current clock cycle the computed next state must equal the write-enable precondition state"
  },
  "Assertion 11": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_RENABLE && !valid |-> NEXT_STATE == ST_IDLE",
    "Signals": ["PRESENT_STATE", "ST_RENABLE", "valid", "NEXT_STATE", "ST_IDLE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_RENABLE": "the read-enable state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_IDLE": "the idle state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning both conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the read-enable state and the transfer valid signal is deasserted, then since the current clock cycle the computed next state must equal the idle state"
  },
  "Assertion 12": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_RENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT",
    "Signals": ["PRESENT_STATE", "ST_RENABLE", "valid", "Hwrite", "NEXT_STATE", "ST_WWAIT"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_RENABLE": "the read-enable state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwrite": "the signal indicating that the operation is a write",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WWAIT": "the write-wait state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the read-enable state and both the transfer valid and write signals are asserted, then since the current clock cycle the computed next state must equal the write-wait state"
  },
  "Assertion 13": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_RENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ",
    "Signals": ["PRESENT_STATE", "ST_RENABLE", "valid", "Hwrite", "NEXT_STATE", "ST_READ"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_RENABLE": "the read-enable state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwrite": "the signal indicating that the operation is a write",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_READ": "the read state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the read-enable state and the transfer valid signal is asserted while the write signal is deasserted, then since the current clock cycle the computed next state must equal the read state"
  },
  "Assertion 14": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WENABLE && !valid |-> NEXT_STATE == ST_IDLE",
    "Signals": ["PRESENT_STATE", "ST_WENABLE", "valid", "NEXT_STATE", "ST_IDLE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WENABLE": "the write-enable state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_IDLE": "the idle state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-enable state and the transfer valid signal is deasserted, then since the current clock cycle the computed next state must equal the idle state"
  },
  "Assertion 15": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WENABLE && valid && Hwrite |-> NEXT_STATE == ST_WWAIT",
    "Signals": ["PRESENT_STATE", "ST_WENABLE", "valid", "Hwrite", "NEXT_STATE", "ST_WWAIT"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WENABLE": "the write-enable state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwrite": "the signal indicating that the operation is a write",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WWAIT": "the write-wait state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-enable state and both the transfer valid and write signals are asserted, then since the current clock cycle the computed next state must equal the write-wait state"
  },
  "Assertion 16": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WENABLE && valid && !Hwrite |-> NEXT_STATE == ST_READ",
    "Signals": ["PRESENT_STATE", "ST_WENABLE", "valid", "Hwrite", "NEXT_STATE", "ST_READ"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WENABLE": "the write-enable state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwrite": "the signal indicating that the operation is a write",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_READ": "the read state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-enable state and the transfer valid signal is asserted while the write signal is deasserted, then since the current clock cycle the computed next state must equal the read state"
  },
  "Assertion 17": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WENABLEP && !valid && Hwritereg |-> NEXT_STATE == ST_WRITE",
    "Signals": ["PRESENT_STATE", "ST_WENABLEP", "valid", "Hwritereg", "NEXT_STATE", "ST_WRITE"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WENABLEP": "the write-enable precondition state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwritereg": "the signal used as an additional write control",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WRITE": "the write state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-enable precondition state and the transfer valid signal is deasserted while the additional write control is asserted, then since the current clock cycle the computed next state must equal the write state"
  },
  "Assertion 18": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WENABLEP && valid && Hwritereg |-> NEXT_STATE == ST_WRITEP",
    "Signals": ["PRESENT_STATE", "ST_WENABLEP", "valid", "Hwritereg", "NEXT_STATE", "ST_WRITEP"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WENABLEP": "the write-enable precondition state constant of the finite state machine",
      "valid": "the signal indicating that a transfer is valid",
      "Hwritereg": "the signal used as an additional write control",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_WRITEP": "the write precondition state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-enable precondition state and both the transfer valid and additional write control signals are asserted, then since the current clock cycle the computed next state must equal the write precondition state"
  },
  "Assertion 19": {
    "clock signal condition": "@(posedge Hclk)",
    "disable condition": "disable iff (!Hresetn)",
    "logical expression": "PRESENT_STATE == ST_WENABLEP && !Hwritereg |-> NEXT_STATE == ST_READ",
    "Signals": ["PRESENT_STATE", "ST_WENABLEP", "Hwritereg", "NEXT_STATE", "ST_READ"],
    "Signal Explanations": {
      "PRESENT_STATE": "the current finite state machine state",
      "ST_WENABLEP": "the write-enable precondition state constant of the finite state machine",
      "Hwritereg": "the signal used as an additional write control",
      "NEXT_STATE": "the computed next state of the finite state machine",
      "ST_READ": "the read state constant of the finite state machine"
    },
    "Logical Operators": ["==", "&&", "!", "|->"],
    "Logical Operators Explanation": {
      "==": "an equality operator ensuring both sides are equal",
      "&&": "a logical AND operator meaning all conditions must be true",
      "!": "a logical NOT operator indicating the signal is deasserted",
      "|->": "an overlapping implication operator meaning that if the left condition is met then the right condition must hold SINCE THE CURRENT CLOCK CYCLE"
    },
    "Assertion Explaination": "if the current finite state machine state equals the write-enable precondition state and the additional write control signal is deasserted, then since the current clock cycle the computed next state must equal the read state"
  }
}