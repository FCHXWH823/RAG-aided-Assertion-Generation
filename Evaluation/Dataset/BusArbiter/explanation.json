{
  "Assertion 1": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "bus_grant[0] + bus_grant[1] + bus_grant[2] < 2",
    "Signals": [
      "bus_grant[0]",
      "bus_grant[1]",
      "bus_grant[2]"
    ],
    "Signal Explanations": {
      "bus_grant[0]": "the first output grant signal from the arbiter",
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[2]": "the third output grant signal from the arbiter"
    },
    "Logical Operators": [
      "+",
      "<"
    ],
    "Logical Operators Explanation": {
      "+": "the arithmetic addition operator that sums the values of signals",
      "<": "the less-than comparison operator ensuring the sum is below a given constant"
    },
    "Assertion Explaination": "if the arithmetic addition of the first output grant signal, the second output grant signal, and the third output grant signal is computed then the result must be less than the constant two"
  },
  "Assertion 2": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "bus_grant[0] |-> (!bus_grant[1] && !bus_grant[2])",
    "Signals": [
      "bus_grant[0]",
      "bus_grant[1]",
      "bus_grant[2]"
    ],
    "Signal Explanations": {
      "bus_grant[0]": "the first output grant signal from the arbiter",
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[2]": "the third output grant signal from the arbiter"
    },
    "Logical Operators": [
      "|->",
      "!",
      "&&"
    ],
    "Logical Operators Explanation": {
      "|->": "an overlapping implication operator meaning that if the condition on the left is true then the condition on the right must hold in the current clock cycle",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "&&": "the logical AND operator ensuring both conditions are true"
    },
    "Assertion Explaination": "if the first output grant signal is set then it implies using the overlapping implication operator that both the negation of the second output grant signal and the negation of the third output grant signal are true in the current clock cycle"
  },
  "Assertion 3": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "bus_grant[1] |-> (!bus_grant[0] && !bus_grant[2])",
    "Signals": [
      "bus_grant[1]",
      "bus_grant[0]",
      "bus_grant[2]"
    ],
    "Signal Explanations": {
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[0]": "the first output grant signal from the arbiter",
      "bus_grant[2]": "the third output grant signal from the arbiter"
    },
    "Logical Operators": [
      "|->",
      "!",
      "&&"
    ],
    "Logical Operators Explanation": {
      "|->": "an overlapping implication operator meaning that if the condition on the left is true then the condition on the right must hold in the current clock cycle",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "&&": "the logical AND operator ensuring both conditions are true"
    },
    "Assertion Explaination": "if the second output grant signal is set then it implies using the overlapping implication operator that both the negation of the first output grant signal and the negation of the third output grant signal are true in the current clock cycle"
  },
  "Assertion 4": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "bus_grant[2] |-> (!bus_grant[1] && !bus_grant[0])",
    "Signals": [
      "bus_grant[2]",
      "bus_grant[1]",
      "bus_grant[0]"
    ],
    "Signal Explanations": {
      "bus_grant[2]": "the third output grant signal from the arbiter",
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[0]": "the first output grant signal from the arbiter"
    },
    "Logical Operators": [
      "|->",
      "!",
      "&&"
    ],
    "Logical Operators Explanation": {
      "|->": "an overlapping implication operator meaning that if the condition on the left is true then the condition on the right must hold in the current clock cycle",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "&&": "the logical AND operator ensuring both conditions are true"
    },
    "Assertion Explaination": "if the third output grant signal is set then it implies using the overlapping implication operator that both the negation of the second output grant signal and the negation of the first output grant signal are true in the current clock cycle"
  },
  "Assertion 5": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "bus_grant != NO_GRANT && bus_ack != 1 |=> $stable(bus_grant)",
    "Signals": [
      "bus_grant",
      "NO_GRANT",
      "bus_ack",
      "$stable(bus_grant)"
    ],
    "Signal Explanations": {
      "bus_grant": "the output grant signal vector from the arbiter",
      "NO_GRANT": "the constant representing no grant",
      "bus_ack": "the bus acknowledge input signal",
      "$stable(bus_grant)": "a temporal check ensuring that the output grant signal remains unchanged"
    },
    "Logical Operators": [
      "!=",
      "&&",
      "|=>",
      "$stable"
    ],
    "Logical Operators Explanation": {
      "!=": "the not equal operator checking inequality",
      "&&": "the logical AND operator combining conditions",
      "|=>": "a non-overlapping implication operator meaning that if the conditions on the left are true then the condition on the right must hold starting the next clock cycle",
      "$stable": "a temporal operator that asserts the value remains unchanged relative to the previous clock cycle"
    },
    "Assertion Explaination": "if the output grant signal is not equal to the no grant constant and the bus acknowledge signal is not equal to one then it implies using the non-overlapping implication operator that the output grant signal remains unchanged starting the next clock cycle"
  },
  "Assertion 6": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "(bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[0]) |=> (bus_grant[0] && !bus_grant[1] && !bus_grant[2])",
    "Signals": [
      "bus_req[0]",
      "bus_grant",
      "NO_GRANT",
      "bus_ack",
      "bus_grant[0]",
      "bus_grant[1]",
      "bus_grant[2]"
    ],
    "Signal Explanations": {
      "bus_req[0]": "the first input request signal from a master",
      "bus_grant": "the output grant signal vector from the arbiter",
      "NO_GRANT": "the constant representing no grant",
      "bus_ack": "the bus acknowledge input signal",
      "bus_grant[0]": "the first output grant signal from the arbiter",
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[2]": "the third output grant signal from the arbiter"
    },
    "Logical Operators": [
      "&&",
      "==",
      "||",
      "|=>",
      "!",
      "&&"
    ],
    "Logical Operators Explanation": {
      "&&": "the logical AND operator ensuring both conditions are true",
      "==": "the equality operator checking equivalence",
      "||": "the logical OR operator meaning at least one condition must be true",
      "|=>": "a non-overlapping implication operator meaning that if the left condition is true then the right condition must hold starting the next clock cycle",
      "!": "the logical NOT operator indicating a signal is reset (0)"
    },
    "Assertion Explaination": "if either the condition that the first input request signal is set and the output grant signal equals the no grant constant or the condition that the bus acknowledge signal is set and the first input request signal is set holds then it implies using the non-overlapping implication operator that the first output grant signal is set and both the negation of the second and the negation of the third output grant signals are true starting the next clock cycle"
  },
  "Assertion 7": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "(bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[1] && !bus_req[0]) |=> (!bus_grant[0] && bus_grant[1] && !bus_grant[2])",
    "Signals": [
      "bus_req[1]",
      "bus_req[0]",
      "bus_grant",
      "NO_GRANT",
      "bus_ack",
      "bus_grant[0]",
      "bus_grant[1]",
      "bus_grant[2]"
    ],
    "Signal Explanations": {
      "bus_req[1]": "the second input request signal from a master",
      "bus_req[0]": "the first input request signal from a master",
      "bus_grant": "the output grant signal vector from the arbiter",
      "NO_GRANT": "the constant representing no grant",
      "bus_ack": "the bus acknowledge input signal",
      "bus_grant[0]": "the first output grant signal from the arbiter",
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[2]": "the third output grant signal from the arbiter"
    },
    "Logical Operators": [
      "&&",
      "!",
      "==",
      "||",
      "|=>",
      "&&",
      "!"
    ],
    "Logical Operators Explanation": {
      "&&": "the logical AND operator ensuring all combined conditions are true",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "==": "the equality operator checking equivalence",
      "||": "the logical OR operator meaning at least one condition must be true",
      "|=>": "a non-overlapping implication operator meaning that if the left condition is true then the right condition must hold starting the next clock cycle"
    },
    "Assertion Explaination": "if either the condition that the second input request signal is set while the first input request signal is reset and the output grant signal equals the no grant constant or the condition that the bus acknowledge signal is set and the second input request signal is set while the first input request signal is reset holds then it implies using the non-overlapping implication operator that the second output grant signal is set and both the negation of the first output grant signal and the negation of the third output grant signal are true starting the next clock cycle"
  },
  "Assertion 8": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "(bus_req[2] && !bus_req[1] && !bus_req[0] && bus_grant == NO_GRANT) || (bus_ack && bus_req[2] && !bus_req[0] && !bus_req[1]) |=> (!bus_grant[0] && !bus_grant[1] && bus_grant[2])",
    "Signals": [
      "bus_req[2]",
      "bus_req[1]",
      "bus_req[0]",
      "bus_grant",
      "NO_GRANT",
      "bus_ack",
      "bus_grant[0]",
      "bus_grant[1]",
      "bus_grant[2]"
    ],
    "Signal Explanations": {
      "bus_req[2]": "the third input request signal from a master",
      "bus_req[1]": "the second input request signal from a master",
      "bus_req[0]": "the first input request signal from a master",
      "bus_grant": "the output grant signal vector from the arbiter",
      "NO_GRANT": "the constant representing no grant",
      "bus_ack": "the bus acknowledge input signal",
      "bus_grant[0]": "the first output grant signal from the arbiter",
      "bus_grant[1]": "the second output grant signal from the arbiter",
      "bus_grant[2]": "the third output grant signal from the arbiter"
    },
    "Logical Operators": [
      "&&",
      "!",
      "==",
      "||",
      "|=>",
      "&&",
      "!"
    ],
    "Logical Operators Explanation": {
      "&&": "the logical AND operator ensuring all combined conditions are true",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "==": "the equality operator checking equivalence",
      "||": "the logical OR operator meaning at least one condition must be true",
      "|=>": "a non-overlapping implication operator meaning that if the left condition is true then the right condition must hold starting the next clock cycle"
    },
    "Assertion Explaination": "if either the condition that the third input request signal is set while both the second and the first input request signals are reset and the output grant signal equals the no grant constant or the condition that the bus acknowledge signal is set and the third input request signal is set while both the first and the second input request signals are reset holds then it implies using the non-overlapping implication operator that the third output grant signal is set and both the negation of the first output grant signal and the negation of the second output grant signal are true starting the next clock cycle"
  },
  "Assertion 9": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "$rose(bus_grant[1]) |-> ($past(bus_req[1]) && !$past(bus_req[0]))",
    "Signals": [
      "$rose(bus_grant[1])",
      "$past(bus_req[1])",
      "$past(bus_req[0])"
    ],
    "Signal Explanations": {
      "$rose(bus_grant[1])": "a check indicating a rising edge on the second output grant signal",
      "$past(bus_req[1])": "the previous clock cycle value of the second input request signal",
      "$past(bus_req[0])": "the previous clock cycle value of the first input request signal"
    },
    "Logical Operators": [
      "$rose",
      "|->",
      "$past",
      "!",
      "&&"
    ],
    "Logical Operators Explanation": {
      "$rose": "a temporal operator that detects a transition of a signal from 0 to 1 in the current clock cycle",
      "|->": "an overlapping implication operator meaning that if the left condition is true then the right condition must hold in the current clock cycle",
      "$past": "a temporal operator that refers to the value of a signal in the previous clock cycle",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "&&": "the logical AND operator ensuring both conditions are true"
    },
    "Assertion Explaination": "if a rising edge is detected on the second output grant signal then it implies using the overlapping implication operator that in the previous clock cycle the second input request signal was set and the first input request signal was reset"
  },
  "Assertion 10": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "",
    "logical expression": "$rose(bus_grant[2]) |-> ($past(bus_req[2]) && !$past(bus_req[1]) && !$past(bus_req[0]))",
    "Signals": [
      "$rose(bus_grant[2])",
      "$past(bus_req[2])",
      "$past(bus_req[1])",
      "$past(bus_req[0])"
    ],
    "Signal Explanations": {
      "$rose(bus_grant[2])": "a check indicating a rising edge on the third output grant signal",
      "$past(bus_req[2])": "the previous clock cycle value of the third input request signal",
      "$past(bus_req[1])": "the previous clock cycle value of the second input request signal",
      "$past(bus_req[0])": "the previous clock cycle value of the first input request signal"
    },
    "Logical Operators": [
      "$rose",
      "|->",
      "$past",
      "!",
      "&&"
    ],
    "Logical Operators Explanation": {
      "$rose": "a temporal operator that detects a transition of a signal from 0 to 1 in the current clock cycle",
      "|->": "an overlapping implication operator meaning that if the left condition is true then the right condition must hold in the current clock cycle",
      "$past": "a temporal operator that refers to the value of a signal in the previous clock cycle",
      "!": "the logical NOT operator indicating a signal is reset (0)",
      "&&": "the logical AND operator ensuring all conditions are true"
    },
    "Assertion Explaination": "if a rising edge is detected on the third output grant signal then it implies using the overlapping implication operator that in the previous clock cycle the third input request signal was set while both the second and the first input request signals were reset"
  }
}