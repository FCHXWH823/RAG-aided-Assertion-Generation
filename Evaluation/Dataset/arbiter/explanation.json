{
  "Assertion 1": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[0] && $past(arb_type == 3'd0)) |-> $past(req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the first arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme zero, then the stored request information from the previous clock cycle indicates that the first request was active"
  },
  "Assertion 2": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[1] && $past(arb_type == 3'd0)) |-> $past(req[1] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical (or bitwise) AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the second arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme zero, then the stored request information from the previous clock cycle indicates that the second request was active while the first request was not active"
  },
  "Assertion 3": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[2] && $past(arb_type == 3'd0)) |-> $past(req[2] & ~req[1] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines multiple conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the third arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme zero, then the stored request information from the previous clock cycle indicates that the third request was active while the second and first requests were not active"
  },
  "Assertion 4": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[3] && $past(arb_type == 3'd0)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines multiple conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the fourth arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme zero, then the stored request information from the previous clock cycle indicates that the fourth request was active while the third, second, and first requests were not active"
  },
  "Assertion 5": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[0] && $past(arb_type == 3'd1)) |-> $past(req[0] & ~req[1])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the first arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme one, then the stored request information from the previous clock cycle indicates that the first request was active and the second request was not active"
  },
  "Assertion 6": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[1] && $past(arb_type == 3'd1)) |-> $past(req[1])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the second arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme one, then the stored request information from the previous clock cycle indicates that the second request was active"
  },
  "Assertion 7": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[2] && $past(arb_type == 3'd1)) |-> $past(req[2] & ~req[1] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the third arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme one, then the stored request information from the previous clock cycle indicates that the third request was active while both the second and first requests were not active"
  },
  "Assertion 8": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[3] && $past(arb_type == 3'd1)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the fourth arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme one, then the stored request information from the previous clock cycle indicates that the fourth request was active while the third, second, and first requests were not active"
  },
  "Assertion 9": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[0] && $past(arb_type == 3'd2)) |-> $past(req[0] & ~req[2])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the first arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme two, then the stored request information from the previous clock cycle indicates that the first request was active while the third request was not active"
  },
  "Assertion 10": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[1] && $past(arb_type == 3'd2)) |-> $past(req[1] & ~req[2] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the second arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme two, then the stored request information from the previous clock cycle indicates that the second request was active while the first and third requests were not active"
  },
  "Assertion 11": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[2] && $past(arb_type == 3'd2)) |-> $past(req[2])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the third arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme two, then the stored request information from the previous clock cycle indicates that the third request was active"
  },
  "Assertion 12": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[3] && $past(arb_type == 3'd2)) |-> $past(req[3] & ~req[2] & ~req[1] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the fourth arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme two, then the stored request information from the previous clock cycle indicates that the fourth request was active while the third, second, and first requests were not active"
  },
  "Assertion 13": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[0] && $past(arb_type == 3'd3)) |-> $past(req[0] & ~req[3])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the first arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme three, then the stored request information from the previous clock cycle indicates that the first request was active while the fourth request was not active"
  },
  "Assertion 14": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[1] && $past(arb_type == 3'd3)) |-> $past(req[1] & ~req[3] & ~req[0])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the second arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme three, then the stored request information from the previous clock cycle indicates that the second request was active while the fourth and first requests were not active"
  },
  "Assertion 15": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[2] && $past(arb_type == 3'd3)) |-> $past(req[2] & ~req[3] & ~req[0] & ~req[1])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "&", "~", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "&": "logical AND that combines conditions",
      "~": "logical NOT which inverts the value of a signal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the third arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme three, then the stored request information from the previous clock cycle indicates that the third request was active while the fourth, first, and second requests were not active"
  },
  "Assertion 16": {
    "clock signal condition": "@(posedge clk)",
    "disable condition": "disable iff (~rst_n)",
    "logical expression": "(gnt[3] && $past(arb_type == 3'd3)) |-> $past(req[3])",
    "Signals": ["gnt", "arb_type", "req"],
    "Signal Explanations": {
      "gnt": "the grant output vector that indicates which request is granted",
      "arb_type": "the arbitration type signal that selects the arbitration scheme",
      "req": "the request signal vector representing pending client requests"
    },
    "Logical Operators": ["&&", "$past", "==", "|->"],
    "Logical Operators Explanation": {
      "&&": "logical AND that yields true when both operands are true",
      "$past": "temporal operator returning the value of a signal from the previous clock cycle",
      "==": "equality operator that checks if two values are equal",
      "|->": "overlapping implication operator which means that if the left-hand condition holds then the right-hand condition must hold in the current clock cycle"
    },
    "Assertion Explaination": "if the output grant of the fourth arbitration line is asserted and the stored arbitration selection from the previous clock cycle equals the fixed scheme three, then the stored request information from the previous clock cycle indicates that the fourth request was active"
  }
}