{"Op": "not", "Op_Regex": "not", "Usage": "not property_expr",  "Explanation": "if property_expr evaluates to true, then not property_expr evaluates to false; and if property_expr evaluates to false, then not property_expr evaluates to true."}
{"Op": "or", "Op_Regex": "or", "Usage": "property_expr1 or property_expr2",  "Explanation": "property_expr1 evaluates to true or property_expr2 evaluates to true."}
{"Op": "and", "Op_Regex": "and", "Usage": "property_expr1 and property_expr2",  "Explanation": "property_expr1 evaluates to true and property_expr2 evaluates to true."}
{"Op": "|->", "Op_Regex": "\\|\\-\\>", "Usage": "sequence_expr |-> property_expr",  "Explanation": "for every match of the sequence_expr beginning at the start point, the evaluation of the property_expr beginning in the current clock cycle at the end point of the match succeeds and returns true."}
{"Op": "|=>", "Op_Regex": "\\|\\=\\>", "Usage": "sequence_expr |=> property_expr",  "Explanation": "for every match of the sequence_expr beginning at the start point, the evaluation of the property_expr beginning at the next clock cyle after the end point of the match succeeds and returns true."}
{"Op": "nexttime", "Op_Regex": "nexttime", "Usage": "nexttime property_expr",  "Explanation": "evaluates to true beginning at the next clock tick or there is no further clock tick."}
{"Op": "s_nexttime", "Op_Regex": "s_nexttime", "Usage": "s_nexttime property_expr",  "Explanation": "evaluates to true if, and only if, there exists a next clock tick and property_expr evaluates to true beginning at that clock tick."}
{"Op": "s_eventually", "Op_Regex": "s_eventually", "Usage": "s_eventually property_expr",  "Explanation": "A property s_eventually property_expr evaluates to true if, and only if, there exists a current or future clock tick at which property_expr evaluates to true."}
{"Op": "eventually [ constant_range ]", "Op_Regex": "eventually\\s*\\[\\s*(\\d+)\\s*:\\s*(\\d+)\\s*\\]", "Usage": "eventually [ constant_range ] property_expr",  "Explanation": "evaluates to true if, and only if, either there exists a current or future clock tick within the range specified by constant_range at which property_expr evaluates to true or not all the current or future clock ticks within the range specified by constant_range exist."}
{"Op": "[*N]", "Op_Regex": "\\[\\*(\\d+)\\]",  "Usage": "sequence_expr [*N]",  "Explanation": "the operand sequence must match N times in succession"}
{"Op": "[->N]", "Op_Regex": "\\[\\-\\>(\\d+)\\]",  "Usage": "boolean_expr [->N]",  "Explanation": "specifies finitely many iterative matches of the operand Boolean expression, with a delay of N clock ticks from one match of the operand to the next successive match and no match of the operand strictly in between. The overall repetition sequence matches at the last iterative match of the operand."}
{"Op": "[=N]", "Op_Regex": "\\[=(\\d+)\\]",  "Usage": "boolean_expr [=N]",  "Explanation": "specifies finitely many iterative matches of the operand Boolean expression, with a delay of N clock ticks from one match of the operand to the next successive match and no match of the operand strictly in between. The overall repetition sequence matches at or after the last iterative match of the operand, but before any later match of the operand."}
{"Op": "$rose", "Op_Regex": "\\$rose",  "Usage": "$rose(expr)",  "Explanation": "returns true (1'b1) if the LSB of the expression changed to 1. Otherwise, it returns false (1'b0)."}
{"Op": "$fell", "Op_Regex": "\\$fell",  "Usage": "$fell(expr)",  "Explanation": "returns true (1'b1) if the LSB of the expression changed to 0. Otherwise, it returns false (1'b0)."}
{"Op": "$stable", "Op_Regex": "\\$stable",  "Usage": "$stable(expr)",  "Explanation": "returns true (1'b1) if the value of the expression did not change. Otherwise, it returns false (1'b0)."}
{"Op": "$changed", "Op_Regex": "\\$changed",  "Usage": "$changed(expr)",  "Explanation": "returns true (1'b1) if the value of the expression changed. Otherwise, it returns false (1'b0)."}
{"Op": "$past", "Op_Regex": "\\$past",  "Usage":"$past(expr, num_of_ticks)",  "Explanation": "returns the sampled value of expr in a particular time step strictly prior to the one in which $past is evaluated."}
{"Op": "and", "Op_Regex": "and",  "Usage": "sequence_expr and sequence_expr",  "Explanation": "the sequence requires both the two operands shall match."}
{"Op": "or", "Op_Regex": "or",  "Usage": "sequence_expr or sequence_expr",  "Explanation": "the sequence requires at least one of the two operands shall match."}
{"Op": "intersect", "Op_Regex": "intersect",  "Usage": "sequence_expr intersect sequence_expr",  "Explanation": "The requirements for match of the intersect operation are as follows: 1. Both the operands shall match. 2. The lengths of the two matches of the operand sequences shall be the same."}
{"Op": "throughout", "Op_Regex": "throughout",  "Usage": "expr throughout sequence_expr",  "Explanation": "the sequnce matches along a finite interval of consecutive clock ticks provided seq matches along the interval and exp evaluates to true at each clock tick of the interval."}
{"Op": "##N", "Op_Regex": "\\#\\#(\\d+)",  "Usage": "##N sequence_expr",  "Explanation": "the evaluation of sequence_expr is delayed by N clock ticks."}